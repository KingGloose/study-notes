# 浏览器工作原理

^e5e468

[【干货】浏览器是如何运作的？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1x54y1B7RE?spm_id_from=333.999.0.0)

## 1. 浏览器发展史

![[00 assets/d89b937641a88dfb389936d5654f2091_MD5.png]]

各个浏览器使用的引擎

![[00 assets/eeb68c50ea80653fe927bb900f2f772a_MD5.png]]

## 2. 浏览器结构

![[00 assets/f85d12ff6eba0431428617b40a28890b_MD5.png]]

**用户界面**：用户界面主要包括：地址栏，后退/前进按钮，书签目录等；（除了从服务器请求到的网页窗口）

**浏览器引擎**：用来查询及操作渲染引擎的接口

**渲染引擎**：用来显示请求的 html 内容；（包括样式，图片，js）

**网络**：主要是来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作；

**UI 后端**：用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。

**JS 解释器** ：用来解释执行 JS 代码；

**数据存储**：用于数据的存储工作，比如 cookie 和 session

## 3. 进程和线程

具体可以参考 5:44-6:33

其实说句通俗的话，就是进程是工厂，但是线程就是打工仔

![[00 assets/0cac0b2540ce1988aa1c8e6bd96c440c_MD5.png]]

以前的浏览器是单线程，有下面 3 个不好的地方

![[00 assets/1a65db504e7dba5a5f765d72a743aa90_MD5.png]]

但是现在浏览器一般都是多进程了，具体被分为以下几个部分

浏览器是个多进程结构，

1. **浏览器进程**：控制除标签页外的用户界面，包括地址，书签，后退，前进按钮等，以及负责与其他浏览器进程负责协调工作
2. **缓存进程**
3. **网络进程**：发起网络请求
4. **渲染器进程**：渲染 Tab 页面的所有内容，但是有可能会为每个标签页是一个渲染进程，这和选择的模型有关系
5. **GPU 进程**：负责整个浏览器的工作
6. **插件进程**：内置插件(flash)，并不是指的自己安装的插件

其中在 Chromium 有四种不一样的模型

1. **Process-per-site-instance**：假如你打开一个网站，然后从这个网站链开的一系列网站都属于一个进程（右键新标签打开和新页面打开不行）。这是 Chrome 的默认模式。
2. **Process-per-site**：同域名范畴的网站放在一个进程，比如www.google.com和www.google.com/bookmarks就属于一个域名内（google有自己的判定机制），不论有没有互相打开的关系，都算作是一个进程中。用命令行--process-per-site开启。
3. **Process-per-tab**：这个简单，一个 tab 一个 process，不论各个 tab 的站点有无联系，就和宣传的那样。用--process-per-tab 开启。
4. **Single Process**：这个很熟悉了吧，传统浏览器的模式，没有多进程只有多线程，用--single-process 开启。

## 4. 连接网站

^af6e1f

[【干货】10 分钟带你了解互联网是如何运作的！\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1Rz4y197Jd/?spm_id_from=333.788.recommend_more_video.-1)

![[00 assets/d719fa9c01be70c9ca65ebee6188ec5f_MD5.png]]

互联网所有的传输都通过 TCP/IP 协议族来传输，TCP/IP 是**面向连接**的**可靠**字节流服务协议

**TCP/IP 协议分为 4 层**

**应用层**：提供特定于应用程序的协议 HTTP FTP IMAP(邮件)

**网络控制层**：发送数据包到计算机上使用特定的端口号的应用程序

**网络层**：使用 IP 地址将数据包发送到特定的计算

**链路层**：将二进制数据包与网络信号相互之间转换

**TCP 可靠**：tcp 在建立连接会进行三次握手，每个收到的数据包都会向发送方发送 ack 确认，已确保发送成功

**IP 不可靠**：IP 是不可靠的无连接协议，它并不关心数据包是否到达目的地，也不关系连接和端口号，目的是连接到目标 IP

**TCP 传输的质量和顺序**

当数据包过大，在网络层会进行分包，分包后传输的链路不一样，到达的时间不一样，TCP 会根据数据包上携带序列号来进行排序重组，如果发送方在一个特定时间内（也就是重试时间）没有接受到接收方的 ack 确认，会再次重新发送

**IP 和 IP 地址的区别**

Ip 是一种协议 有两种标准 IPv4 2^32 次方和 IPv6 2^128

IP 地址是一串数字 192.0.0.1

**互联网图**

每个计算机设备连接猫（调制解调器）将计算机的数字信号转换为可沿电话线的模拟信号，然后再连接当地的 ISP，当地的 ISP 再连接区域的，再往上连接......，而且每个 ISP 都会有一个路由器，里面包含了目标主机的 IP 地址，这样可以不用每次经过 NAP 来找到目标地址

![[00 assets/52ab4fd563001efa1f8de55b4f7c4413_MD5.png]]

**网络传输**

上面的图从下到上

1. 个人电脑
2. 猫
3. local ISP 互联网服务提供商
4. regional ISP 经过多个主干网络
5. NSP 网络服务提供商 大型网络 卖带宽给 ISP
6. NAP 每个 NSP 连接到至少三个网络访问点
7. ISP NSP 所有网络提供都携带路由器，每个路由有当前子网络 ip 的路由表，当底层向上层发送数据时候，找不到会依次向上找，可能由一个主干网络跳到另外一个主干网络。

**DNS 服务**

存在意义是 IP 别名，不让公司丢客户，也容易记，DNS 是一个分布式数据库，存储了域名和 IP 的对应关系

## 5. 浏览器工作

这里建议看原片 9:35-结尾的部分的动画

1.当你在浏览器的地址栏输入网址的时候，**浏览器进程**的**UI 线程**会捕捉你输入的内容

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040000498.png" alt="屏幕截图 2022-03-09 125909"  />

2.如果是网址，那么**UI 线程**就会开启**网络线程**来请求 DNS 来进行域名解析，服务器会返回返回数据

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040000519.png" alt="屏幕截图 2022-03-09 130101" style="zoom:80%;" />

3.浏览器通过网络请求后获取数据后，浏览器会通过**SafeBrowsing**来检查站点

4.当**网络线程**完成之后会将数据给**UI 线程**，UI 线程会创建一个**渲染器进程**，并且浏览器进程会将数据通过**IPC**管道来进行数据传输，正式进入渲染流程

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040000554.png" alt="屏幕截图 2022-03-09 130625" style="zoom: 67%;" />

5.**渲染器进程**的主线程将将**html**解析构造 DOM 树，首先是通过**Tokeniser**标记化，通过**词法分析**将输入的 html 内容解析为多个**标记**，对识别的标记进行**DOM 树构造**，在构造的同时会创建**document 对象**

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040000584.png" alt="屏幕截图 2022-03-09 155907" style="zoom:67%;" />

6.在 html 中有**图片**、**css**、**js**等内容，图片和 css 是通过**网络**下载的，并不会影响 html 的解析，但是在解析的时候遇到了**script**标签的话，就会**停止 html 解析流程**，这个时候去**解析和加载 js 脚本**

7.这个时候为什么要去加载 js 脚本呢？这是因为不清楚 js 脚本是否会改变 html 的结构，假如这个时候你写入一个**document.write()**的话，前面写的 html 结构就有问题了

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040000652.png" alt="屏幕截图 2022-03-09 160338" style="zoom:67%;" />

8.我们把 html 解析完毕之后，**渲染器进程**的主线程就会解析**css 样式**，并确定每个**DOM 节点**来计算样式

![[00 assets/dfef974718d34932c62c91645b807bad_MD5.png]]

9.这个时候就需要知道每个元素在页面中占多大的**空间**，**位置**在哪里这个过程称为**layout 布局**

![[00 assets/c044dfba8ef1b2a5762177332f4af440_MD5.png]]

10.**渲染器进程**的**主线程**根据**dom 树**和计算好的**样式**生成**layoutTree**，layoutTree 记录了位置坐标和尺寸

![[00 assets/2ab3c3ac68fc86fa59e642dff62709c8_MD5.png]]

但是这里要注意几个地方

1. 首先设置了**display:none**的元素，是不会出现在 Layout Tree 上，但是会出现在 DOM 树上
2. 但是通过伪类**::before**添加的元素会出现在 Layout Tree 上，但是不会出现在 DOM 树上

这是因为 DOM 是是通过解析 html 得出来的，但是 Layout Tree 是通过 DOM 树和计算样式得来的

11.**渲染器进程**的**主线程**通过遍历**Layout Tree**生成**绘制顺序表**

![[00 assets/f9b19a7e202866969bd3364d8ac0bff3_MD5.png]]

12.将上面的绘制的信息转换为像素点，这个过程被称为**栅格化**

13.**早期的栅格化**：只栅格化可视区域的位置

**现在的栅格化**：使用**合成器线程**来将页面的各个部分分为多个图层，分别对其进行栅格化，再将可视区内容组合成一帧

![[00 assets/01de6c9c7a8ba07d1d0fddf4f441ced0_MD5.png]]

14.然后**渲染器进程**的**主线程**遍历**layoutTree**生成**Layer(图层) Tree**和

15.**渲染器进程**的**主线程**将**Layer Tree**和**绘制信息表**传给**合成器线程**，**合成器线程**再将每个图层**栅格化**

![[00 assets/12e1e40bd5b2ec1d6648d5ee5852b9f3_MD5.png]]

16.**合成器线程**将得到的信息分图层分成更小的图块，交给**栅格线程**

![[00 assets/05bdaaf18a4b8ca65e21580a67644b7a_MD5.png]]

17.**栅格线程**栅格化每个图块，并将他存储到**GPU 内存**中

18.栅格线程栅格化完成后，返还给合成器线程**draw quads**图块信息 ，这些信息记录了图块在**内存中的地址**和在**页面那个位置**绘制图块信息存储在 GPU 中

![[00 assets/563a0c6db97c1319f5dc9318289e25e6_MD5.png]]

19.**合成器线程**将栅格线程通过**IPC**返回的图块合成帧交给**浏览器进程**

20.**浏览器进程**收到**一帧的图像**后传给**GPU**进行渲染

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040001083.png" alt="屏幕截图 2022-03-09 164925" style="zoom:67%;" />

21.总结

![[00 assets/8ec5e8e2b2f08166e7107f18bb9dcb4b_MD5.png]]

**重排**：当改变 dom 的属性时，会重新进行样式计算，会重新布局(Layout)和绘制(Paint)

**重绘**：当改变颜色时，只会发生样式计算(Style)和绘制(Paint)

22.其他

**JS**也是运行到主线程上面的，假如你写了一个重排和重绘的动画，就会挤占主线程，这样就会导致页面的卡顿

![[00 assets/a6899be1a3ec007b561c9fa57c1deaef_MD5.png]]

**优化空间**

**requestAnimationFrame()**：会将主线程的任务分散到每一帧的间隔，从而不影响动画的流程

![[00 assets/c5d1631879a07d68b91a792176687e58_MD5.png]]

**Fiber**：react 利用浏览器的空闲时间做优化

**Transform**：会直接运行合成器线程，所以不会使用主线程的渲染

# Cookie、Session、Token

[Cookie、Session、Token 究竟区别在哪？如何进行身份认证，保持用户登录状态？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1ob4y1Y7Ep?spm_id_from=333.999.0.0)

HTTP 是无状态的，即便你访问过，它也不记得你

## 1. Cookie

你在浏览器输入网址之后，会调用 UI 线程，UI 线程调用网络线程，向服务器发送 HTTP 请求（具体的 HTTP 请求可以参考我以往的文章），服务器会返回一个 Cookie，里面包含了数据，然后每次浏览器发送 HTTP 请求的时候都会带上 Cookie

![[00 assets/e9551254e3ea025b94ec74fb8cf9aa92_MD5.png]]

但是浏览器是可以看到 Cookie，所以 Cookie 其实并不是很安全，你的电脑被黑的话，你的数据都会丢失

## 2. Session

Session 也就是会话，Session 一般会有一个唯一的 ID，你在网页输入密码和账户之后，服务器会生成一个唯一的 Session ID 和会话的时间......包到 Cookie 里面发送给浏览器，之后浏览器每次发送 cookie 的时候就不发送账户和密码了，当到了最大的时间之后，Cookie 就会自动删除

![[00 assets/085fa6432d664b18251dd8c269cae019_MD5.png]]

## 3. Cookie 和 Session 代码

建议观看视频 5:53-8:51

## 4. Token

JWT（Json Web Token），浏览器将账户和密码发送给服务器，服务器生成一个 JWT 和 JWT 签名密文，服务器将 JWT 发送给浏览器，每次请求的时候就将 JWT 发送给服务器

![[00 assets/a2b06a80629bbff77f1330181e9aaa9e_MD5.png]]

**JWT 结构**

![[00 assets/dffd46dafc5f197f007fcff00c2c2b10_MD5.png]]

header 和 payload 进行 Base64 编码，而不是加密，是可以转换出来的，服务器将保存的密码和上面的 Base64 进行算法计算得到签名信息，算法就是 header 声明的 typ

![[00 assets/031013fa304e17deef7d0391c9e7dfa9_MD5.png]]

但是还是有人会疑惑 Session 和 Token 有声明区别，其中 Session 是保存在服务器的，但是 Token 是保存客户端的

## 4. Token 代码

可以观看视频 11:25 部分

# 乱码问题

[你懂乱码吗？锟斤拷烫烫烫（详解 ASCII、Unicode、UTF-32、UTF-8 编码）\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1xP4y1J7CS?spm_id_from=333.999.0.0)

一开始的时候只有 ASCII 编码，其最大值为 127，一共存储了 128 个字符

比如说：a -> ASCII 表示 97 -> 97 - > 0110 0001

所以使用一个字节来存储一个字符

但是不可能只保存英文啊！所以各个地方就创造了多个标准，但是标准多了之后，在内存中一串数字，在不同的标准下就是不一样的字符

![[00 assets/cdcbf172e98f4fca436d36f8e26efada_MD5.png]]

所以为了解决这个问题，就出现了 Unicode 编码，包含了很多的字符，每个字符有一个码点值，在计算机存储的就是它的二进制

![[00 assets/8e614e6c5737be889e9040a1d73a88bf_MD5.png]]

为了显示下面的内容，就需要使用四字节的容量来存储

😂 -> 0000 0000，0000 0001，1111 0110，0000 0010

使用这个方式来存储的话就会浪费很多容量，所以这个时候就有了 UTF-8，UTF-16，UTF-24，UTF-32

![[00 assets/c5f113a3a778706af840ee2c7a03de75_MD5.png]]

但是为了区分各个码点位数，就需要使用下面的形式来存储，假如你是 128-2047 这个区间的字符，存储在计算机就必须在第一个字节前面 4 个写 1110，第二个字节前 2 个写 10，第三个字节前 2 个写 10

这样的话 ACSCII 码和 UTF-8 就完美兼容了

![[00 assets/45dd44a461a2a568fbf8ae50d3988f00_MD5.png]]

# 哈希表

[『教程』哈希表是个啥？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1qR4y1V7g6?spm_id_from=333.999.0.0)

哈希函数也称为散列函数、杂凑函数

比如：你要查西瓜，就通过哈希函数找到参数为 66，就到数组中寻找，就找到了价格为 2.0

![[00 assets/31f324f0936fb5e686a42bb46629432d_MD5.png]]

哈希函数的算法就有 SH256，MD5 值，

我们在网络中下载的文件，可能会有数据的损坏，所以我们使用这个文件的 MD5 值，再和官网的比对，假如是一样的，就没什么问题了

其实一些网盘也是使用的 MD5 来比对资源，这样的话就不用反复存储资源了

# BGP

[你的数据是如何漂洋过海的？BGP 的原理是什么？ (bilibili.com)](https://www.bilibili.com/medialist/play/watchlater/BV1qa411C7nA)

## 1. AS

BGP 就是**边界网关协议**

一开始网络分发数据的时候，服务器发给个人，但是并不是每个人都希望得到这份数据，所以就需要一个路由器来分发数据，其中每个组就叫做 AS(自治系统)

![[00 assets/f68bc1faaac38ba7be4f1bc1e1ac173c_MD5.png]]

**常见的 AS 自治系统**

假如在国家层面的话，每个国家信息传输都不一样，假如想将数据从一个国家传到另一个国家的话，是不是可能经过另一个国家，但是那个国家也不清楚这个数据是否包含不好的东西呢？所以就有了 BGP，也就是让每个自治网关系统遵守一个协议

![[00 assets/566c11e03b668352165e9b96a8fe6c44_MD5.png]]

有了这个 BGP 路由器就不需要记录全世界的路由表了，只需要按照编号记录就可以了

## 2. eBGP 和 iBGP

eBGP 是外部 BGP，iBGP 是内部 BGP

eBGP 是管理各个自治系统的，但是 iBGP 是管理自治系统内部的，并且 iBGP 是不能独自修改的，必须有 eBGP 修改之后 iBGP 才能进行更新

而且 eBGP 是不能进行全互联，iBGP 是要全互联的，假如网络故障的话，iBGP 没有全互联，是不是就网络不通，而且不去全互联的话最优路径选择也很难做，但是要 iBGP 做到全互联是很难的

![[00 assets/b72aa567894788330a2d32aa73fa02c5_MD5.png]]

## 3. 工作原理

BGP 使用的是 TCP 来进行传输，传输的端口是 179

BGP 连接之后有 4 种报文：open：建立连接；update：进行数据的传输和更新；notification：中断，拒绝加入错误信息；keepalive：保持会话

其中 BGP 还有 6 种状态：Idle：空闲；connect：表示初始连接；Active 表示活跃状态，这个时候进行 TCP 的三次握手；opensent：就是发送报文后；openconfirm：就是等待报文的接受；established 就是接受报文，建立连接

## 4. 路径选择

![[00 assets/e5f9f5a695132bc66886583fba096b11_MD5.png]]

# HTTPS

HTTPS 其实不是单独的协议，而是在原本的 HTTP 协议上面添加了 TSL/SSL 加密，这样的话通信就不容易被拦截，而且你使用 HTTPS 是加密之后的，更加安全

SSL 是 TSL 的前身，下文都是说的 TSL

## 1. 加密方式

> 对称加密

下面就是一种对称加密

![[00 assets/eefc5e46bcd952bd07de39a808146949_MD5.png]]

都使用的一个加密的规则，加密之后为 YGnldewU，使用这个规则解密之后就知道客户端要发送的信息，但是使用这种方式的话，知道了加密的规则后就知道发送的信息了，所以就有了不对称加密

> 不对称加密

下面就是一种不对称加密

![[00 assets/2c24a2c188045a2a9eeb882a638b6ece_MD5.png]]

使用公钥加密之后只能使用私钥解密，使用私钥加密之后只能使用公钥解密

服务端有成对的私钥和公钥，服务器将公钥给客户端，客户端使用公钥加密，但是我们使用这个公钥是不能解开这个数据的，但是加密的信息只能使用服务器端的算法来解开，这样就避免了算法泄露之后，敏感信息泄露的风险，所以这样的加密方式也叫做公钥加密，也就是非对称加密

## 2. 证书

一般网站为了证明是你要进入的网站，就需要使用 TSL/SSL 证书，这个是 CA（Certificate Authority 证书授权中心）发布

HTTP 的端口号为 80，HTTPS 的端口号是 443

## 3. TLS 握手过程

首先正常的 TCP 的三次握手是没变化的

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040001886.png" alt="屏幕截图 2022-03-15 210523" style="zoom:50%;" />

1.首先客户端发送消息 Client Hello 给服务端，客户端告诉服务端他支持 TSL 1.2 版本和 16 种加密的方式，这 16 个就是不同的加密算法组合![[00 assets/dcc5ce4429bb4f05c925e2a1bc91d9ed_MD5.png]]

2.这个时候服务端发送响应 Server Hello 给客户端，并且告知客户端他使用的 TSL 的版本和加密算法

![[00 assets/2710e39195c4f9d67d55b79d911bf5f5_MD5.png]]

3.这个时候服务端还会发送响应给客户端来出示浏览器自己的证书，这样浏览器就会对照自己的证书列表来确认这个服务器是否可信

![[00 assets/2ecab2dc0887a7a0f7b7022be9664b6b_MD5.png]]

4.这个时候服务器会再发送公钥给客户端，这里补充一下，假如这个时候是网银的话，可以需要客户端将证书发送个服务端

![[00 assets/2857921c78d78fae7e1b833fadfc19e2_MD5.png]]

5.服务器发送了 3 个响应给了客户端，又要发送一个响应 Server Hello Done 来表示这波发送结束了

![[00 assets/1ea0bc01868754311eac661948190728_MD5.png]]

6.下面就是客户端处理上面发送的 3 个响应了

Client Key Exchange：这个时候客户端会生成第三个随机数，叫做预主密钥，这第三个随机数会使用刚刚服务端发送的公钥进行加密，也就是下面的 Pubkey，并且会将 Pubkey 发送给服务端

Change Cipher Spec：这一步就是告诉服务器以后就使用商议好的算法和密钥来进行加密

Encrypted Handshake Message：表示客户端这边的 TLS 协商已经没问题了

![[00 assets/6fde2e5cf29be8b28a64dcabea639bc9_MD5.png]]

7.最后服务端发送 Encrypted Handshake Message 表示服务端已经准备好了

![[00 assets/4ecfd271ea76e3850b9e6c6dfbb1ecb2_MD5.png]]

> TLS 握手过程总结

首先是第一随机数是客户端生成的，发送给服务端

第二随机数是服务端生成的，发送给客户端

第三个随机数经过服务端机密算法生成为预主密钥，发送给服务器，通过服务器的私钥解密出这个随机数，然后客户端和服务端将第一随机数+第二随机数+预主密钥生成为会话密钥

并且要注意的是，上面的加密方式是非对称加密，这是因为响应量是非常大的，所以后面就使用会话密钥进行对称加密

![[00 assets/fd41046c9511efac36ce1360ba195c06_MD5.png]]

# CDN

[什么是 CDN？CDN 能为我们做什么？我们为什么要了解他？\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1jS4y197zi?spm_id_from=333.999.0.0)

一条指令要发送给服务器，需要经过很长的路径，可能等了一段时间都没等到响应，所以这个时候就需要在各个地方设置服务器备份，为用户提供服务

所以就形成了 CDN(Content Delivery Network)内容分发网络，有很多边缘服务器提供服务，CDN 就是帮助服务器近距离给用户分发网页内容

![[00 assets/9705b9b416677b364d8d5378150dc607_MD5.png]]

## 1. 分发内容

网页中一直没变化的就是静态内容，假如时一直在变化的，就是动态内容

![[00 assets/064e666574d1a40d48ac7668dd83db21_MD5.png]]

并且源服务器发送文件给 CDN 可以利用 HTTP 头部信息的 cache-control 来设置文件的缓存，这样 CDN 就知道那些可以保存，可以保存多久，那些可以不用去保存

![[00 assets/3ae7119db2e2d197802c52452ac804fc_MD5.png]]

## 2. 分发流程

首先源服务器提前将静态内容交给 CDN 备份，也就是 push

客户端访问网页的时候，就近的 CDN 就会 response，并将内容给客户端

![[00 assets/2dddb44f19dcde2a2ea38fbfaa767fca_MD5.png]]

假如一开始的时候 CDN 没有保存备份的话，CDN 就会向源服务器索要文件，也叫做 pull

获得备份之后就可以向客户端发送内容

![[00 assets/aba115356f1dd0914c363ddd7b1cf93e_MD5.png]]

假如使用动态内容的话，因为不是直接连接服务器的，所以就提供不了多少加速服务

但是还有的，比如说：时间，CDN 就有一个接口，这样直接可以调用这个接口来获取时间

## 3. 安全性和可靠性

各个服务器都会监控其流量，假如一台服务器已经跑满，这个时候就将流量转移到另一台服务器上面，这个也叫做**负载均衡**

当然这个流量的转移在代码层面实现有点复杂，所以就采用了域名服务器的做法，使用一样的 IP 地址，距离用户最近的位置进行响应，这个叫做**任播**

![[00 assets/03c92d858d8e4aca26a8980c283b962d_MD5.png]]

当然 CDN 还有就是网络加速，其中一个就是因为距离变近了，所以网站就加速了，还有一个就是将代码优化，本来代码中的空格是为了程序员方便阅读的，但是 CDN 会将空格去掉，这样的话就压缩了这个文件的大小

# 面向对象编程

[8 分钟搞懂面向对象编程 | 面向过程 vs 面向对象 | OOP | 封装 继承 多态 (bilibili.com)](https://www.bilibili.com/medialist/play/watchlater/BV1wZ4y1B7A7)

# Ping 命令

**_因为学校网络问题，暑假回去记录_**

[Ping 命令的原理及多种用法 (bilibili.com)](https://www.bilibili.com/medialist/play/watchlater/BV1WZ4y187ak)

> ping 127.0.0.1

127.0.0.1 是一个保留地址，也叫回送地址，下面就是检测本机的基础网络配置是否正常，检测本机的 tcp/ip 地址是否正常安装

![[00 assets/b097133142e41d76f90abdfecd2fee08_MD5.png]]

> ping 本地 ip

我们可以使用 ping localhost，但是现在电脑 ping localhost，也就是 ping 127.0.0.1，也就去到了第一步

![[00 assets/62b57bae02f862546324a9dc277180cc_MD5.png]]

本地 ip 地址分为公网 ip 和内网 ip，但是路由器和本地 isp 会禁止你去 ping 自己的公网 ip，所以我们要 ping 自己的内网 ip

> ping 默认网关

> ping 目标 ip 地址

> ping 目标主机名

# DNS

参考视频 1：[超直观的 DNS 科普，一个视频搞懂 DNS 是啥，是怎么运作的\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1F54y1R7BC?p=2&spm_id_from=pageDriver)

参考文档 1：[字节面试被虐后，是时候搞懂 DNS 了 - 掘金 (juejin.cn)](https://juejin.cn/post/6990344840181940261)

参考文档 2：[[DNS 递归查询和迭代查询 - MaXianZhe - 博客园 (cnblogs.com)](https://www.cnblogs.com/juniorMa/articles/15617886.html)](https://blog.csdn.net/weixin_43518038/article/details/107812384)

## **1.什么是 DNS**

DNS 即域名系统(**D**omain **N**ame **S**ystem)，当我们在浏览器输入一个 URL 地址时，浏览器要向这个 URL 的主机名对应的服务器发送请求，就得知道服务器的 IP，对于浏览器来说，DNS 的作用就是将**域名转换成 IP 地址**。

当然下面还有更加权威得说法，摘自《计算机网络：自顶向下方法》的概念

> DNS 是：
>
> ​ 1.一个由分层的 DNS 服务器实现的**分布式数据库**
>
> ​ 2.一个使得主机能够查询分布式数据库的**应用层协议**

也就是，DNS 是一个应用层协议，我们发送一个请求，其中包含我们要查询的主机名，它就会给我们返回这个主机名对应的 IP；

其次，DNS 是一个**分布式数据库**，整个 DNS 系统由分散在世界各地的很多组 DNS 服务器组成，每台 DNS 服务器上都保存可以让我们最终查到主机名对应的 IP。

所以 DNS 的查询过程，说白了，就是去向这些 **DNS 服务器询问**，你知道这个主机名的 IP 是多少吗，不知道？那你知道去哪台 DNS 服务器上可以查到吗？直到查到我想要的 IP 为止。

其中有几个点，就是几级域名（test.com 顶级域名、test.cn.com 二级域名、test.mail.cn.com 三级域名 ），其中根服务器有 13 组，每组又有很多不同得 DNS 服务器

## **2.分布式、层次数据库**

为什么是分布式的，这个很容易理解，假如这个世界上只有一个 DNS 服务器，全球所有人要访问网络得时候都要向它询问，所以需要这个服务器性能很强，并且线路过长会导致访问时间增加

下面可以分为**根** DNS 服务器、**顶级域(Top-Level Domain, TLD)**DNS 服务器和**权威** DNS 服务器

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040001254.png" alt="image-20220514205325427" style="zoom:67%;" />

当然我们可以根据下面这个图来理解，根域名服务器包含很多的顶级域名服务器，顶级域名服务器又有很多权威域名服务器，这里面包含了域名的 ip 地址

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040001285.png" alt="屏幕截图 2022-05-14 214443" style="zoom:50%;" />

**2.1** **根 DNS 服务器**

`www.baidu.com` 的完整写法是 `www.baidu.com.`，最后的这个 `.` 就是根域名。

根 DNS 服务器的作用就是管理它的下一级，也就是顶级域 DNS 服务器。通过询问根 DNS 服务器，我们可以知道一个主机名对应的顶级域 DNS 服务器的 IP 是多少，从而继续向顶级域 DNS 服务器发起查询请求。

**2.2 顶级域(Top-Level Domain, TLD)DNS 服务器**

为下一级 DNS 服务器提供服务

**2.3 权威 DNS 服务器**

最终返回给主机 IP 地址

## **3.本地 DNS 服务器**

**严格来说，本地 DNS 服务器并不属于 DNS 的层次结构**，但它对 DNS 层次结构是至关重要的。

每个 ISP 都有一台本地 DNS 服务器，比如一个居民区的 ISP、一个大学的 ISP、一个机构的 ISP，都有一台或多台本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，**本地 DNS 服务器起着代理的作用**，并负责将该请求**转发**到 DNS 服务器层次结构中。

![[00 assets/52ab4fd563001efa1f8de55b4f7c4413_MD5.png]]

## 4.递归查询、迭代查询

> 方式一

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040001022.png" alt="屏幕截图 2022-05-14 212339" style="zoom: 50%;" />

1.首先时本机获取到本地 DNS 服务器，可以是社区、学校......的 ISP，或者是你的路由器，我们自己也可以自己设定 DNS 服务器，比如说：你下载 VS 的时候，可能连接不是微软的服务器，所以可以设置谷歌的 DNS 服务器。来向其他服务器来获取 ip 地址

![[00 assets/1d6f80974576fe547892c59e23a6d91a_MD5.png]]

2.本地 DNS 服务器将该报文转发到根 DNS 服务器；

3.该根 DNS 服务器注意到 `com` 前缀，便向本地 DNS 服务器返回 `com` 对应的顶级域 DNS 服务器（TLD）的 IP 地址列表。

4.本地 DNS 服务器向其中一台 TLD 服务器发送查询报文；

5.该 TLD 服务器注意到 `baidu.com` 前缀，便向本地 DNS 服务器返回权威 DNS 服务器的 IP 地址。

6.本地 DNS 服务器又向其中一台权威服务器发送查询报文；

7.该权威服务器返回了 `www.baidu.com` 的 IP 地址；

8.本地 DNS 服务器将 `www.baidu.com` 跟 IP 地址的映射返回给主机，主机 就可以用该 IP 向 `www.baidu.com`发送请求

其中本机向本地 DNS 服务器发送请求是递归查询，而本地 DNS 服务器给各个层次的 DNS 服务器发送请求是迭代查询

> 方式二

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405040001071.png" alt="屏幕截图 2022-05-14 213720" style="zoom:50%;" />

这个整体就是递归查询

> 总结

其中递归查询的意思是客户端只发一次请求，要求对方给出最终结果。

而迭代查询是客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，

## 5.DNS 的优化与应用

1.**DNS 缓存**：DNS 存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS 服务器缓存，根域名服务器缓存，顶级域名服务器缓存，权威域名服务器缓存。当然，缓存并不是永久的，每一条映射记录都有一个对应的生存时间，一旦过了生存时间，这条记录就应该从缓存移出。事实上，**有了缓存，大多数 DNS 查询都绕过了根 DNS 服务器**，需要向根 DNS 服务器发起查询的请求很少。

2.**DNS 负载均衡(DNS 重定向)**： DNS 负载均衡技术的实现原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址，在应答 DNS 查询时，根据这个服务器的距离、此时负载情况......，将客户端的访问引导到不同的服务器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。

大家耳熟能详的 CDN(Content Delivery Network)就是利用 DNS 的重定向技术，DNS 服务器会返回一个跟 用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容。

3.**DNS Prefetch**：是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。

# TCP 三握四挥

参考文档 1：[(49 条消息) TCP 详解\_wang_nian 的博客-CSDN 博客\_seq=x](https://blog.csdn.net/wang_nian/article/details/109202533)

# HTTP

[从 HTTP 到 WEB 缓存 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903791809003527)
