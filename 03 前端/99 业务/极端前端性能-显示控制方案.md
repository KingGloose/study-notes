---
标签: [前端性能, Vue, 显示控制]
版本记录:
- 2026-01-23：首版，整理 v-if / v-show 与 z-index / 透明度 的性能差异
---

# 极端前端性能下：为什么用 z-index / 透明度 会比 v-if / v-show 更快？

> [!summary] 这篇笔记你能学到什么？
- v-if、v-show 在 Vue 里到底做了什么
- 浏览器渲染管线（布局 / 绘制 / 合成）对性能的影响
- 为什么在极端性能场景，更推荐用 z-index、opacity 这类 CSS 技巧
- 什么场景可以用「框架级条件渲染」，什么场景该退回到「纯 CSS 控制」

如果你现在完全不理解「为什么不用 v-show / v-if，而要用 z-index / 透明度」，可以先记住一句话：

> **框架的条件渲染（v-if / v-show）= JS 层逻辑 + DOM 结构 + 布局修改**
>
> **z-index / 透明度 = 尽量只让浏览器做「合成」这一步**，跳过前面较重的步骤，所以在极端场景下会更快。

---

## 1. 先搞清楚：v-if 和 v-show 各自做了什么

这里先从「Vue 自己要做的工作」开始理解。

### 1.1 v-if：真的有 / 没有这个 DOM

在 Vue 中：
- `v-if="condition"` 为 **真**：
  - Vue 会在虚拟 DOM 中「挂载」这一整块内容
  - 触发生命周期（created/mounted 等）
  - 生成真实 DOM 节点并插入页面
- `v-if="condition"` 为 **假**：
  - 这一块在虚拟 DOM 中被「移除」
  - 对应的组件会被销毁，DOM 从页面上删除

也就是说：
- 每次从 false → true / true → false 的切换，都要走一遍
  - 虚拟 DOM diff
  - 创建 / 销毁组件实例
  - 创建 / 删除 DOM

> 在极端性能场景（例如：
> - 高频切换（每一帧、每几帧在切）
> - 列表里有成百上千个这样的块
> ）这些创建 / 销毁的成本就很明显了。

### 1.2 v-show：DOM 一直在，只是 display: none / block

`v-show` 的逻辑简单很多：
- DOM 只在初次渲染时创建一次
- 后面切换时只是改元素的 `style.display`，比如：
  - 显示：`display: ''` / `display: block`
  - 隐藏：`display: none`

它的代价主要有两部分：
- Vue 层：
  - 依然要做一次响应式更新（数据变了 → 触发渲染 → 设置 style）
- 浏览器层：
  - `display` 从 `none` ↔ `block` 会触发布局（layout）
  - 页面要重新计算所有受影响元素的尺寸和位置

> 对少量元素来说，这没什么
> 
> 但对**大型复杂页面 + 高频切换**来说，布局成本会变成瓶颈。

---

## 2. 浏览器渲染管线：哪一步最耗性能？

很粗略地看，浏览器渲染一帧大概要经历：

1. **JS 执行**（Vue 的响应式、diff 等都在这儿）
2. **Style 计算**（style / class 改变时）
3. **Layout 布局**（例如 display 从 none 变为 block）
4. **Paint 绘制**（把像素画到图层上）
5. **Composite 合成**（把多个图层叠在一起）

其中：
- 布局（Layout）和绘制（Paint）一般比合成（Composite）要重
- 改 `display` 基本一定会影响布局
- 改 `opacity` 或 `transform`，在大多数现代浏览器中可以只触发**合成**，跳过布局和重绘

> [!tip] 关键直觉
> - v-if：经常伴随着 DOM 的增删 → 影响布局 + 绘制
> - v-show：改 display → 影响布局 + 可能的重绘
> - 改 opacity / z-index：更可能只在合成阶段解决 → 更轻

当你在追求「极致流畅、每一帧都要稳住 60fps+」时，就会尽量把操作控制在**合成层**，避免动到布局和重绘。

---

## 3. 为什么 z-index / 透明度 更友好？

从「框架」和「浏览器」两层来看：

### 3.1 从 Vue 视角：减少框架参与

当你用 `v-if` / `v-show` 控制显示：
- 每次状态变化 = 一次响应式更新
- Vue 要：
  - 触发渲染函数
  - 对虚拟 DOM 做 diff
  - 找出变化的节点并更新真实 DOM / style

当你退回到「纯 CSS 控制」：
- Vue 只需要负责很少的状态变更（例如 currentIndex）
- 真正的显示策略交给 CSS 和浏览器合成层

举个典型极端场景：全屏多「页」的轮播 / 导览：
- **做法 A：多页 + v-if/v-show 切换**
  - 每一页是一个组件树
  - 切换页时：大量组件 mount / unmount 或 display 变化
- **做法 B：所有页都渲在同一个容器里，靠 z-index / opacity 控制谁在上层**
  - Vue 只是改一个 `activeIndex`
  - CSS 根据 index 给对应页面更高的 z-index / 更高的 opacity
  - 其它页面可以继续留在 GPU 图层里，合成阶段直接切

### 3.2 从浏览器视角：利用合成层和 GPU 加速

多数情况下：
- `opacity` + `transform` 可以让浏览器把元素提升到**合成层**
- 在合成层上的变换：
  - 不需要重新布局
  - 不需要重新绘制像素
  - 只是让 GPU 把原有的图做位移 / 透明度混合

而 `display: none`：
- 直接把元素移出布局树
- 再改回 `block` 时，需要：
  - 重新参与布局计算
  - 可能重新绘制

> 所以在极端场景下，用 z-index / opacity 的核心收益是：
> - **少让 Vue 干活**（少 diff、少 DOM 结构变动）
> - **少让浏览器做 Layout / Paint，多用 Composite**

---

## 4. 一个对比示例：轮播 / 多页容器

场景：你有一个全屏轮播，每一页是一个复杂页面，频繁左右切换。

### 4.1 方案一：v-if 控制页面挂载

```vue
<template>
  <div class="pages">
    <PageA v-if="page === 'A'" />
    <PageB v-if="page === 'B'" />
    <PageC v-if="page === 'C'" />
  </div>
</template>

<script setup>
import PageA from './PageA.vue'
import PageB from './PageB.vue'
import PageC from './PageC.vue'

const page = ref('A')
// 高频切换 page 的值
</script>
```

问题：
- 切换时：
  - 整个 PageX 组件树 mount / unmount
  - 每个页面内的 Watcher / Effect 都要重新建立
  - DOM 大量创建 / 销毁

### 4.2 方案二：统一渲染，CSS 控制显示层级

```vue
<template>
  <div class="pages">
    <div class="page" :class="{ active: page === 'A' }">
      <PageA />
    </div>
    <div class="page" :class="{ active: page === 'B' }">
      <PageB />
    </div>
    <div class="page" :class="{ active: page === 'C' }">
      <PageC />
    </div>
  </div>
</template>

<script setup>
import PageA from './PageA.vue'
import PageB from './PageB.vue'
import PageC from './PageC.vue'

const page = ref('A')
</script>

<style scoped>
.pages {
  position: relative;
}

.page {
  position: absolute;
  inset: 0;
  opacity: 0;
  z-index: 0;
  transition: opacity 0.2s ease;
}

.page.active {
  opacity: 1;
  z-index: 1;
}
</style>
```

特点：
- 所有 Page 组件只创建一次，一直存在
- 切换时 Vue 只改一个 `page`，触发很少量的 DOM class 更新
- 浏览器通过 opacity / z-index 切换可见层，不用重新布局整个页面

在「页面复杂 + 切换频繁」的情况下，这个方案通常会更稳。

---

## 5. 什么时候适合用哪种方式？

可以用一个简单的决策思路：

> [!tip] 快速选择
> - **元素很少 + 切换不频繁**：优先用 `v-if` / `v-show`，代码更直观
> - **元素较多 / 页面复杂 + 切换频繁**：考虑用 z-index / opacity 控制显示
> - **动效丰富（淡入淡出、滑动）**：多用 `opacity` + `transform`，更容易 GPU 加速

另外：
- `v-if` 适合：
  - 真的不需要这个组件时就销毁，释放内存
  - 比如：大型弹窗、一次性向导
- `v-show` 适合：
  - 切换频率一般、数量不大
  - 比如：Tab 内容切换
- z-index / opacity 适合：
  - 高频切换的复杂页面
  - 大型动画场景（轮播、展示墙、地图上的图层切换等）

---

## 6. 常见误解和坑

- 误解 1：**只要用 opacity 就一定快**
  - 实际上：
    - 如果元素本身很简单，差别不大
    - 如果没有合成层（没触发 GPU 图层），收益也有限
- 误解 2：**v-show 一定很轻量，可以随便用**
  - 在复杂布局中，大量元素 display 在 none / block 之间切换，布局成本也很可观
- 误解 3：**所有东西都用 z-index / opacity 控制就好了**
  - 如果页面非常大、长期存在，内存压力也会增加
  - 有些场景反而应该用 v-if 在看不到时彻底卸载

> [!warning] 记住：性能优化永远是「按场景权衡」，不是「选一个万能解」。

---

## 7. 相关概念与延伸阅读

- [[前端性能优化-总览|前端性能优化总览]]
- [[浏览器渲染流程-Layout-Paint-Composite|浏览器渲染流程：Layout / Paint / Composite]]
- [[Vue-条件渲染-v-if-v-show|Vue 条件渲染：v-if 和 v-show 的取舍]]
- [[GPU-合成层与硬件加速|GPU 合成层与硬件加速]]
- [[业务|业务总览]]

---

## 8. 马上动手：5 分钟练习清单

- [ ] 在一个简单的 Vue 页面里写出：用 `v-if` 切换两个组件的 Demo
- [ ] 改写成：同时渲染两个组件，用 `opacity` + `z-index` 切换显示
- [ ] 打开 Chrome Performance / Rendering 面板，对比两种方式在频繁切换时的 FPS 与 Layout 次数

> 如果你能清楚回答：「**为什么在我这个具体场景下，CSS 控制比 v-if / v-show 更快或更合适？**」，说明你已经真正掌握了这个知识点。

---

相关笔记：
- [[业务]]
- [[前端性能优化-总览]]
- [[浏览器渲染流程-Layout-Paint-Composite]]

