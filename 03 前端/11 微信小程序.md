视频讲解：[黑马程序员前端微信小程序开发教程，微信小程序从基础到发布全流程*企业级商城实战(含 uni-app 项目多端部署)*哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1834y1676P?p=2)

视频讲解：前端系统课 - coderwhy - 微信小程序

# 1. 基本入门

## 1.1 基本介绍

> 什么是小程序？

![image-20221106222249181](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330024.png)

![image-20221106222306922](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330059.png)

> 各个平台为什么都需要支持小程序呢？

![image-20221106222538348](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330072.png)

> 小程序由谁来开发？

![image-20221106223605781](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330066.png)

> uni-app 和 taro

![image-20221106224003859](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330080.png)

## 1.2 项目结构

下面为`微信小程序`得整体得目录结构，也会是以后微信小程序开发的文件结构

![image-20221107092329095](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330092.png)

> 每个文件

![image-20220528162200024](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330917.png)

> pages 文件夹

![image-20220528162412151](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330946.png)

下图为`page文件夹`中得`.json`文件得配置

![image-20220528164004664](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330963.png)

> app.json

![image-20220528163036078](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330985.png)

> project.config.json

![image-20220528163352993](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330011.png)

> sitemap.json

![image-20220528163711695](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330032.png)

## 1.3 创建 page

如果`创建page`得话只需要在`app.json`里面添加一个`"pages/list/list"`，就会在`pages`文件夹下面创建一个`list文件夹`，`list文件夹`下面就是相应得文件

其中排在第一位得会作为首页存在，如下图中得`pages/list/list`就是排在第一位，那么小程序打开展示得页面就是它

![image-20220528164939490](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330839.png)

\*如果要使用`page`得话一定要在`app.json`中得`pages`中注册才可以

## 1.4 MVVM

下面的`MINA框架`就是`微信小程序`的框架

![image-20221118091522282](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330869.png)

## 1.5 架构模型

> 双线程模型

![image-20221118092558456](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330908.png)

> skyline

微信官网中有介绍`skyline`的渲染引擎，但是目前只是一个`beta`版本，所以只需要稍微了解一下就可以了

![image-20221118093222850](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330958.png)

# 2. 基本使用

## 2.1 基本使用

下面是对于`微信小程序`的一个基本的使用，包含了`数据绑定`、`列表渲染`

![image-20221117232922150](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330981.png)

下面是`事件绑定`的处理，其中数据的修改必须使用`this.setData()`处理，这个和`React`中的`setState`的语法很类似

![image-20221118090945840](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330014.png)

## 2.2 App

`App`文档：[App(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html)

![image-20221123224313123](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330799.png)

`App`中可以进行下面的操作

![image-20221123224326458](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330818.png)

> 作用一：判断打开场景

**官方场景值文档**：[微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html)

在生命周期函数中存在参数`options.scene`，用于判断进入小程序的方式，比如：扫码进入小程序就跳转到特定页面进行展示

![image-20221123224931040](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330845.png)

> 作用二：定义全局 App 的数据

![image-20221123225854166](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330873.png)

> 作用三：生命周期函数

![image-20221123230733425](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330901.png)

## 2.3 Page

**Page 官方文档**：[Page(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html)

其中`Page`包含下面的作用，这个可以类比为`Vue`中的`Views`

![image-20221124212449895](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330953.png)

我们可以做`列表渲染`、`网络请求`、`数据初始化`

![image-20221124223840789](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330787.png)

当然我们也可以`绑定事件`和`样式绑定`

![image-20221124224614456](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330817.png)

其中`上拉刷新`和`下滑触底`可以参考我`3.4.3`的笔记

# 3. 配置信息

## 3.1 基本介绍

![image-20221118094424348](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330842.png)

## 3.2 project.config.json

> project.config.json

`project.config.json`主要是在里面编写一些配置文件使用的，下图中就包含了基础库、appid...等信息。假如想要配置更多的信息可以参考官网文档：[项目配置文件 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)

![image-20221118094942804](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330884.png)

> project.private.config.json

当然还存在一个`project.private.config.json`，这个主要是协同开发的时候使用的，作为自己的一个私有的配置信息存在

![image-20221118095412860](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330921.png)

## 3.3 sitemap.json

`sitemap.json`这个主要是用于微信小程序检索使用的。

具体配置可以参考：

1、sitemap 配置：[sitemap 配置 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html)。

2、sitemap 介绍：[sitemap 配置 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html)

假如你是政府单位的小程序肯定不希望被收录，所以我们需要手动配置`sitemap.json`文件。正常的商业项目肯定是希望被收录

![image-20221118100023555](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330004.png)

## 3.4 app.json

### 3.4.1 基本介绍

`app.json`这个主要是用于微信小程序设置一些全局配置。

具体配置可以参考：

1、app.json 配置：[全局配置 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

2、app.json 介绍：[小程序配置 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#全局配置)

下面就是比较常见的配置

![image-20221118101803482](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330613.png)

### 3.4.2 pages

这里就是我们创建`page`的位置，假如你手动创建的`page`，但是不再这里配置是不行的。不仅仅是创建`page`，这还是一个配置路由的位置，比如项目后续的路由跳转和导航栏跳转，都需要使用到`page`中的配置

![image-20221118101937220](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330636.png)

### 3.4.3 window

#### 3.4.3.1 基础配置

`window`比较常见的配置项，包含了`导航栏`、`loading`、`全局事件`....

![image-20220530170902957](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330659.png)

下面即是一部分的配置信息

![image-20221118102125651](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330700.png)

#### 3.4.3.2 下拉刷新

我们在`window`的配置中将`enablePullDownRefresh`设置为`true`就可以开启全局的下拉刷新了，当然有全局的话就会存在局部，假如我们只想在局部开启下拉刷新，就需要在`page`中的`.json`文件中手动的开启使用

![image-20220530190458928](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330728.png)

当然我也可以在`.js`中使用`onPullDownRefresh`监听到`下拉刷新`，这里面可以编写一些网络请求相关的`API`处理。因为我们下拉刷新的时间比较长，我们可以使用`stopPullDownRefresh`来手动来关闭`下拉刷新`

![image-20221118112920187](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330380.png)

#### 3.4.3.3 上拉触底

设置上拉触底，也就是我们向下阅读的时候，屏幕往上划，划到了底部的时候要加载后面的内容，这个就是设置下拉触底的距离。假如我们需要配置的话可以设置`onReachBottomDistance`的距离，就可以开启了

![image-20221118103649992](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330405.png)

我们在`.js`中使用`onReachBottom`来监听到页面滚动到底部

![image-20221118113251324](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330427.png)

### 3.4.4 tabBar

`tabBar`配置导航栏，下面是设置`tabBar`的常见的属性

![image-20221118102526965](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330464.png)

`tabbar`的配置选项

![image-20220530192630316](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330491.png)

单个`tab`的配置选项

![image-20220530192755370](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330544.png)

我们在`app.json`中就是按照下面的方式来配置`tabbar`

![image-20220530202852580](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330310.png)

## 3.5 页面配置

![image-20220530203140341](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330335.png)

下面为经常使用的`页面配置`的`配置项`

![image-20220530203320348](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330363.png)

我们就是使用下面的方式来编写`配置项`

![image-20220530203705552](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330390.png)

# 4. 常见组件

## 4.1 text

**text 官方文档**：[text | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/component/text.html)，`text`其本质就是`HTML`里面的`span`

![image-20221124225132746](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330420.png)

## 4.2 button

### 4.2.1 基本使用

**button 官方文档**：[button | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

![image-20221124225526020](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330456.png)

> 基本使用

我们可以为`button`设置不同的属性展示不同的样式，并且在小程序中`button`是块级元素

![image-20221124225551899](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330291.png)

### 4.2.2 open-type

![image-20221124230416370](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330321.png)

## 4.3 view

`view`类似于`HTML`中的`div`，是作为一个块级元素占一行

![image-20221124231305722](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330347.png)

![image-20221124231313050](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330376.png)

## 4.4 image

### 4.4.1 基本使用

**image 官方文档**：[image | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/component/image.html)，其中`image`组件默认宽度**320px、高度 240px**

![image-20221124231524753](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330398.png)

> 基本使用

1、这里有一个文档路径加载的小技巧：直接使用`/`的话就默认选择根路径，比如上面的`加载本地图片`中的`src`

![image-20221124231730415](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330432.png)

2、`image`存在一个`mode`属性，对于设置图片来说很方便

![image-20220529114653783](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330329.png)

### 4.4.2 chooseMedia

**wx.chooseMedia 官方文档：**[wx.chooseMedia(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.chooseMedia.html)

`chooseMedia`可以用于`拍摄`或者`选择本地图片`。我们在本地手机选择图片之后可以本地展示，也可以上传云端

![image-20221125112647914](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330366.png)

### 4.4.3 previewImage

**wx.previewImage 官方文档**：[wx.previewImage(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html)

在新页面中全屏预览图片，可以查看大图保存图片、发送给朋友等操作

![image-20221125113205653](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330402.png)

## 4.5 scroll-view

**scroll-view 官方文档**：[scroll-view | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)

![image-20221125113540521](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330455.png)

1、`scroll-view`本身是为了实现`局部滚动`，假如是全局滚动的话可以直接让`view`高度撑起来即可，就不需要使用`scroll-view`

2、假如你想`x轴`局部滚动的话，就需要宽度超出`scroll-view`。相应的想实现`y轴`局部滚动的话，就需要高度超出`scroll-view`

3、假如你想要`scroll-view`内部实现`flex`布局，就需要加上` enable-flex`来开启`flex`布局

![image-20221125113638763](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330490.png)

## 4.6 richtext

可以将 HTML 的节点，转换为微信小程序里面的节点

## 4.7 共有属性

对于每个组件来说，存在下面的`共有属性`

![image-20221125114642055](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330518.png)

# 5. WXSS

## 5.1 基本介绍

**WXSS 官方文档**：[WXSS | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)

> 编写位置

`wxss`本质和`CSS`是一样的。其中`全局样式`是对于`app.wxss`来说的

![image-20221125131448753](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330435.png)

> 支持选择器

![image-20221125131559478](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330460.png)

其中选择器遵循下面的权重

![image-20221125131754338](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330484.png)

## 5.2 rpx

`rpx`作为微信小程序特有的单位，其主要是为了解决多机型适配的问题

![image-20221125131955110](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330510.png)

# 6. WXML

## 6.1 基本介绍

![image-20221125164342191](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330548.png)

## 6.2 模板语法

![image-20221125164351025](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330568.png)

虽然可以理解为`Vue`中的模板语法，但是还是有一些区别，比如该模板语法中不允许添加`函数`

## 6.3 条件渲染

### 6.3.1 基本使用

**wx:if 官方文档**：[条件渲染 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html)

`wx:if`本质和`v-if`是差不多的

![image-20221125164618537](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330336.png)

### 6.3.2 hidden

类比于`Vue`中`v-if`和`v-show`的区别，假如频繁切换的话就使用`hidden`来处理，否则使用`wx:if`来处理

![image-20221125164637534](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330366.png)

## 6.4 列表渲染

### 6.4.1 基本使用

**wx:for 官方文档**：[列表渲染 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html)

![image-20221125165518321](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330414.png)

1、当然我们也可以使用`block`来处理，类比于`Vue`中`template`

2、还存在一个索引`index`，来表示遍历到那里

![image-20221125165502513](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330452.png)

### 6.4.2 修改别名

![image-20221125165720502](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330492.png)

### 6.4.3 key

![image-20221125165940480](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330578.png)

# 7. WXS

## 7.1 基本介绍

**WXS 介绍**：[WXS 语法参考 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/)

`WXS`本质是跑在`WXML`中的，因为微信小程序是双线程模型，一个渲染层，一个逻辑层，所以不能直接在`模板语法`中使用`函数调用`，所以就存在一个`WXS`直接跑在`WXML`

![image-20221125173354434](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330086.png)

## 7.2 基本使用

我们可以使用下面的方式来引入`.wxs`文件，注意`wxs`只支持`ES6`的语法，所以不存在`箭头函数`、`对象增强`、`import导出`....写法

![image-20221125193334042](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330110.png)

## 7.3 汇总

```javascript
// 为传入的数字添加￥
function formatPrice(price) {
  return "￥" + price
}

// 计算总价格
function totalPrice(bookList) {
  return bookList.reduce(function (preValue, nextValue) {
    return preValue + nextValue.price * nextValue.num
  }, 0)
}

// 传入一个10000，转换为1万
function formatCount(count) {
  var newCount = parseInt(count)
  if (newCount >= 100000000) {
    return (newCount / 100000000).toFixed(1) + "亿"
  } else if (newCount >= 10000) {
    return (newCount / 10000).toFixed(1) + "万"
  } else {
    return newCount
  }
}

// 时间100 转换为1:40
function padleft(time) {
  if ((time + "").length >= 2) return time
  return "0" + time
}
function formatTime(time) {
  var minute = Math.floor(time / 60)
  var second = Math.floor(time) % 60

  return padleft(minute) + ":" + padleft(second)
}


module.exports = {
  formatPrice: formatPrice,
  totalPrice: totalPrice,
  formatCount: formatCount,
  formatTime: formatTime
}
```

# 8. 事件监听

## 8.1 基本使用

1、因为微信小程序是手机上面的，所以没多少事件，下面就是常见的几个事件

![image-20220530152225060](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330151.png)

2、在`.js`文件里面书写的时候，回调函数会有一个 event 参数

![image-20220530152543250](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330187.png)

3、关于 target 和 currentTarget 的区别

![image-20220530152941439](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330399.png)

4、其大致的语法格式和 Vue 是差不多的，但是还是有一些细微的区别

![image-20220530161515677](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330905.png)

其和 Vue 的区别主要集中在`修改参数`和`传递参数`

```javascript
// pages/list/list.js
Page({
  //数据
  data: {
    num:Math.random() * 10,
    num1:10,
    num2:0,
    text:"fafafa", 			 Url:"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg4.baixing.net%2F3d28c2293405e68f94fe1aac026c8a3a.png_bi&refer=http%3A%2F%2Fimg4.baixing.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1656486884&t=379e82e5ddf2ce5f8d71692b0b057eaf"
  },
  //带有event参数
  ShowEvent(e){
    console.log(e);
  },
  AddNum(e) {
    console.log(e.target)
    //修改参数，要调用setData函数,其实this.data就可以拿到data里面的参数
    this.setData({
      num1:this.data.num1 + 1
    })
  },
  ShowNum2(e){
    this.setData({
      //e.target.dataset.num2，就可以拿到传递来的参数num2
      num2:this.data.num2 = e.target.dataset.num2
    })
  },
  bindKeyInput(e){
    console.log(e.detail.value)
    this.setData({
      //文本框传递来的参数
      text:e.detail.value
    })
  },
})
```

```html
<view>
  <!-- 模板字符串使用 -->
  <image src="{{Url}}" mode="aspectFit"></image>
  <view>{{num > 5 ? '这是一个大于5的数字' : '这是一个小于5的数字'}},{{num}}</view>
  <view>{{num + 10}},{{num}}</view>
  <view>===============================</view>
  <!-- 展示event -->
  <button type="primary" bindtap="ShowEvent">点击我</button>
  <view>==============================</view>
  <!-- 事件绑定 -->
  <view>{{num1}}</view>
  <button type="primary" bindtap="AddNum">点击我</button>
  <view>==============================</view>
  <!-- 事件传参 -->
  <view>{{num2}}</view>
  <button type="primary" bindtap="ShowNum2" data-num2="{{3}}">点击我</button>
  <view>==============================</view>
  <!-- bindinput事件 -->
  <view>文本内容：{{text}}</view>
  <input value="{{text}}" bindinput="bindKeyInput" type="number"/>
</view>
```

## 8.1 事件分类

**事件官方网址**：[事件 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)

![image-20221125201829165](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330928.png)

## 8.2 event

### 8.2.1 基本介绍

![image-20221125201957507](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330953.png)

### 8.2.2 target 和 currentTarget 区别

其中`target`是触发事件的元素，`currentTarget`是处理事件的元素，所以按照下面的处理方式就有区别

![image-20221125203833074](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330082.png)

### 8.2.3 touches 和 changedTouches 的区别

![image-20221125224352862](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330111.png)

### 8.2.4 mark 传递参数

![image-20221125225430020](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330254.png)

## 8.3 tab 案例

![image-20221125210349760](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330898.png)

## 8.4 冒泡/捕获

> 基本介绍

![image-20221125224812003](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330929.png)

> 基本使用

![image-20221125224757308](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330961.png)

# 9. 组件化

## 9.1 基本使用

1、右键创建一个`Components`，一般是丢到`components`的文件夹下，这里面存放的都是公共组件

2、在使用的地方的`.json`文件中的`usingComponents`指定使用即可，也就是说`components`、`page`都可以使用组件，只需要配置`.json`文件

![image-20221125232030093](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330989.png)

使用`自定义组件`存在下面的注意事项

![image-20221125232431535](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330014.png)

## 9.2 组件样式

按照下面的尝试，可以总结为：对于`class`来说是互不影响的，但是对于`id`、`属性`、`标签`选择器根据情况是各不相同的，所以编写尽量使用`class`来处理

![image-20221125233328781](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330819.png)

假如我们想要`page`中编写的样式也可以影响`component`的话，可以修改`stylesolation`属性

![[00 assets/ad2cd31a9cbb3bcbf636479c332ea6f7_MD5.png]]

![image-20221125233852028](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330877.png)

## 9.3 组件通信

### 9.3.1 基本介绍

![image-20221126100750190](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330905.png)

### 9.3.2 properties

![image-20221126101440077](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330927.png)

我们按照下面的方式来传递参数，和`Vue`中的`props`是一样的

![image-20221126101249312](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330949.png)

### 9.3.3 externalClasses

1、有时候，我们不希望将样式在组件内固定不变，而是外部可以决定样式。我们使用下面的方式来给子组件传递`class样式`

2、需要注意的是`externalClasses`不生效的情况，(1)不能使用驼峰命名，(2)组件内部有一样的类名被覆盖了

![image-20221126102925393](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330625.png)

### 9.3.4 自定义事件

1、微信小程序使用`triggerEvent`方法来发送事件

![image-20221126110624401](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330654.png)

2、父组件接受传递来的数据，使用`event`来接受数据

![image-20221126110827808](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330680.png)

## 9.4 获取组件

1、使用`this.selectCOmponent()`根据`类选择器`来获取组件实例，我们就可以调用里面的方法

![image-20221126230216706](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330721.png)

2、子组件中编写方法，其中第一个参数就是传递来的参数

![image-20221126230334382](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330757.png)

## 9.5 插槽

### 9.5.1 基本使用

1、和`Vue`中使用得方式基本一样

![image-20221214184736055](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330822.png)

2、我们也可以使用多个插槽

![image-20221214191458122](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330690.png)

我们需要在对应得`组件`中使用`multipleSlots`开启即可

![image-20221214191540497](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330721.png)

### 9.5.2 默认插槽

小程序本身是不存在`默认插槽`这个语法得，所以下面只是一个方法来实现。我们使用`CSS`得伪类选择器来处理，只要`homeBannerStyle`下面为空得话，就让类名为`default`得`view`显示

![image-20221214185310401](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330752.png)

## 9.6 behaviors

![image-20221214194349021](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330846.png)

下面就是`behaviors`得使用方式，本质其实就是`Vue`中得`mixins`

![image-20221214200610873](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330868.png)

## 9.7 生命周期

![image-20221215112242041](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330893.png)

虽然上面存在这么多得生命周期钩子，但是作为组件真正使用基本都是下面得生命周期

![image-20221215112507314](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330621.png)

我们在`组件`中可以监听`page`中得生命周期

![image-20221215112749194](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330645.png)

## 9.6 构造器

1、这里得`methods`需要注意和`page`不一样。在`page`中写方法不需要定义`methods`，但是在组件中需要

![image-20221214191743488](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330672.png)

![image-20221214191755201](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330714.png)

# 10. API

## 10.1 网络请求

### 10.1.1 基本使用

![image-20221215114359784](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330766.png)

下面为`wx.request`得基本使用情况，当然还有很多得参数

![image-20221216123825626](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330846.png)

作为微信小程序我们配置相应得域名需要在小程序得后台进行操作，文档：[网络 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)

![image-20221216124734209](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330480.png)

然后还有一个`webview`业务域名得配置

1、不能带有端口，也就是你要使用`业务域名`得话，就需要默认端口为 443 给业务域名使用

2、需要将校验文件放置在目录下

![image-20221216125110967](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330505.png)

### 10.1.2 请求封装

> 函数封装

```javascript
export function WXRequest(options) {
  const { url } = options
  return new Promise((resolve, reject) => {
    wx.request({
      ...options,
      success: (res) => {
        resolve(res)
      },
      fail: (rej) => {
        reject(rej)
      }
    })
  })
}
```

1、我们可以使用下面得 2 种方式来进行请求，即`then`和`async/await`

![image-20221216133314129](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330530.png)

2、其中对于`async/await`得请求方式效率太低了，只有上一个请求完之后才会请求下一个。所以我们需要将其写在函数中，这样就可以同时发送请求

![image-20221216134012655](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330568.png)

> 类封装

1、一般为了拓展性得话，我们都会使用`类`进行封装

2、我们可以在`constructor`中编写`baseURL`、`timeout`....基础信息，这样我们创建实例得时候可以直接使用

```javascript
class RequestService {
  constructor(baseURL) {
    this.baseURL = baseURL
  }
  request(options) {
    const { url } = options
    return new Promise((resolve, reject) => {
      wx.request({
        ...options,
        url: this.baseURL + url,
        success: (res) => {
          resolve(res)
        },
        fail: (rej) => {
          reject(rej)
        }
      })
    })
  }
  get(options) {
    return this.request({
      ...options,
      method: "get"
    })
  }
  post(options) {
    return this.request({
      ...options,
      method: "post"
    })
  }
}
```

### 10.1.3 上拉触底请求

1、我们使用`onReachBottom`来进行监听，只要触底就发送请求

2、对于请求来得数据我们使用一个新得数组往里面叠加，这样列表是连贯得

3、对于数据得更新，为什么`currentPage`不是使用`setData`来处理？这是因为我们修改了`currentPage`并不需要更新页面，所以不需要使用。这个和`React`得思想很想

![image-20221216175655326](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330603.png)

## 10.2 弹窗

**官方文档**：[wx.showToast(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html)

![image-20221216181010575](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330685.png)

## 10.3 分享

官方文档：[Page(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShareAppMessage-Object-object)

![image-20221216182330898](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330521.png)

## 10.4 获取信息

> 获取用户设备信息

**官方文档**：[wx.getSystemInfo(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfo.html)

![image-20221216182616966](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330546.png)

> 获取位置信息

**官方文档**：[wx.getLocation(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html)

下面就是获取位置信息的方式，如果需要使用该能力的话，需要在`app.json`中添加`permission`字段

![image-20221216211830464](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330569.png)

## 10.5 storage

**官方文档**：[wx.setStorageSync(string key, any data) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html)

这个可以参考`微信小程序`文档中的展示案例，但是这里需要注意下面的异步存储数据的方法，里面存在一个数据加密需要一定的时间并不是立马存储

![image-20221216212242606](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330597.png)

## 10.6 页面跳转

### 10.6.1 基本介绍

**官方文档**：[wx.switchTab(Object object) | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html)

![image-20221217101920605](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330632.png)

### 10.6.2 navigateTo

1、我们使用`navigateTo`进行路由的跳转，并且携带参数

2、如果需要接收的话，需要在跳转到的页面中的`onLoad`的`options`中进行获取

![image-20221217104243195](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330674.png)

### 10.6.3 navigateBack

其基本使用可以参考官方文档中的案例

![image-20221217104458164](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330561.png)

### 10.6.4 上级数据传递

其中从首页跳转到详情页可以直接使用`query参数`，但是从详情页返回到首页还要传递参数的话就有点困难了

![image-20221217104758402](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330588.png)

> 早期方式

![image-20221217131033006](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330615.png)

![动画87](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330643.gif)

> event 方式

1、我们使用`navigateTo`来编辑`events`

2、我们添加`eventChannel`即可，发出事件，即可传递参数

![image-20221217132322628](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330683.png)

### 10.6.5 navigator 组件

![image-20221217132616611](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330734.png)

## 10.7 登录流程

> 基本介绍

![image-20221219165200154](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330463.png)

> 小程序登录流程

![image-20221219171326881](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330487.png)

## 10.8 页面生命周期

1、上面写的是组件的生命周期，下面是页面的生命周期

![image-20220602121800371](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330512.png)

# 11. 云开发

## 11.1 基本介绍

### 11.1.1 整体介绍

> 完整的小程序

![image-20230504112433302](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330556.png)

> 开发成本考虑

![image-20230504112624720](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330613.png)

> 云开发模式

![image-20230504112944936](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330678.png)

> 云开发模式和传统开发模式对比

![image-20230504112959591](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330442.png)

> 项目流程对比

![image-20230504113252818](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330470.png)

### 11.1.2 核心技术

![image-20230504113503734](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330497.png)

## 11.2 基本创建

> 基本使用

1、创建支持云开发的微信小程序项目

![image-20230504133403704](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330517.png)

2、这是点击云开发之后生成的文件目录

3、其中`cloudfunctions`表示是`云函数`，`miniprogram`对应的就是之前的工程文件，`uploadCloudFunction.sh`是批处理文件，将云函数统一上传

![image-20230504133804173](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330540.png)

> 云开发控制台

1、我们主要使用的是`数据库`、`存储`、`云函数`

![image-20230504144632132](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330563.png)

2、环境可以理解为一个服务器

![image-20230504144707935](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330372.png)

> 云开发初始化

![image-20230504145357010](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330397.png)

1、首先要确保`app.js`中初始化了云开发，也就是`wx.cloud.init()`

![image-20230504145439866](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330420.png)

2、我们再`project.config.json`中也可以指定`项目文件夹`和`云函数文件夹`

![image-20230504145503335](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330440.png)

## 11.3 云数据库

### 11.3.1 基本介绍

1、对于云数据库就可以理解为`mongodb`，其使用的方式基本差不多

![image-20230504154920986](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330465.png)

### 11.3.2 可视化工具

1、云开发控制台存在下面的可视化工具，我们可以通过输入参数来添加参数

![image-20230504155059533](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330501.png)

2、当然还存在`JSON`模式的传入参数。外层不能存在`key`只能存在对象，并且对象和对象之间不加`,`

```json
{
    "name":"zs",
    "age":18
}
{
    "name":"ls",
    "age":20
}
```

3、通过可视化工具就可以直接插入数据

![[00 assets/398cddf312496dda0611411bd6c67991_MD5.png]]

### 11.3.3 数据库操作

在操作之前要获取数据库和集合

![image-20230504160005138](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330296.png)

#### 11.3.3.1 添加数据

![image-20230504160318114](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330320.png)

1、我们使用`collection`的`add`方法来添加数据

![image-20230504155929384](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330354.png)

2、对于结果的获取，有 2 种方式。第一种就是使用回调函数`success`，第二种就是使用`Promise`

![image-20230504160152744](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330376.png)

3、下面写的是请求斗鱼的数据，并且将数据都存入云数据库

![image-20230504163704663](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330451.png)

![image-20230504163745243](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330002.png)

#### 11.3.3.2 查询数据

![image-20230504162301044](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330023.png)

1、对应上面各个查询方式的代码

![image-20230504171036995](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330049.png)

还可以通过`field`来指定返回的字段

![image-20230504171104304](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330171.png)

2、下面是常见的查询指令，官方文档：[指令 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/query.html)

![image-20230504164954467](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330206.png)

3、对于正则的解释，一般我们使用正则来替代模糊查询。官方文档：[Database.RegExp | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Database.RegExp.html)

![image-20230504165721817](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330830.png)

#### 11.3.3.3 删除数据

1、本质就是调用`remove()`方法，但是需要添加合适的查询条件

![image-20230504171723442](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330851.png)

2、我们在使用的时候可能出现下面的问题，这是因为云数据库的权限问题，我们可以手动的添加权限

![image-20230504171926118](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330870.png)

我们在数据库中修改自定义安全规则即可，这样就可以让用户可读可写了

![image-20230504163317118](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330896.png)

3、在控制台可能存在索引问题，为了解决这个问题，我们只需要创建`_openid`和`_id`的索引就可以解决

![image-20230505230722485](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330927.png)

![image-20230505230311420](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330958.png)

#### 11.3.3.4 更新数据

![image-20230504171944833](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330597.png)

1、和之前是一样的，都是写查询条件，然后调用`update()`或者`set()`方法即可

2、并且对于`update`和`set`之间是有区别的，其中`update`表示是更新其中的字段，但是其他的字段都不会修改；但是`set`表示覆盖该对象，其中只包含`data`中的数据。

![image-20230504172322375](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330621.png)

### 11.3.4 索引

1、我们可以在`云数据库`中添加索引，在现在的版本中是默认建立索引的

![image-20230504174300418](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330647.png)

2、其实本质就是数据库中的索引

### 11.3.5 数据库封装

```javascript
const db = wx.cloud.database();

class cloudDatabase {
  constructor(collectionName) {
    this.collection = db.collection(collectionName);
  }

  // 增加
  insert(data) {
    return this.collection.add({ data });
  }

  // 查询
  query(condition = {}, skip = 0, limit = 20, isDoc = false) {
    return isDoc
      ? this.collection.doc(condition).get()
      : this.collection.where(condition).skip(skip).limit(limit).get();
  }

  // 删除
  remove(condition = {}, isDoc = true) {
    return isDoc
      ? this.collection.doc(condition).remove()
      : this.collection.where(condition).remove();
  }

  // 更新
  update(condition = {}, data, isDoc = true) {
    return isDoc
      ? this.collection.doc(condition).update({ data })
      : this.collection.where(condition).update({ data });
  }
}

export default cloudDatabase;
```

## 11.4 云存储

### 11.4.1 基本介绍

![image-20230504175111796](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330673.png)

### 11.4.2 可视化工具

1、我们也可以是由可视化工具来`上传文件`或者`上传文件夹`

![image-20230504175144444](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330704.png)

2、上传完成之后会有一个`file id`，可以将该地址放置于类似`image`中

![image-20230504231527239](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330779.png)

### 11.4.3 文件上传

1、我们使用`wx.cloud.uploadFile`函数来上传文件

2、其中`filePath`表示文件的地址。`cloudPath`表示云端的地址，这里可以理解为存入云端的文件名，前面的`wallpaper/`表示云存储的文件夹

![image-20230504232520129](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330333.png)

### 11.4.4 文件操作

> 下载文件

![image-20230504232951960](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330363.png)

> 删除文件

![image-20230504233127018](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330386.png)

> 临时地址

![image-20230504233331248](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330531.png)

## 11.5 云函数

### 11.5.1 基本介绍

![image-20230504234445048](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330562.png)

### 11.5.2 基本使用

1、首先我们需要创建一个云函数

![image-20230505094841836](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330688.png)

创建完云函数之后就是下面的示例代码

![image-20230505095025239](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330199.png)

如果看不到`云函数`的话，这是因为是同步下来的云函数，需要下载

![image-20230505105040467](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330229.png)

2、我们编写完代码之后需要上传并部署之后，才能使用

![image-20230505095310486](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330252.png)

3、在云函数中返回的数据，会存入放回结果的`result`中

4、使用`wx.cloud.callFunction`来调用云函数，其中`name`表示云函数名字

![image-20230505095533416](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330305.png)

5、我们给`data`传入参数，就可以在云函数中的`event`中使用

![image-20230505100236435](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330422.png)

### 11.5.3 获取 openID/unionid

1、我们使用`cloud.getWXContext()`函数获取`openid`和`unionid`

2、但是我们没开通对应的功能，`unionid`是获取不到的

![image-20230505102017640](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330149.png)

3、但是对于`openid`和`unionid`来说都是作为鉴权使用

4、它们存在区别，`openid`一般只在`小程序`和`公众号`中使用。但是你想做到多平台共享，就需要`unionid`，比如:该项目存在小程序、公众号、APP，你想让它们之间鉴权都一样的话就需要`unionid`

![image-20230505102315722](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330173.png)

### 11.5.4 云端调试/本地调试

1、我们打开云开发控制台，存在本地调试和云端测试

![image-20230505103205905](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330211.png)

2、一般的情况使用`本地调试`

![image-20230505103238422](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330241.png)

3、相当于传递参数`event`，但是一般很少使用云端调试

![image-20230505103353544](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330267.png)

### 11.5.5 数据库操作

1、下面就是使用云函数的作用

![image-20230505103943071](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330332.png)

2、我们也可以在`云函数`中直接操作数据库，并且返回数据

![image-20230505104616664](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330070.png)

### 11.5.6 发送 HTTP 请求

1、我们还可以使用`npm i axios`，因为`云函数`是运行在`node.js`中，所以可以和平常使用`node`环境是一样的

![image-20230505125306842](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330090.png)

2、但是需要注意的是，这里运行的`node.js`环境是`node 12`，所以不支持`ES Module`。只能使用对应的模块化导入，比如这里的`axios`是使用的`0.27`的版本，可能最新的版本已经不知道`CommonJS`导入了

![image-20230505125632709](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330114.png)

我们需要更换到对应的版本中

![image-20230505125647177](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330138.png)

### 11.5.7 生成二维码

1、如果不是云开发的话，想要生成小程序码就很麻烦。但是使用云函数的话，它带有天然的鉴权，可以直接获取结果

2、按照下面的方式可以直接生成小程序码

![image-20230505132921260](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330171.png)

### 11.5.8 上传文件

1、其基本的上传流程就是下面的，和之前云存储中的上传是一样的

2、下面是获取小程序码，然后上传到云存储中，然后返回给小程序端进行显示

![image-20230505133421141](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330224.png)

# 12. 其他

## 12.1 获取小程序码

1、在获取小程序码的时候，首先需要获取对应的`TOKEN`

![image-20230505130910268](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330968.png)

2、再通过`TOKEN`来获取小程序码，并且这些操作都是后端来操作的

![image-20230505130926911](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330994.png)

3、下面是不同的分类

![image-20230505132109833](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330018.png)

# 13. 项目 - 云音乐

## 11.1 前期准备

1、创建项目，对于`AppID`来说在微信开发平台获取

2、我们先划分文件夹，下面的`assets`表示资源文件，`components`表示组件，`pages`表示`views`文件，`services`表示网络请求部分，`utils`表示封装的功能

3、然后就是创建页面，这里主要是 2 个`pages`，所以我们在`pages`中编写了 2 个文件夹。这个时候`app.json`就会自动添加路径

4、配置`tabbar`，按照下面的配置即可

![image-20230423101726606](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330045.png)

## 11.2 视频页面

### 11.2.1 网络请求封装

1、对于网络请求，其思路和之前是一样的，我们这里直接使用`index.js`来处理。封装的`class`在我之前的代码中有，可以参考

![image-20230423203546006](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330073.png)

2、这里分为 2 个文件，一个是请求的实例，还有一个就是请求的接口了

![image-20230423203654014](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330109.png)

3、在`page`中按照这样的方式来请求就行，因为网络请求是通用的，所以需要单独从`onLoad`中抽取出来

![image-20230423203721078](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330110.png)

### 11.2.2 mvItem 封装 - wxs 使用

![image-20230423203941262](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330132.png)

1、对于这样的页面，我们需要抽取成组件。因为是组件，所以我们需要将数据传输给组件

2、这里数据的传输我们使用`props`来处理

![[00 assets/f1cc0c0c55401d154f04412ce3451fd6_MD5.png]]

3、获取`props`的值，再传入到页面即可

![image-20230423204114524](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330179.png)

4、上面的逻辑和结构基本就是这样的，下面来说一下`小程序`中的样式部分。

![image-20230423204257879](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330207.png)

首先就是，这个播放数和时长的处理，这里采用的是定位的解决方案

![image-20230423204348728](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330235.png)

5、并且对于小程序中的`backgroud-image`中不能添加本地图片，所以这里我使用的是`base64`的方式来处理的

![image-20230423204501724](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330121.png)

6、对于只显示 2 行字的处理，我们也采用 CSS 的方式

![image-20230423204524342](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330148.png)

7、在页面需要使用到函数的话，就需要采用`wxs`。下面就是基本的使用方式。

8、需要注意一个问题，对于`wxs`只支持`ES5`的语法，所以`箭头函数、let、import`都不存在

![image-20230423205316039](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330173.png)

### 11.2.3 下拉/上拉刷新

1、因为刷新之后需要添加新的数据，所以需要改造网络请求的逻辑

2、我们修改数据需要使用`this.setData()`函数，并且重新渲染页面。但是对于`offset`来说，因为是依赖`TopMvList`的长度的，如果写进去可能就不是修改之后的数据，而是修改之前的，所以就会一直请求第一页的数据，所以我们这里直接修改里面的值即可

![image-20230423204726955](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330207.png)

3、我们需要在对应的`.json`文件中写上属性，这样才能使用

4、因为服务器只会返回`50条`数据，所以这里需要采用`hasMore`来判断是否还有数据

5、下拉加载的时候，需要请求到数据之后，再停止加载即可

![image-20230423205019780](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330236.png)

### 11.2.4 \*mvDetail 开发

1、我们点击`mvItem`之后需要跳转到详情页，但是这里存在 2 种开发方式。第一种就是点击之后，获取组件的`id`，然后在`page`中编写跳转的逻辑，但是这种写法需要写的东西比较多

2、第二种方式就是将点击的方式写在组件中，这样就直接获取组件中的`id`，这样写法更加简洁。这里采用的就是种方式

![image-20230423205833324](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330268.png)

3、需要开发出下面的形式的页面

<img src="https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330186.png" alt="image-20230423205945182" style="zoom:50%;" />

4、其基本的逻辑就是编写网络接口，然后再编写页面

![image-20230423210128324](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330210.png)

5、然后请求到数据存入，然后让页面来渲染

![image-20230423210031014](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330240.png)

6、对于视频播放的处理，微信小程序提供了`video`组件来处理，我们直接将视频地址输入就可以播放了。因为这个是分段加载的音乐，可能后续还会继续加载视频数据，所以我们这里需要修改`referrer-policy`的值

![image-20230423210345049](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330269.png)

7、提供的`video`组件还存在弹幕功能，因为这种东西都直接是服务器返回的，但是现在服务器是没有弹幕的，所以这里写的是固定的，但是基本的形式就是这样的

![image-20230423210809312](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330295.png)

8、因为还存在下面的推荐视频的内容，这里我们封装一个组件`mv-related`

![image-20230423210522340](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330327.png)

9、其基本的封装思路和上面的`mvItem`是一样的，这里就不去赘述了

![image-20230423210607812](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330267.png)

10、对于推荐视频也提供有接口，在网上找`网易云API`就有了

### 11.2.5 内容滚动

![image-20230423210950533](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330295.png)

1、下面的内容是需要滚动的，但是上面的视频不能滚动

2、对于这种功能，有 2 种实现的逻辑，第一种就是将`video`的`position`为`fixed`，这样视频就固定到顶部了

3、还有一种实现的方式就是使用`scroll-view`来实现，下面就是采用这种方式

4、我们需要设置滚动条的长度，这里使用`CSS`计算属性来处理。`video`的高度默认就是`225px`，所以我们这里可以直接减去`225px`。我们这里还设置了`100%`，它是相对于父元素的`100%`，如果这个时候父元素没有设置高度的话，就是相对于内容的`100%`，这个时候高度就很高

![image-20230423211209775](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330321.png)

5、所以我们需要对父元素设置一个高度，这里依旧采用`100vh`的方式让父元素占据整个视口

![image-20230423211449038](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330356.png)

## 11.3 音乐页面

### 11.3.1 Vant 库安装

1、安装`Vant库`，`npm i @vant/weapp -S --production`，然后需要在`工具` -> `构建npm`之后才能使用

![image-20230423212244849](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330381.png)

2、我们在`.json`文件中注册组件，然后直接在页面中使用就行了

![image-20230423212856377](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330432.png)

### 11.3.2 搜索框

1、我们这里直接使用`Vant`库中封装好的`搜索框`

![image-20230423215259639](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330407.png)

2、这里需要修改样式，存在 2 种方式。第一种就是使用类名强制修改里面的属性，第二种就是使用`CSS变量`来处理

![image-20230423215246530](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330427.png)

3、因为我们使用了`Vant`库中的函数，但是官方库并没有及时的更新，所以有一些小的问题。内部一直有一些内容在报错

![image-20230423215356936](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330449.png)

第一种解决方式就是修改内部的源码，但是修改之后，如果需要迁移项目的话就很麻烦。

第二种方式就是降低微信小程序的版本库，我们将基础库降低到`2.18.0`之后就不会出现这样的问题

![image-20230423215506377](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330481.png)

如果在选项中没有的话，我们可以直接在文件中修改也行

![image-20230423215558417](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330504.png)

4、点击搜索栏之后，需要跳转到搜索页面，这里查看官方文档中的事件监听就可以知道了

![image-20230423215703423](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330526.png)

![image-20230423220106998](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330236.png)

### 11.3.3 轮播图

#### 11.3.3.1 基本实现 - CSS 样式

![image-20230424162924513](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330263.png)

1、编写网络接口，请求数据到`page`中，页面渲染。我们使用`swiper`官方组件来设置轮播图

2、相应的`微信小程序`的`swiper`的选项查看文档即可

![image-20230424163032149](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330286.png)

3、构建完成之后需要编写样式，首先在该界面的元素都会左右留有空隙，这里对全局设置`padding`。但是设置之后会出现`搜索框`再次压缩的情况

![image-20230424163434785](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330319.png)

4、所以我们使用`CSS变量`来处理，`Vant`库在这里就是使用的变量来设置的

![image-20230424163531802](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330344.png)

5、随后便是设置轮播图的圆角，因为图片会顶出盒子，所以使用`overflow`来隐藏图片

![image-20230424163626791](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330406.png)

#### 11.3.3.2 \*轮播图高度

1、因为`swiper`默认是`150px`，如果这样的话下面的点就会位于图片下面，我们想让`swiper`的点位于图片中

2、其中一个办法就是将轮播图的高度固定死，但是这样就存在机型不同，轮播图图样式不同的情况，所以这种方式不考虑

![image-20230424163808306](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330247.png)

3、这里采用的是计算轮播图高度的形式。对于`image`组件存在一个事件，只要图片加载完毕就会自动调用

![image-20230424164341012](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330273.png)

里面存在一些`event`参数，里面包含了该图片的各种信息。我们可以计算图片的宽高比，并且计算组件的宽高来推算高度，但是这样的方式比较麻烦

![image-20230424164435485](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330310.png)

4、我们可以直接获取`image`组件的高度，设置给轮播图即可

5、在微信小程序中要获取高度需要一个新的`API`，`createSelectorQuery`放回一个实例

![image-20230424164732994](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330337.png)

6、但是这种方式获取元素很复杂，我们可以封装成一个组件来处理

7、回调函数中很难传递参数给外面，所以外面这里使用`promise`的方式将回调函数中的数据传输给外面，这个其实就是一种函数中传递参数的方式

![image-20230424165530658](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330365.png)

8、我们在`page`中获取高度，通过`{{ }}`方式动态决定高度的获取

9、首先我们想让点在图片中，本质就是图片覆盖整个`swiper`，我们将图片的`width`设置为`100%`，就相当于动态的决定图片的高度。所以我们获取图片的高度，设置给轮播图即可，这样就实现了不同机型的适配，动态的计算了轮播图的高度

![image-20230424165851294](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330394.png)

#### 11.3.3.3 \*获取节流

1、因为有很多的图片，我们不可能都去计算，我们这里使用节流的方式来提高性能。第一种方式就是使用自己编写的函数来节流

2、第二种方式就是使用`underscore`库来实现节流的操作，`npm i underscore`，然后构建`npm`

3、我们导出函数，并且给`throttle`函数，就可以实现节流的操作

![image-20230424171010225](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330131.png)

4、最后调用节流函数即可

![image-20230424171124948](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330159.png)

### 11.3.4 头部标题封装

![image-20230424212417509](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330235.png)

1、因为这个组件是经常要使用的，所以我们单独抽取成一个组件，并且按照下面的形式来设置样式

2、因为我们还需要点击更多之后跳转到推荐音乐的页面，所以我们还需要设置点击事件

3、这是一个通用的组件，我们通过自定义事件的形式，对父组件的函数进行回调

4、`areaHeaderTitle`表示标题，`hasMore`表示是否展示旁边的更多

![image-20230424212402093](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330266.png)

### 11.3.5 推荐音乐 - 状态管理

![image-20230425161908328](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330295.png)

1、首先是网络请求，然后放置到`page`中，再展示页面，这里做过很多这里就不过多的赘述了

2、很显然这种东西应该属于一种组件，所以我们封装为`musicItem`组件，并且通过`props`传递数据

![image-20230425162051550](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330317.png)

3、这个需求是首页展示 6 条数据，但是点击更多之后会展示 200 条数据，并且接口也是一次性返回 200 条数据，所以我们需要将着 200 条数据传输给另外一个`page`中，很显然小程序没有提供类似`pinia`的状态管理工具

4、所以这里就使用老师封装的`hy-event-store`库，来实现状态的管理，`npm i hy-event-store`

5、其基本的编写逻辑就是这样的，和`pinia`是差不多的

![image-20230425162424480](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330013.png)

6、我们使用`import`导入之后。`onState`来实时监听该数据，只要数据变化就会调用该回调函数。使用`dispatch`来调用管理工具中的`action`，这样就实现了微信小程序的状态管理

![image-20230425162524699](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330039.png)

7、我们直接在另外一个页面中监听即可

![image-20230425162705011](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330066.png)

### 11.3.6 推荐歌单 - 全局变量

![image-20230425162801457](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330092.png)

1、网络请求，展示数据，很显然这也可以封装成一个组件

![image-20230425162829808](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330122.png)

2、对于该模块我们需要横向滚动，所以我们这里使用`scroll-view`来处理，并且设置为`scroll-x`让它横向滚动，并且让它支持`enable-flex`

3、这里重点就是设置样式，我们想让滚动条左右占满，所以设置`flex`布局，并且使用`flex-shrink`，让他们之间不再相互拥挤

4、因为全部设置了一个`padding`左右两边为`20rpx`，所以我们也使用`margin-left`来冲出全部的宽度设置。

5、并且每个盒子都需要间距，这里就使用了`margin-left:24rpx`设置

![image-20230425163408744](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330144.png)

6、最后一条其实是最难的，老师没使用`flex`布局，这里直接参考它的视频。但是我这里发现直接设置为`padding-right`就可以实现右边的空隙

![image-20230425163433242](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330980.png)

7、因为我们需要要让滚动条按照屏幕的宽度来设置，这里有一个方法`wx.getSystemInfo`，它会返回手机的系统信息

8、我们能获取到信息，数据就需要存放在一个全局的位置，因为该参数不会经常修改，所以我选择放置在`app`中

![image-20230425163704353](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330003.png)

9、我们使用`getApp()`来获取设置即可

![image-20230425163754165](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330022.png)

### 11.3.7 热门歌单 - 组件抽取

![image-20230426145535930](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330061.png)

1、网络请求，数据展示

2、你可以发现这个功能其实和`推荐歌曲`是一样的，所以我们这里可以抽取成一个组件，这样以后可以直接复用

![image-20230426145703477](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330088.png)

3、我们在`main-music`中直接传递参数即可

![image-20230426145718847](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330124.png)

### 11.3.8 更多歌单 - 组件样式/网络请求优化

![image-20230426145822534](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330920.png)

1、我们点击歌单更多之后需要跳转到该页面中

2、这里依旧是请求数据，数据展示，但是这里有一个小技巧

3、因为所有的工作都需要先获取标签，所以我们使用同步的方式来获取标签，因为根据标签来获取数据都是不相干的，而且无前后顺序要求，所以我们这里直接获取`promise`并且传入到`promise.all`中，这样就提高了网络通讯的性能。

4、并且网络请求之后再去使用`this.setData`，也就只渲染了一次页面，提高了运行的性能

![image-20230426150015847](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330951.png)

5、因为我们之前就封装了一个类似的组件，所以可以直接复用

![image-20230426150400388](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330982.png)

6、我们引入组件直接复用

7、但是存在一个组件化抽取之后样式的问题，我之前直接将该组件的宽度写死，这样就导致了组件的复用性不高，需要后续手动修改样式

![image-20230426150419805](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330013.png)

8、对于类似的组件可以采取这样的样式编写的形式，给父组件设置`width:100%`

![image-20230426150618423](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330042.png)

这样该组件的宽度就通过使用者的样式来决定了

![image-20230426150716733](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330122.png)

### 11.3.9 巅峰榜 - 数据映射

![image-20230427093810479](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330098.png)

1、我们要实现这样的榜单，因为这个数据需要在不同的页面中展示，所以我们需要将这些数据存放在`store`中

2、我们这里使用`对象`的映射来表现数据，并且采用下面的方式来请求数据就达到所有数据都是异步请求

![image-20230427094036271](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330124.png)

3、请求到数据之后就需要监听该数据，并且调用里面的方法

![image-20230427094156613](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330151.png)

4、剩下的就是页面展示部分了，这块区域很显然要抽取为一个组件

![image-20230427094327567](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330182.png)

![image-20230427094337212](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330210.png)

### 11.3.10 获取音乐列表

![image-20230427205524799](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330240.png)

1、我们点击排行榜之后会进入到这个页面

2、这个本质就是获取数据，并且存入到`store`中，这个在我获取巅峰榜的时候就存起来了

![image-20230427205657159](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330062.png)

3、我们点击之后会引入该数据，这个时候我们就需要使用`type`或者`value`来区分，是从那个入口进入的

![image-20230427205852587](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330084.png)

4、随后便是根据`type`设置值，重新渲染界面

![image-20230428113050699](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330105.png)

5、因为点击歌单之后还存在上面的歌单图片的展示

![image-20230428113206362](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330132.png)

所以我们这里直接封装成一个组件来使用，使用`if`来判断

![image-20230428113153035](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330158.png)

6、对于小程序来说，我们要传入`bool`类型，要使用`{{ }}`来传入

![image-20230428113404504](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330189.png)

## 11.4 播放页面

因为该部分的逻辑比较复杂，所以这里只写思路。建议直接看代码

### 11.4.1 获取数据

![image-20230429170519574](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330058.png)

1、点击了这个`item`，就会自动跳转到播放界面，并且传递参数

2、按照我之前封装组件的喜好，我会将事件传递出来，内部参数都是外部规定的。但是这个组件如果这样编写会很难做，所以我直接就在内部传递参数

![image-20230429170749992](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330079.png)

3、参数传递之后就需要跳转页面，并且需要给页面传递参数

4、参数传递之后就需要进行网络请求，然后就是页面渲染了

![image-20230429171029987](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330103.png)

### 11.4.2 \*自定义导航栏

![image-20230429171127591](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330134.png)

1、对于微信小程序是允许我们设置导航栏，我们需要在`.json`中配置

![image-20230429171234194](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330160.png)

2、这个是我编写自定义导航栏的`HTML`结构。因为我们设置为自定义导航栏之后，文字的显示会在状态栏中显示，所以我们需要手动设置高度

3、但是这个高度不是固定的，因为不同的机型它的状态栏高度都是不一样的，所以我们需要动态设置

![image-20230429171426952](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330179.png)

4、我们依旧使用`getSystemInfo`来获取状态栏高度

![image-20230429171631198](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330000.png)

5、随后动态设置即可

![image-20230429171833459](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330024.png)

6、然后就是设置中间的主体部分，我们按照下面的结构搭建即可

7、但是这里存在一个插槽的使用，这个参考我之前的笔记

![image-20230429172011031](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330047.png)

8、切记，使用插槽之前一定要开启`options`

![image-20230429172129517](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330079.png)

9、而且对于`微信小程序`中是没有默认插槽值得，所以我们需要手动使用`CSS`来设置。下面得意思是`.default`默认设置为`none`，如果`.slot`为`empty`得话就设置为`flex`

10、设置这个`flex`是因为要取消`image`下面多余得`4px`，如果没这个需求设置为`block`也行

![image-20230429172229179](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330107.png)

11、随后设置在使用组件得地方设置插槽就行

![image-20230429172416300](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330147.png)

### 11.4.3 \*导航切换

![image-20230429172552921](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330977.png)

1、我们滑动下面得音乐页面就需要在不同得`page`中切换，这个存在 2 种思路。第一种就是使用`scroll-view`设置为`x轴滚动`。第二种方式就是把它当作轮播图来编写。很显然把它当作轮播图来编写会更加简单，所以我这里就采用这种方式

2、我们监听`swiper`得滚动，内部存在一个`event`记录了当前滚动到第几页

3、设置`currentIndex`之后就需要改变`navBar`得字体加粗

![image-20230429172909647](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330003.png)

4、因为`swiper`默认是由内容撑开得，状态栏是动态决定得，所以`swiper`也需要动态计算得来

5、`swiper`高度 = 屏幕高度 - 状态栏高度 - `navBar`高度

![image-20230429173254395](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330038.png)

6、我这里就动态定义了全局得`navBar`得高度，这样需要修改得话直接改这里就行

![image-20230429173454403](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330072.png)

7、我们还可以点击上面得文字来切换

![image-20230429173914485](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330105.png)

8、点击之后设置`currentIndex`。然后使用`current`来作为索引

![image-20230429173957494](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330171.png)

### 11.4.4 页面展示

![image-20230501192838576](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330192.png)

1、数据请求，页面展示

2、我这里分为 5 个部分，依次展示。随后就是编写样式了，这里就不去赘述

![image-20230501201938222](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330218.png)

### 11.4.5 歌曲播放

1、歌曲得播放，外面使用微信小程序内置得 API，也就是`wx.createInnerAudioContext()`

![image-20230501202142557](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330241.png)

2、我们设置`src`和`autoplay`就可以进入页面自动播放

![image-20230501202241166](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330273.png)

3、当然`微信小程序`中有对应得文档直接参考

4、这里有一个 bug，我们设置了`autoplay = true`可以自动播放，但是再设置`onWait`监听之后`autoplay`就失效了。我这里使用的方式是，因为`onWait`是针对`滚动条优化`的，只要我们人为操作滚动条的话就设置为`false`，只要再播放这个歌曲就设置为`true`来阻塞`onWait`

5、使用`isFristShowPlay`来控制函数是否执行

![image-20230502232044511](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330297.png)

只要每次播放其他音乐就会改为`true`，这样就不会执行`onWaiting`内的函数了

![image-20230502232133923](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330369.png)

只要拖动了滚动条就改为`false`，这样`onWating`还可以继续执行下面的代码

![image-20230502232248747](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330264.png)

### 11.4.6 滚动条

#### 11.4.6.1 基本实现

1、对于`audioContext`存在`onTimeUpdate`监听事件，只要音乐播放时间变化就会调用该回调函数

2、我们这里得`currentTime`使用`audioContext.currentTime`来获取当前时间，然后动态计算滚动条得数据

![image-20230501202438481](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330290.png)

该内容还会动态计算底部时间

![image-20230501202808189](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330320.png)

计算出得值传入到`slider`中得`value`，该值只会在是整数得情况下变化，内部自动做了节流

![image-20230501203126870](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330350.png)

3、因为还需要音乐得时长数据，因为该接口是动态加载数据得，所以使用`audioContext`会出现时长不对得情况，所以这里使用接口中获得时间

![image-20230501203036084](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330383.png)

#### 11.4.6.2 点击跳转

1、我们点击滚动条需要跳转到指定得时长得部分

2、因为我这里封装为组件，所以我传递事件出来

![image-20230501203316319](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330404.png)

3、使用`audioContext.seek`来设置音乐得时长，设置之后再设置`currentTime`

![image-20230501203456695](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330164.png)

4、因为我们点击之后数据可能还没缓存过来，所以我们需要先暂停，缓存到了之后再播放

![image-20230501203831703](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330192.png)

#### 11.4.6.3 拖动播放

1、我们拖动滚动条之后也会自动改变时长。这里使用`bindchanging`来监听事件

![image-20230501203943056](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330217.png)

2、我们需要`isChangingSlider`来表示是否在拖动，如果拖动就不去实时加载音频数据

3、并且该函数使用了节流，我们这里使用了`underscore库`中得`throttle`来实现

![image-20230501204200077](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330244.png)

使用`isChanginingSlider`之后就不会去动态渲染进度条了，也就避免拖动时滑动条跳动得`bug`

![image-20230501204520687](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330270.png)

### 11.4.7 歌词解析

1、这是歌词解析得函数，因为传来得歌词一般都是有规律得，所以可以解析

![image-20230501205020287](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330345.png)

2、我们使用`for`来遍历，这就是一个小算法

![image-20230501205113641](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330170.png)

3、这里直接参考代码即可

### 11.4.8 播放列表

1、我们点击下一首或者上一首的时候肯定是需要一个播放列表的

2、所以播放列表属于多个页面都需要的，所以我们使用`store`的方式来存储

![image-20230502203652405](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330195.png)

3、点击歌曲之后传入`列表`和`索引`

![image-20230502203710614](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330223.png)

4、在`onLoad`中监听即可

![image-20230502203742654](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330252.png)

### 11.4.9 上一首/下一首

1、既然我们都能获取到歌曲的列表了，我们也可以做上一首和下一首的功能

2、在做功能之前，我们需要抽取播放功能的核心代码，这样我们直接传入`id`即可播放下一首

![image-20230502204117432](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330273.png)

3、我们获取共享的歌曲的索引和列表

![image-20230502204155399](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330346.png)

编写边界判断的条件，并且根据条件来计算

![image-20230502204410824](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330151.png)

### 11.4.10 播放模式

1、组件中发出事件，并且根据数据来计算现在处于那种模式

2、而且还需要将该数据传递给父组件，这样父组件中就可以做判断了

![image-20230502204623094](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330174.png)

3、因为下一首和上一首的逻辑都封装起来了，所以我们也需要判断切换的模式

4、如果是列表播放的话，就默认下一首。如果是随机播放的话，就随机生成数字进行播放，并且这里需要注意不能和上次随机到的数字一样

![image-20230502204750370](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330196.png)

5、因为还需要一个列表循环，这个表示的意思是依旧可以下一首，如果是自然播放完毕就一直循环着一首

6、微信小程序的`audioContext`提供了一个`API`，`loop`来表示是否循环播放

7、我们在模式切换的时候也切换一下`loop`的值

![image-20230502205110214](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330229.png)

8、如果实时自然播放完毕就不执行`playNextEvent`的方法

![image-20230502205238022](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330253.png)

### 11.4.11 播放完毕

1、使用`audioContext`的`onEnded`事件，只要自然播放完毕就下一首

![image-20230503095945552](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330340.png)

## 11.5 歌词页面

### 11.5.1 页面展示

![image-20230502202553638](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330106.png)

1、获取数据并且展示。我们这里使用看`scroll-view`来表示滑动

![image-20230502202355735](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330127.png)

2、这是样式部分。因为只是基础部分，所以这里就不过多赘述了

![image-20230502202536216](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330152.png)

### 11.5.2 歌词滚动

1、这里采取的措施是使用`微信小程序`提供的`scroll-top`来移动滚动条

2、添加`scroll-with-animation`让滚动有动画

![image-20230502202652521](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330178.png)

3、这里存在一个 bug。因为我设置的滚动高度是固定的，但是歌词有多有少，可能存在滚动偏差的情况

## 11.6 代码抽取

我这里存放了未抽取和已经抽取的代码，可以对比查看，而且我还设置了`git`

1、我们将核心的播放逻辑都抽取到`player.js`中

![image-20230504104622729](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330207.png)

## 11.7 浮动播放器

![image-20230504103954985](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032330305.png)

1、下面是`HTML`结构

![image-20230504103938182](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331025.png)

下面是`CSS`结构

![image-20230504104016344](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331048.png)

2、因为我们之前已经将核心代码进行了抽取，所以直接调用即可

3、因为我之前的数据都是实时加载的，并且通过`eventbus`来实时监听，所以我们直接跳转到`music-play`中即可

![image-20230504104340197](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331067.png)

但是在`music-play`中需要做处理，因为没有传入`id`，所以就是继续听之前的歌

![image-20230504104604911](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331102.png)

## 11.8 分包

### 11.8.1 基本介绍

官方文档：[分包加载 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html)

> 基本介绍

1、我们在详情中可以查看`本地代码`中的代码依赖分析

![image-20230503210443311](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331139.png)

可以看到不同文件中各个文件的大小

![image-20230503210521361](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331239.png)

> 独立分包

1、正常分包需要主包加载完毕之后才会加载该`独立分包`，这需要该包不依赖主包的任何东西

![image-20230503214652966](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331995.png)

2、如果要使用的话，添加`independent`配置即可

![image-20230503214707660](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331017.png)

> 分包预下载

1、我们可以配置，再下载某个包完成之后，立即下载其他包

![image-20230503214942504](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331039.png)

2、我们可以配置`preloadRule`，就表示分包预下载

3、`pages/main-music...`表示该包下载完毕就会下载下面配置的包。`packages`表示要下载的包，它可以配置`root`和`name`中的值，`network`表示在什么网络时下载，`all`表示所有网络都下载

![image-20230503215030800](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331068.png)

> 分包异步化

1、如果`video`中封装了需要的`组件`和`函数`，但是我们需要在`play`中使用。但是`video`中配置了分包，所以不一定在`play`中可以引入到，所以就可以配置分异步化

2、这样就可以在`play`中配置替代，该方式查看文档来解决。因为这种需求一般很少

### 11.8.2 基本使用

1、我之前的文档结构只存在`pages`包，我称为该包为主包，我们在一开始加载小程序的时候就会全部加载下来

2、但是我们分包之后就只会加载我们需要的包，我们不点击分包的页面就不会下载，这样加快了首屏加载的速度。下面是未分包之前

![image-20230503213710983](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331093.png)

3、我们将包分为下面的形式

4、可以看出，包分为`musicPlayer`、`musicSearch`、`musicVideo`，它们对应的就是`music-play`、`detail-search`、`detail-mv`

![image-20230503213615534](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331142.png)

5、但是我们分出来之后，微信小程序不一定知道如何查找包，这个时候就需要在`app.json`中配置

6、下面的`subPackages`就是分出来的包，`root`表示根文件夹名，`pages`表示下面的包

![image-20230503213958142](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331778.png)

6、我们将包分出来之后，相应的地址都需要修改

7、对应的`路由`地址也需要修改，在最前面加上`根文件名`即可

![image-20230503214127635](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331801.png)

8、对于`.json`中引入的组件也需要修改，注意最好使用下面的方式来编辑路径，如果使用`../../components....`会造成路径寻找不到

![image-20230503214259253](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331826.png)

9、可以看到分包之后，就可以看到下面我们分的包的文件大小了

![image-20230503214421464](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331853.png)

### 11.8.3 Vant 库优化

1、我们需要手动来删除`Vant`库的的文件

2、我们根据使用到了组件，来一层层查找库中的文件，并且记录之后，手动删除

3、下面就是我们这个项目中剩余的文件夹

![image-20230504102806208](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331894.png)

## 11.9 云开发

### 11.9.1 我的页面

![image-20230505202953547](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331035.png)

1、因为有收藏和喜欢的功能，所以我们需要添加一个`我的`的`tabbar`，这些步骤直接查看之前的代码即可

2、下面就是页面的开发中`HTML`的结构

![image-20230505203157007](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331638.png)

### 11.9.2 云开发搭建

1、首先要创建对应的`云开发`环境，并且创建`云函数`的文件夹

![image-20230505203802278](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331668.png)

2、我们在`project.config.json`中写入`cloudfunctionRoot`配置，并且指出对应的文件夹名字，就可以配置对应的云开发环境

3、如果没有配置上可以重启微信开发工具

![image-20230505203855847](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331693.png)

4、这里我们暂时只使用获取`openid`的能力

![image-20230505205012441](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331739.png)

### 11.9.3 登录功能

1、因为微信小程序获取用户信息政策已经修改了，所以要按照下面的版本号对应的方式来处理

![image-20230505203521461](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331864.png)

2、我这里使用到的版本号未`2.31.1`，所以我使用`头像昵称填写能力`的方式来处理，为`open-type`添加选择头像的能力，并且做出对应的事件监听

![image-20230505203614559](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331553.png)

3、头像的地址会传递进`event`，我们需要将获取到的信息存入到`storage`中

![image-20230505203700900](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331575.png)

4、我们还需要注意，一开始加载页面的时候也要获取登录的状态

![image-20230505204242139](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331595.png)

### 11.9.4 收藏/喜欢

![image-20230505203301088](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331620.png)

1、我们点击右边的`...`之后就可以显示收藏和喜欢的功能

![image-20230505204355309](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331649.png)

2、监听点击事件，这里存在事件冒泡的问题，可以使用`catchtap`来阻止事件冒泡

![image-20230505204531037](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331692.png)

3、对应的选择界面，我们使用微信小程序自带的`API`，也就是`wxx.showActionSheet`，它会给`success`传递选择的`index`值

![image-20230505204447693](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331383.png)

4、点击之后要对对应的歌曲进行收藏和喜欢的操作，这里我提前在云数据库中创建了集合

![image-20230505204856014](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331406.png)

5、点击之后要将对应的数据插入到数据库中

6、因为使用了云开发的能力，所以我们在传入数据的时候会默认生成`_openid`，这是用户的`openid`。不需要我们去做额外的操作![image-20230505204807157](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331428.png)

### 11.9.5 收藏/喜欢/历史页面跳转

1、存在不同的页面，我这里使用`tabs`变量来控制

![image-20230505205206497](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331456.png)

2、使用变量就可以控制跳转的页面了，并且传入对应的参数

![image-20230505205137695](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331485.png)

3、根据传入的`type`来执行不同的函数，并且通过`openid`来获取对应的值，在页面中展示即可

![image-20230505205252962](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331580.png)

这里也可以不使用`openid`来判断，因为云数据库中存在权限设置，直接勾选`仅创建者可读写`就可以实现`openid`区分用户的操作

![image-20230505205408902](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331286.png)

### 11.9.6 歌单功能 - 追加数据

1、这个就不过多的介绍了，和之前的流程是一样的

2、但是这里存在一个问题，我们需要对歌单数据进行追加，相对应的也提供了对应的`commond`，只需要`cmd.push()`就可以追加对应的数据

![image-20230506141201805](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331304.png)

3、并且还有一个架构设计上的思想，因为歌单数据都是统一的，最好的方式就是将歌单数据统一进行管理，这样我们在任何页面都可以监听到

![image-20230506141348890](https://knowledge-picture.oss-cn-wuhan-lr.aliyuncs.com/202405032331328.png)

4、剩下的开发流程基本就是一样的了，对数据的增删改查，并且在页面中进行展示
