# 1 基本介绍

>基本介绍

前端监控的目的很明确，无非就是让我们的产品更完善，更符合我们和用户的需求。运营与产品团队需要关注用户在产品内的行为记录，通过用户的行为记录来优化产品，研发与测试团队则需要关注产品的性能以及异常，确保产品的性能体验以及安全送代。

而一个完整的前端监控平台至少需要包括三个部分：**数据采集与上报、数据整理和存储、数据展示一**。算上需要监控的项目的话，也就是说，至少需要4个项目才能完整的记录前端监控的内容。


>监控平台

目前也有很多的监控平台可以使用：**阿里ASMR、Sentry、灯塔**等


>监控SDK

通过上面两个现成的框架，大家也大致能看出，我们前端监控到底是要干什么事情
- `页面的性能情况`：包括各阶段加载耗时，一些关键性的用户体验指标等
- `用户的行为情况`：包括PV、UV、访问来路，路由跳转等
- `接口的调用情况`：通过http访问的外部接口的成功率、耗时情况等
- `页面的稳定情况`：各种前端异常等
- `数据上报`：如何将监控捕获到的数据上报

其实完整的监控平台至少分为三大类
- **数据采集与上报**
- 数据整理和存储
- 数据展示

而上面总结的那一大堆，主要就是监控SDK的实现，SDK，其实就是SoftwareDevelopmentKit.其实就是提供实现监控的API


>监控埋点

无论性能，行为还是异常情况，我们都需要在需要监控的项目代码中去监听这些内容。那么具体监听的手段其实就被称之为前端埋点。

前端埋点还分为**手动埋点**和**无痕埋点**。

**手动埋点**，就是在要监听的项目中的某段代码或者某个事件中加入一段监听SDK代码，然后对监听的内容进行上报，好处就是可以对关键性行为做出具体的跟踪，坏处是具有侵入性

**无痕埋点**，就是就是对监听的项目进行全部无脑监听，比如点击事件，滚动事件等等，只要触发了就上报。好处就是对代码没有侵入性，坏处当然也很明显无法快速定位关键信息，上报次数多，服务器压力大


>监控整体流程

其实监控的整体流程如下

- 监控目的
	 - 事前预警
	 - 事后分析
	 - 性能分析
	 - 业务赋能
- 监控流程
	- 监控SDK
		- 数据采集
		- 数据上报
	- 数据看板
	- 错误还原
	- 监控报警
- 监控平台构成
	- 数据采集与上报
	- 数据整理与存储
	- 数据展示
- 监控SDK
	- 错误监控采集
		- JS代码运行错误
		- Promise异步错误
		- 静态资源加载错误
		- 接口请求错误
		- 跨域脚本错误
		- Vue报错
		- React报错
	- 白屏监控监测
		- 白屏监测难点
			- 白屏原因的不确定：
				- 资源加载错误
				- 代码执行错误
			- 前端渲染方式的多样性：前端很多渲染方式，比如CSR、SSR、SPA、MPA每种方式不同，原因也不同
		- 解决方案
			- onerror + dom监测
			- mutation observer api
			- 页面截图监测
			- elementsFromPoint api 采样对比
			- 饿了么白屏监测方案
	- 性能数据监测采集
		- FP：First Paint 白屏时间
		- FCP：First Contentful Paint 首次内容绘制时间
		- LCP：Largest Contentful Paint 最大内容绘制时间
		- TTFB：Time To First Byte 第一字节时间
		- FID：First Input Delay 首次输入延迟
		- CLS：Cumulative Layout Shift 累积布局偏移
	- 用户行为数据监控采集
		- PV、UV
		- 页面跳转
		- 用户点击
		- 页面停留时长
		- 页面访问速度
	- 个性化指标
		- Long Task 长任务
		- Memory 页面内存
		- 首屏加载时间
	- 数据上报
		- 数据上报方式
			- 图片打点上传
			- 常规ajax上传
			- sendBeacon
		- 数据上报时间
			- 采用requestIdleCallback / setTimeout 延时上报
			- 在 beforeunload 回调函数中上报
			- 缓存上报数据、达到一定数量再上报
- 错误还原
	- source map 代码还原
	- 错误行为栈
	- rrweb前端录屏
- 数据看板
	- 错误列表
	- PV、UV等
	- 性能指标
- 监控报警
	- 报警规则
	- 报警方式


