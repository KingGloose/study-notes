# 1 简单选择器

## 1.1 通用选择器

1、表示所有的元素都选中，其中通用选择器也可以叫做通配符选择器，
![[00 assets/be0fe1f12cec52fc181d775fb65a461c_MD5.png]]

2、但是在实际的项目中并不会直接使用通用选择器，因为这个选择器会将所有的`HTML`元素都遍历一遍，所以就会导致代码执行的效率变低，所以更加推荐下面的方式，将要设置的元素都手动写出来
![[00 assets/3143b0871f2c28c54f5b715d11795a50_MD5.png]]

## 1.2 元素选择器

1、使用元素的名称来设置选择器，比如：`p{ }` ，`div{ }`......设置一个元素选择器，该文件下面的所有的元素都会加上该样式
![[00 assets/4986b3633416ab890f6716e67785766d_MD5.png]]

## 1.3 类/ID 选择器

1、为`HTML`添加`class/ID`属性，再来通过`类/ID选择器`来获取。虽然`id选择器`可以多次使用，但是为了遵守`HTML`的规范，`id`选择器最好使用一次
![[00 assets/946e5edc44fb4221b7aeb1268d93cfe8_MD5.png]]

![[00 assets/eeb60bb17fb33011b8756e16257fc0c4_MD5.png]]

# 2 属性选择器

1.`[att]`：只要任意标签中存在`属性att`，那么该标签就会被选择

2.`E[att]`：只要`E标签`中存在`属性att`就会被选择

3.`E[att = value]`：只要`E标签`中的存在该`属性att`，并且属性值等于`value`就会被选择

4.`E[att^ = value]`：只要`E标签`中的存在该`属性att`，并且属性值以`value开头`就会被选择

5.`E[att$ = value]`：只要`E标签`中的存在该`属性att`，并且属性值以`value结束`就会被选择

6.`E[att* = value]`：只要`E标签`中的存在该`属性att`，并且属性值中`存在value`就会被选择

我们还存在`[att = value]、[att ^= value]......`的用法，这个在`Vue`的组件库和`scoped`中比较常见

![[00 assets/cb5319479e2c26920bf08ebdd0af2329_MD5.png]]

# 3 关系选择器

1、后代选择器：`祖先 后代 { }`，比如`div span`就是`div`包裹下面的**所有**的`span`都会被选择
![[00 assets/573fbb81460671eb9493f550d6d3132b_MD5.png]]

2、子代选择器：`父代 > 子代 { }`，比如`div > span`表示`div`包裹下面的第一代的`span`才会被选择
![[00 assets/a2a910ca6096e7ed8aed845347af9cb3_MD5.png]]

3、兄弟选择器：`前一个兄弟 + 后一个兄弟 { }`，表示紧挨着的标签才会被选择
![[00 assets/978b1c6807529dd1ea6d0d0f2617ec7b_MD5.png]]

4、同辈选择器：`前面所有的兄弟 ~ 后面所有的兄弟`所有兄弟的标签就会被选择
![[00 assets/4b91617e374b7e36fead11157f846e8d_MD5.png]]

# 4 选择器组

1、`交集选择器`：2 个选择的条件都符合，就会被选择，这个主要是为了精准选择某一个元素。注意不带空格，带空格的话就是后代选择器
![[00 assets/a8b982a9ac48d0e27a8da15444d331f5_MD5.png]]

2、`并集选择器`：只要标签中包含里面条件就会被选择，这个主要是给多个元素设置同一个属性
![[00 assets/69cb8cae3c46bec3876285f9a44d1cb9_MD5.png]]

# 5 伪类选择器

## 5.1 基本介绍

![[00 assets/3ba4e49ed8c918932af61374b8774ed1_MD5.png]]

当你鼠标指向`div`就会使用下面的样式属性，相当于执行了指定的操作，那么就会被该选择器选中

![[00 assets/6cbcf301d568b5e4a394e805a27882a3_MD5.png]]

> 常见伪类

![[00 assets/65a641f18b3d7d83aa43dce119e8d58a_MD5.png]]

## 5.2 动态伪类

- **:link** 未访问的链接
- **:visited** 已访问的链接
- **:hover** 鼠标挪动到链接上
- **:active** 激活链接(鼠标在连接上按住未松手)
- **:fouces** 拥有输入焦点的元素

**:hover**必须放在**:link**、**:visited**和**:active**，后面才能完全生效，所以建议的编写顺序是**:link、:visited、:focus、:hover 、:active**

1、下面是实践的案例，其中`a标签`中每个动态伪类都可以被设置，但是其他标签不能设置`:link和:visited`

![[00 assets/680634acc7a06a228b7f9e34ecedbe57_MD5.png]]

2、伪类元素后面可以添加选择器，这样的话只要鼠标触摸到`box`的时候就会设置`main`的样式。并且这里需要注意和前面的`box`是否存在父子关系

![[00 assets/d857b08b94fbc1105c8dc751c103d91c_MD5.png]]

## 5.3 结构伪类

### 5.3.1 :nth-child

> :nth-child()

![[00 assets/44b5e9260e3b0ee473ad3e1758816a48_MD5.png]]

### 5.3.2 :nth-of-type()

> :nth-of-type()

![[00 assets/8e538f6ec92e7c7277d8dba998e90b10_MD5.png]]

> :nth-child 和:nth-of-type 对比

唯一的区别就是计算元素的方式不一样

![[00 assets/76e3e1ae1ac4055383b1c283e82b0623_MD5.png]]

### 5.3.3 :root

`:root`选择所有的元素

![[00 assets/07228357116ec8186d6ce3e332a14c9c_MD5.png]]

### 5.3.4 :empty

`:empty`只要没有子元素就改变

![[00 assets/de492a68058108bb64eb2b201198293f_MD5.png]]

### 5.3.5 :only-child

`:only-child`标签，父元素只有一个的话就去执行

![[00 assets/8795d7e42789f04d84c6847e8f3e50a9_MD5.png]]

`only-of-type()`就和`:nth-of-type/:nth-child`的计算方式一样

## 5.4 否定伪类

`:not()`将符合条件的元素从选择器中去除

> 1

下面就是表示`ul > li`中除了第三个`li`，其他`li`都设置为红色

![[00 assets/f7b3e730493639a7d1a4b335c2087c19_MD5.jpeg]]

> 2.

body 下面的子元素不包含`h2`就选中

![[00 assets/a3811b2c692d961c3f3943f04aac1e7e_MD5.png]]

# 6 伪元素

这里需要和`伪类选择器`做出区分，`伪元素`是`::xxxx`，而`伪类选择器`是`:xxxx`

> ::first-line 和::first-letter

![[00 assets/01b8d519d2c1f530bcfad8e1b49190a0_MD5.jpeg]]

> ::before 和::after

这个应用场景就比较多了，该伪元素通常和`content`来使用。

下面就是一个例子，该排行榜可能左边又不同的数字，右边又有不同的图标来显示，我们不可能一个个为元素添加标签，所以就可以使用`::before`和`::after`

![[00 assets/9edde846955d4f9052448a74a419af0a_MD5.jpeg]]

下面就对比了`直接手写的标签`和使用`::before和::after`的区别，很明显使用`::before和::after`简单很多，而且扩展性也强很多

![[00 assets/3453d50223d1392fb535f7c56e381938_MD5.png]]

当然对于`content`不仅仅可以添加`字符串`还可以使用`url()`来添加链接，这个`url()`也可以在`@import url()`

我们也可以使用`::before和::after`来绘制图形，假如要显示的话一定不能省略`content`

![[00 assets/020d7b2041607b0cfc3fb4b16e4f13fd_MD5.png]]

# 7 选择器权重

下面就是选择器的权重表，假如需要的话可以查询

|              选择器              |    权重    |
| :------------------------------: | :--------: |
|             !import              |    最高    |
|             内联样式             |  1.0.0.0   |
|            ID 选择器             |  0.1.0.0   |
| 类选择器、伪类选择器、属性选择器 |  0.0.1.0   |
|        元素选择器、伪元素        |  0.0.0.1   |
|                \*                |  0.0.0.0   |
|             继承样式             | 没有优先级 |

选择器的权重表遵循下面的规则

1. 当优先级是一致的时候，遵循的`最后一个选择器的样式`
2. 分组选择器是单独计算的，比如`.one,.two,.three`，那么设置类为`one`的权重就是`0.0.1.0`
3. 权重不会越级，比如：设置一个`id选择器`和设置十个`class选择器`那个大？显而易见，肯定是`id选择器`，最后计算的值为`100`，而`class`就是`90`并不会越级超过`100`

下面就是一个计算权重的示例

![[00 assets/115300ee5c2a6567e9352b11092c1b90_MD5.png]]
