# 依赖追踪更精准

> 主题：理解“减少不必要的 effect 订阅与触发”到底意味着什么。

## 核心概念
依赖追踪是“读取时建立关系、变更时触发关系”。
“更精准”意味着：只追踪真正用到的依赖，避免把无关字段也加入 effect 的依赖集合。

## 以前常见的问题
- 读取了一个对象的某个字段，却把整个对象或更多层级都当作依赖。
- 对数组、Map/Set 的访问被粗粒度记录，导致无关变更也会触发。
- computed 链式依赖被多次订阅，触发时重复执行。

## 3.6 的直观理解
- 追踪更细粒度：只记录“这次读取用到的那一项”。
- 触发更精确：只有真正相关的依赖变更才会触发 effect。
- 结果：同样的更新，触发次数更少，性能更稳。

## 例子（概念层面）
- 读取 `state.list[0]`，只订阅索引 0，而不是整个 list。
- 读取 `map.get('a')`，只订阅 key 为 a 的依赖，而不是 map 的全部。
- computed 只在依赖变更时失效，而不是被多次重复标记。

## 实际影响
- 深层对象改动时，只有相关组件重渲染。
- 大列表、小改动时，触发成本显著降低。
- watch 的触发更可预测，避免“感觉没有变也触发”。

## 关联笔记
- [[Vue3.6 响应式重构]]
