# Vue3.6 响应式重构（速览与要点）

> 目标：从资深 Vue 使用者视角，聚焦关键实现、性能变化、API 变化、数据结构/算法、与旧版对比及实际影响。

## 一句话定位
Vue3.6 的响应式重构主要是“性能与内存模型”的优化：依赖收集更精准、触发更合并、数据结构更轻量，确保 Composition API 在复杂场景下更稳定、更可预测。

## 速览清单
- 依赖追踪更精准：减少不必要的 effect 订阅与触发（详见：[[依赖追踪更精准]]）。
- 触发调度更稳定：去重、合并、按需触发，降低重复执行。
- 依赖图更轻量：减少临时结构创建，缓解 GC 压力。
- 组合语义更一致：computed/watch/shallow/readonly 的边缘行为更统一。
- API 形态基本不变：大多是底层行为优化，对日常使用透明。

## 关键实现（不展开源码结构）
### 1) 依赖收集更细粒度
- 读取时只建立必要依赖，避免“过度收集”。
- 对数组索引、length，以及 Map/Set 等结构做更精细的分类追踪。
- 结果是：无关变更不再导致大面积触发。

### 2) 触发调度更可控
- 触发阶段对 effect 去重与排序更明确。
- computed 的失效更新更“惰性”，链式计算减少重复执行。
- watch 调度更稳定，减少“同一轮多次触发”的体感问题。

### 3) 依赖图更紧凑
- 依赖集合减少冗余结构，降低内存使用。
- 热点读写路径进行了缓存层面的优化，提升高频场景性能。

### 4) 行为一致性增强
- shallowReactive / shallowRef 与 readonly 的组合更一致。
- watch、computed 的同步/异步调度在边缘场景更稳定。

## 性能变化（你能直观看到的）
- 大表格/列表频繁更新：CPU 占用更低。
- 深层响应式对象：抖动更少，触发更少。
- computed 链：级联计算次数减少。
- 深度 watch：频率更可控。

## API 变化与兼容性
- API 形态基本不变。
- 边缘行为更可预测：
  - computed 失效更按需
  - watch 触发更稳定

## 与旧版对比要点
- 旧版容易“收太多依赖” → 3.6 更精准。
- 旧版调度易重复 → 3.6 去重与合并更明确。
- 旧版组合行为偶发不一致 → 3.6 行为更统一。

## 实际使用影响（建议留意）
- 过去依赖“过度触发”隐式完成的逻辑，在 3.6 可能需要显式触发。
- 调试时可能感觉触发次数减少，这是正常优化结果。

## 推荐学习路径
1) 先建立“依赖收集 vs 触发调度”的概念框架。
2) 结合自己的项目场景检查高频更新与深度对象的触发行为。
3) 对 computed/watch/shallow/readonly 的组合语义做一次回归测试。

## 可选练习（自测）
- 设计一个深层嵌套对象，分别在 3.5 与 3.6 观察触发次数。
- 构造 computed 链式依赖，观察重复执行是否减少。
- 使用 watch 深度监听 + 大数组更新，观察调度频率变化。
