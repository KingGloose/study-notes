# 时间规划

```
2024.6 找实习
2024.8 中旬 离职准备秋招
2024.9 全力投简历准备
2024.10 秋招结束，准备看公司情况来考虑是否春招，找一个好的名声比较大的实习单位
如果秋招不顺利 2025.3 全力准备春招
```

# 个人介绍

## V1

面试官好，我叫张嘉辉，即将于 2025 年毕业于湖北师范大学计算机科学与技术，我是来应聘前端实习生

在校期间，我积极参与学科竞赛，获得了湖北省第十二届、十三届“挑战杯”省赛铜奖，以及第八届中国国际“互联网+”省赛铜奖。此外，我还荣获了优秀班干部、学习标兵、优秀团员以及“青马工程”优秀学员等荣誉称号

同时在校期间，我也独立完成了多个项目

第一个是人大小程序，他的技术栈是微信小程序原生和 vant 组件库，该项目的微信小程序部分和原型设计由我个人独自开发上线，做过首屏加载速度和包体积的优化，服务了数百名人大代表记录履职积分，发表建议目前已经稳定运行 2 年；

第二个项目是七夕诗墙，这是一个 uniapp 的跨端项目，用户可以通过线下的电视合成图片，同时我负责整个项目的前后端部分，该项目的设备性能不算很好，而且屏幕太大导致了 gpu 渲染压力较大，为了整体的可用性，需要做对应的性能优化，把项目优化到可用的状态；

第三个项目是瑞龙环保，是一个综合平台，包括了数据大屏、企业官网、物联设备的 mqtt 连接等

我认为自己是一个热爱技术、热爱前端的人，也认为自己可以胜任投递的岗位，希望今天的面试愉快，谢谢！

## V2

面试官您好，我是张嘉辉，很高兴有机会参加贵公司的前端开发实习生面试。我主要的技术栈是：Vue、Nodejs、Uniapp、微信小程序等

我对于前端技术充满热情，在校期间，我积极投身于多个项目的独立开发，这些项目均采用前端技术进行构建。热衷于技术研究，并乐于不断学习和探索

除了项目开发，我还积极参与各类学科竞赛，提高了我的团队协作和沟通能力。

我愿意独立思考和换位思考，让我能够从不同角度审视问题，并寻找到合适的解决方案。

期待能有机会加入贵公司，与团队一起成长，共创佳绩。谢谢！

## V3

面试官您好，我叫张嘉辉，很高兴有机会参加贵公司的面试。我主要的技术栈是：Vue、Nodejs、Uniapp、微信小程序等

我对于前端技术充满热情，热衷于技术研究，并乐于不断学习和探索。在校期间，我积极投身于多个项目的开发，这些项目均采用前端技术进行构建。

除了项目开发，我还积极参与各类学科竞赛，提高了我的团队协作和沟通能力。

我愿意独立思考和换位思考，让我能够从不同角度审视问题，并寻找到合适的解决方案。

期待能有机会加入贵公司，与团队一起成长，共创佳绩。谢谢！

## V4

面试官您好，我叫张嘉辉，很高兴有机会参加贵公司的面试，我来自湖北师范大学，在校期间带领工作室成员获得 6 项省级荣誉，也独立完成了多个项目上线开发，简历中的人大小程序和七夕诗墙目前已经运营的近 2 年，前几天刚刚将瑞龙环保的项目部署上线

我对前端技术充满热情，热衷于技术的研究，并乐于不断学习和探索，擅于团队开发，能从不同得角度来思考，期待加入贵公司，与团队一起成长

# 项目总结

## **人大**

> 需求背景：

1、针对上线的问题，因为政府内部组织人员变动，导致备案上线等一系列认证活动很麻烦，所以需要理清各部门信息

2、部分人大代表机型较老，导致首屏加载速度偏慢

3、优化包体积大小，因为主包体积已经接近 2mb 了，所以可以做部分的体积优化

4、 针对履职题目的复杂性和多变性，因为部分题目为年审题目，且有些时段需要更新选项，而且每次开代表会议的时候也会不一样

5、一起编写的后端因为比较忙，所以部分接口的设计，需要我自己一个人来完成

6、针对部分分包其实还有一个，就是代表大会的场景，其实这个时候很多代表是在一个小屋子的，部分代表的手机幸好较老，基带也不是很好，希望能以最低的带宽来完成签到的功能，需要你去采取分包的策略

> 解决：

1、针对小程序的备案直接写主体人责任人授权书，小程序负责人授权书；针对域名备案的问题，使用该县人大子域名来做 DNS 解析

2、采用分包，让首屏加载速度提升 23%，因为部分代表其实是不存在论坛和审批的功能，所以在一开始的时候并不需要加载对应的功能

3、手动裁剪掉业务中没用到的 Vant 组件，减少体积 83%

4、设计并实现通过配置化来展示题目，编写执行的 hook 函数来做额外的区分，也节约了后期大量的维护题目的成本

5、这其实放在现在可以一个人写完，但是放在之前其实不行，作为一个前端还没学明白的人

> 总结：

1、这是我大二时的作品，各方面存在很多设计时的问题，但是通过这一个项目，我知道代码编写的整体流程，也知道了前后端联调等一系列工作，也为我后续的学习和接单铺路

2、站在现在的角度来讲其实是一个很青涩的作品，各种设计让我现在重新去做的话，可以做的更好，比如一系列审核功能，报表数据等

3、还有一个就是作为一个前端开发，我需要快速上手原型工具，根据自己平时的经验来做设计；还要跑线下一起和代表们商讨业务，也让我知道了人情事故，随后还需要作为负责人，去和后端开发表述整体的业务

## **七夕诗墙**

> 需求背景：

1、因为测试机和正式上线的机器不一致；测试机屏幕较小，而且用的芯片较好，但是正式机芯片差距很大，而且屏幕较大，gpu 渲染压力很大，所以上线测试的时候存在 Canvas 拖动严重卡顿的问题

2、针对古诗列表渲染场景，因为选择完古诗还需要选择加载的字体，所以需要 Canvas 实时渲染

3、并且该设备默认并未开启硬件加速，导致视频播放失败，

4、 该设备需要全屏使用，而且还是 uniapp 的 bug，设置安卓全屏的时候下面会给虚拟按键留空

5、微信支付的整体流程

6、RK3399 为正式机器、RK3588 为测试机器，机器性能差异较大，如何去做对应的适配

> 解决：

1、为了给瑞芯 RK3399 做 Canvas 绘图性能优化，使用 renderjs 将 Canvas 拖拽部分逻辑重写迁移到的视图层，减少逻辑层和视图层的通讯损耗，提高拖动流畅度

2、需要大量的列表渲染使用 app-nvue 重构提高渲染速度，整体优化 0.6s

这里后期其实可以换成虚拟列表，来做实时渲染，第一次进入的时候只渲染部分内容，或者已经渲染的做图片缓存，下次直接加载缓存

3、这个设备较坑，出厂不知道为啥没有硬件加速功能，还需要使用 H5+手动开启设备的硬件加速，同时加快渲染速度

4、为了解决全屏导致的虚拟按钮留白问题，封装挂载全局函数操作 Webview 全局下移

5、首先就是微信商户号的开通，以及一系列的加密策略需要自己一个人来做，需要大量来阅读官方文档，最后微信支付的后端接口部分，使用的开源库来设计的流程，你只需要传入加密库即可

> 总结：

1、这个项目一开始设计的时候就是电视端使用安卓来开发，可能会少很多的问题，但是考虑到成本使用了 uniapp 来开发，因为跨端，所以拖拽部分是可以复用的，而且开发周期短很多

2、这个项目也是独立一个人完成的，但是在跨端的时候碰到了很多的问题需要解决，也让我第一次意识到一个产品的设计需要做大量的考虑，特别是跨端的项目

## **瑞龙环保**

> 需求背景：

1、整体的开发难度可控，其实最难的部分就是沟通

2、数据大屏全局样式污染，导致样式错误，这个也是一次遇到这样的情况，所以一开始没发现；

3、公司官网，要有内容，并且要美观大气

4、项目介绍和产品介绍需要表单，这里存在复用的问题

> 解决：

1、样式污染的问题，后续调试源码的时候发现到全局样式的污染，所以我使用 patch-package 来记录源码的修改

2、使用 aosjs 来实现动画效果的过渡，对于首页背景图固定的效果，使用 background-attach 来实现 fixed 固定；使用 Swiperjs 来修改样式实现轮播图；存在滚动视差的使用 css 3d 来做

3、使用 wangEditor 来实现富文本编辑的问题，首先就是切换导致 DOM 加载的问题，使用底层的 Slate 来实现聚焦和重写 DOM

4、自己封装了一个简单的 naiveui 的 crud 表格，可以实现绝大部分功能的复用

5、数据大屏地图下钻比较难

6、剩下的就是后台管理部分的代码了

7、还有就是关于脚手架的部分，这部分其实不算很难

> 总结：

# 实习讲解

## 1、富文本 ckeditor5 处理

嗯我来先说一下整个项目的背景，目前实习的企业使用 ckeditor5 富文本编辑器我需要将它原本的功能转为 word 文档的形式

1、第一个就是查看官网是否存在该配置，查看后发现确实没有，

2、想想有没有其他办法，其实是存在一个 i18n 的兼容性处理，但是不是很好，而且不能扩展文本数量，只能使用 5 个

3、在官网看到内部的代码结构，感觉作者之前是写 C#的，内部分了很多层，渲染层就是 view 来做核心控制，感觉可以修改内部源码，所以定位源码，发现确实可以，这里要找到 node_module 来找到源码的位置，然后再定位到 package.json 中的 main 来看导出

4、再使用依次定位源码位置，这里有一个问题就是 vite 其实是有缓存的，你需要删除缓存再去执行才能生效，然后这个时候修改源码发现有效果，但是需要一个能够修改源码的工具，这个时候就需要使用 patch-package 来记录源码变化，同时在程序中配置 postinstall 来执行保证每次都能执行 patch-package 记录的变化

5、但是记录源码其实不是很好，因为这样每次都需要进源码来修改，我这里想到的就是可以修改类上的原型来做修改，这样内部再调用的时候就可以使用变化的函数

6、目前公司的代码是这样的，但是我事后想了一下，其实还是不够，为什么呢？因为目前业务还在增长，还没定型，代码其实不多，如果代码变多，工程复杂的情况，你修改原型会有很多的隐患问题，其他开发者不一定能定位到位置

7、我认为最好的方法就是自己适配官网的代码，你传入配置来定位问题

## 2、由 unplugin-auto-import 引起的体积压缩

1、unplugin-auto-import 原理

[vue 第三方组件按需引入，最后项目的包体积真的变小了吗？前端打包体积的优化，减少打包体积，也算是前端老生常谈的问题了。 - 掘金 (juejin.cn)](https://juejin.cn/post/7144658029328203813#heading-4)

[你真的了解 ElementPlus 的按需导入吗？ElementPlus 是我们在日常业务中经常会接触到的组件库，如果要在 - 掘金 (juejin.cn)](https://juejin.cn/post/7344567644174336035?from=search-suggest)

[vue 第三方组件按需引入，最后项目的包体积真的变小了吗？\_为什么按需引入没有是打包体积减小-CSDN 博客](https://blog.csdn.net/qq_41000974/article/details/126917331)

[element-ui 按需引入包体是全部引入的 3+倍-CSDN 博客](https://blog.csdn.net/lefex/article/details/117004472?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-117004472-blog-126917331.235%5Ev43%5Epc_blog_bottom_relevance_base9&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-117004472-blog-126917331.235%5Ev43%5Epc_blog_bottom_relevance_base9&utm_relevant_index=5)

[🚢 社区探索 - unplugin-vue-components 剖析 - 《All about FE》 - 极客文档 (geekdaxue.co)](https://geekdaxue.co/read/imoxiao@xo4eyk/vv1n80)

[使用 unplugin-vue-components 按需引入组件（内附实现原理） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/613985053)

2、首先是介绍业务场景，需要对原有的项目进行优化，这也是第一次接触到前端工程化的问题，这是一开始的宝体积的大小，大概是 7.43mb
![[00 assets/985515d61d0c0999ac529561ab752dee_MD5.png]]

3、针对包的问题最基础的就是优化静态资源文件，压缩图片、字体等基本的处理方式，上述静态资源优化完之后，再将不要的页面，不使用的包排查一遍，该删的删掉

4、优化到这里其实我的工作已经完成了，但是我在想能不能再多做一点，我想把首次加载的 vendor.js 再压缩一点，所以我使用了 unplugin-auto-import 来代替原本的全局引入，想使用局部引入来减少部分的包体积，然后让首屏加载的 vendor.js 减少一点，但是我引入之后体积变大了从原本的 4mb 变成了 7mb，我要来探究是什么导致了这样的问题？

5、首先是按照公司的项目来搭建一个一个一模一样的开发环境，可是各种尝试之后无果，但是发现 webpack 会将多次使用的包合并到一个大包里面

6、随后我便想到是否是公司项目中存在代码问题，便开始逐步排查，首先减少页面数量，和代码引入数量，再逐步放开来控制变量再来依次排查包体积变大的原因

7、最后发现一个引入出现了问题，那就是 elMessage 组件的引入，他直接引入下面的 lib/component 这里面引入了很多的其他组件
![[00 assets/eb738d2f0f0cabb8d74b0f1c418b1e41_MD5.png]]

8、随后我将各个组件库的违规引入全部治理了一下，此时包体积从 2.27mb -> 1.28mb，首包体积压缩了近 1mb，如果换算，首屏加载至少能快 1s 左右
![[00 assets/81ddad2f4df017a33f3c3332bc46ccc0_MD5.png]]

9、但是优化之后又发现了一个问题，那就是包体积还有近 6.14 mb
![[00 assets/2fd2fb1c241cb193fbb9561bbde29e10_MD5.png]]
但是我发现有很多的小图片进行了额外的打包，而且内部转为了 base64 存储了，而且还是相同的图片
![[00 assets/966662272f5a7c45dd1b5368db084542_MD5.png]]

10、随后进行治理，这些页面大多其实都是一致的，只是部分有区别，我这里封装了一个高阶的组件，来统一管理，针对图片叫 UI 转为精灵图来做修改，减少小图片的请求次数
![[00 assets/e356a0ee59b731d119e94539e066ccbc_MD5.png]]

11、一开始 FCP 是 6.6s，减少了 1s 还不止，虽然最后总体积大了 0.1mb，可以理解因为很多组件都拆分出来了，需要加载部分额外的代码，但是首屏加载的包体积少了近 1mb
![[00 assets/a001ae2d046f1a3cd66febac6ce6b799_MD5.png]]

## 3、针对接口的重复减少

[前端接口防止重复请求实现方案前言 前段时间老板心血来潮，要我们前端组对整个的项目都做一下接口防止重复请求的处理（似乎是有 - 掘金 (juejin.cn)](https://juejin.cn/post/7341840038964363283?searchId=202410122140063ACC0F3A5F6610C3CA50)

1、首先这个需求就是一个伪需求，但是目前公司的代码很多人接手，而且形成了组件套组件的情况，要变成一个无法推倒的屎山了，而且接口也存在很对的重复请求的情况，针对这个背景来做接口部分的优化

如果是该接口重复的问题，和接口缓存的区别，那我们来使用接口缓存呢？很简单，因为接口都是同时发送会占用大量的资源，目前只对这部分进行优化处理，当前的场景是进入页面之后存在 20+重复的接口请求，而且目前的代码的架构是使用微前端为基础模块，然后在给定的模块中编写指定逻辑，形成了组件套组件，页面套页面的情况，难以维护，首先就是需要在这个基础上，尽可能的执行优化操作

2、因为是部分优化，从小到大来做适配，所以需要有一个对应的提示，这里使用 dev 变量来表示是否为开发环境，如果是开发环境就显示哪些页面使用过了，正在逐步适配，但是生产环境就没这些显示，而是 Tree-Sharking 掉

3、功能大致是这样实现的，在请求的时候会在外面套一层 Promise，如果有重复的请求就会返回一样的 Promise，同时为了满足部分的需求，可以在封装一个函数 getApi，你传入地址，参数等，计算哈希在 map 中寻找，这样返回的是同一个 Promise，这么做主要原因是因为可以去做很多额外的市区
![[00 assets/e39d8d8844eac6d897ee5c5913de42ae_MD5.png]]

3、考虑第一个接口挂了的情况：请求错误重新进行进行连接即可，

轮询的情况：添加参数，表示该接口不缓存，也不找缓存，直接返回 axios 的 Promise

![[00 assets/6055f9de2a7bd9c6d15c4ebffd869739_MD5.png]]

TODO: 目前没想到如何去做

维护一个 map，你可以主动去设置，某个哈希执行某个函数，在 axios 的全局响应拦截就可以取出这个哈希去执行

![[00 assets/50c7f38a13473c79e8261c4ee1d13b3d_MD5.png]]

![[00 assets/ee9d916659d788b7b6991a1887965fac_MD5.png]]

3、这个问题也需要解决，第一个想到的就是深拷贝，我这里打算引入 lodash 但是会额外引入包体积，遵循着 “如无必要，勿增实体” 的原则，想想有没有其他的办法来解决

4、后续便参考了 Vue 的做法，对于参数使用函数返回值的形式，对于请求会包在一个函数中，进行函数调用的方式来做

![[00 assets/d36a9caff4c8dca257d3624854ff1490_MD5.png]]

TODO: 了解一下 adapter 层

![[00 assets/72a492519a27a5dc19c7140c28776b26_MD5.png]]

## 4、为什么你一直在强调业务文档

【挖掘真正的学习价值所在【让编程再次伟大#20】】https://www.bilibili.com/video/BV1GAyZYAEwA?vd_source=8992a13080c32977bce93a5140823f3b

我认为技术需求都是为业务需求服务的，很多的代码或者技术需求其实都是有来源的，我认为针对部分的业务需求最好是留下一些文档 know-why，也就是了解为什么再去编写我认为是项目能一直持续下去的核心

## 5、使用原生渲染来降低内存占用

首先来说就是要使用原生渲染的背景，因为用的技术架构是 Electron，而且还是游戏相关的内容，如果在打游戏的时候内存占用很高其实就不行，所以内部有专门的优化内存的关注

1、为什么不使用 Vue 来做渲染，这是因为 使用 Vue 渲染的话会绑定内部很多的响应式数据，而且还是 Map 数据类型，基于哈希也会占用一部分内存，目前房间列表的业务几乎不会再变了，所以要采用原生渲染的方式来降低内存的占用

2、首先就是使用单例模式编写render函数，这个render函数本质就是一个类，然后输出HTML字符串然后使用innerHTML上去，这样只有几个类的内存占用

3、针对每个房间的事件处理，使用事件委托的方式，为每个元素添加标签属性，然后触发在根元素上的事件，标签属性就会在方法组里面寻找触发。有一些方法其实是依赖委托的，再来使用数组做缓存来

4、定时器全局唯一，至少针对房间列表的处理全局唯一，减少函数的压入

5、针对数据的存储，只有方法数据的缓存，以及一个全局的对象，减少之前代码中的深拷贝等操作，基本都编写纯函数，减少内存泄漏的风险，而且最好就是使用全局的对象

6、针对布局中没必要的元素统统删掉，也就是优化布局中的DOM元素，尽可能减少

7、针对DOM采用批量处理，也就是微任务中，尽可能在下次渲染中执行，保留出一个modifyRoomList 方法，这样在后续针对DOM修改会尽量聚集在一起修改，也方便浏览器一起重排重绘，也能适当的提升性能

8、如果有类似拖拽事件的情况，也是使用全局的函数，避免内存地址不一样，导致事件绑定无法消除的情况

9、减少使用 scoped 来减少 css 哈希的处理，这样也能降低打包的体积

> 遗憾

1、但是也存在一部分遗憾就是虚拟列表使用的内部的，每个存在的元素都会留一个根元素，其实这一部分的元素都可以不存在

2、针对防劣化做的不是很好，因为这一套操作下来操作就变成了，修改数据 + 真实DOM的修改，维护成本其实是提升了很多。比如在后续的业务代码迭代中你无法保留比较好的接口给业务侧来使用，特别是针对数据

3、针对防劣化这部分，可以使用 MutationObserver 来做列表元素中的DOM观察，如果是标记的内部的元素被删除的话就去执行删除该元素中方法的操作，这样避免了事件绑定中业务代码编写，其他人忘记取消事件绑定的处理

## 6、figma插件怎么编写

1、我们在 figma dev mode 的时候可以看到对应的 css style
![[00 assets/08edf2ae3ccb1da2d3bb46528fb56437_MD5.png]]

2、这个就是主要的转换
![[00 assets/b2d1033523e98ad5f9420a269f7587a0_MD5.png]]

然后现在有2个变量，一个是已经定义原型名称 -> CSS变量 -> LESS变量 目前做了映射表
![[00 assets/b7a1052b320ce4668f58a3c4e8c8ef46_MD5.png]]
![[00 assets/410679318e4d44701794f98a6eea7e79_MD5.png]]

3、针对 figma 可以使用监听下面的事件
![[00 assets/e8be0090fab3c4963a36863d04ccb210_MD5.png]]
还需要在 manifest 中添加 codegen 
![[00 assets/5b5e7a104d667fe1494f0db87db08dd8_MD5.png]]

4、我们可以监听代码生成事件，再来做处理
![[00 assets/d2b6670335389a4960bda710765cadd5_MD5.png]]
![[00 assets/3d15b430ace188a663082a7b9c8d5e7f_MD5.png]]

5、针对 less 绑定主题的本质 CSS变量 -> LESS变量，修改了CSS变量就行
![[00 assets/e349f9bdeeefa2aa69bc37202c738742_MD5.png]]

## 7、如何封装 v-repeat

1、目前针对数据埋点，其实说是数据报点，用的一个开源的平台 Sentry，但是并没有使用里面的全部功能，但是反映到业务端，只有建立一个字段，比如：event_open_xxx 然后在请求接口的时候传入 event_type，带入 value 即可

2、针对报点的主要是点击、停留、页面访问（PV），针对访问主要使用的 IntersectionObserver API 来监测元素是否进入视口

3、同时要考虑性能优化，滚动节流来上报、防重复上报（记录key的方式）

4、针对 click 就是使用 el 监听就行，然后直接网络请求

5、针对 PV 本质就是如下进行上报
![[00 assets/2843b55cb602ff807b05497193b254c4_MD5.png]]

6、针对停留的本质就是使用 IntersectionObserver 监听元素是否在页面上，然后在进入的时候记录时间，在离开的时候执行回调即可
![[00 assets/f29766cd32cdbed1f49ce3add68c7e62_MD5.png]]

# 真实面经

## 2024.6.6 武汉真内控

### 1、自我介绍 / 你的这些项目都是那里来的

问题：我感觉我自己的自我介绍不算很好

### 2、如何让一个元素水平垂直居中

[[八股记录#^56f71f]]

### 4、var 和 let 的区别

[[八股记录#^736ca1]]

### 5、数组 filter 使用方式

### 6、Promise 的使用

[[ECMAScript#^15cb91]]

### 7、数据算法了解吗？可以说下栈和队列的区别吗？

栈：[[04 数据结构#^8cd345]]

队列：[[04 数据结构#^bdf812]]

### 8、"Come in Hello World" 倒序为 "World Hello in Come"，请使用 JS 一条语句来实现

```javascript
console.log("Come in Hello World".split(" ").reverse().join(" "));
```

### 9、1,2,3,4,5,6 { 7,8,9, { 1,2,3, { 4,5,6 } } }，请将除了最外层的 { } 都转换为 `[ ]`

需要使用栈来实现

### 10、Vue3 和 Vue2 都使用过吧！那么 Vue2 的 mixin 的用法，Vue3 和 Vue2 mixin 类似的方法是那个

[[八股记录#^89b01c]]

### 11、请说一下关于你对 TS 的了解

[[八股记录#^71ef7f]]

### 12、我看你简历提到了关于 AI 的使用，可以说一下你如何去使用 AI 的

### 13、关于正则表达式知道多少，这里就出一个简单的，如何判断一个字符只有字母和数据

![[00 assets/3ab40c170c4174f8392e47c018dded8e_MD5.png]]

### 14、反问

关于我的面试评价如何？（水平很高）

公司主要是做什么的？（内控相关，财务管理之类的）

刚刚您提到了业务中存在表单，请问下有没有抽取配置化（表达了项目中到处都是配置，是否可以思考能不能统一配置呢？）

### 总结

武汉的一家小厂，气氛较好，面试官人也很好。面试官也确实是写代码的，写业务的，问题都更偏向于实际业务，问题也不算很难，八股文偏少，并且针对 AI 的看法也和我很一致，聊了半个小时也很愉快。

## 2024.6.11 武汉微创新

### 1. 笔试

#### 1. null 和 undefined 的区别

#### 2. JS 事件冒泡是什么，如何阻止他

#### 3. js 有几种数据类型

#### 4. 请简述 cookies、sessionStorage、localStorage 的区别

### 2. 面试

#### 1、自我介绍

#### 2、请介绍下用的最多技术栈的项目

#### 3、权限管理了解过吗？RBAC 权限管理，如何做到没有权限不加载对应的代码，菜单和页面呢？

[[八股记录#^25cb6b]]

#### 4、你封装过哪些组件？封装这些组件要考虑哪些东西

[[八股记录#^8f69e9]]

#### 5、组件间数据传递有哪些方式

[[八股记录#^85f217]]

#### 6、如果是 props 传递数据到组件中，但是页面没有渲染是为什么？该如何处理

#### 7、axios 中进行数据请求，存在拦截器，那么请求拦截器中可以修改哪些参数

#### 8、反问：

1、对我有什么评价：技术的宽度没问题，但是关于网络请求这一块要多看看

## 2024.6.11 北大软件

#### 1、自我介绍 / 项目那里来得

#### 2、请介绍一下 弹性布局，以及 justify-content 有哪些参数

[[八股记录#^485760]]

#### 3、请介绍一下 flex: 1

[[八股记录#^fed75c]]

#### 4、那么 flex: 1 和 flex: auto 是一致的吗

[[八股记录#^284df6]]

#### 5、子元素设置 padding-top 设置为 100% 是基于父元素得什么来做得

[[八股记录#^d116f9]]

#### 6、3 个正方形盒子水平排布在页面中，随着页面来变化

[[八股记录#^d116f9]]

#### 7、.a > .b && .a .b && .a.b && .a,.b 选择器组都指代得什么

[[八股记录#^8f7e14]]

#### 8、rem em vw vh 这些 css 单位各自得区别

[[八股记录#^0d241e]]

#### 9、js 得数据类型有哪些

[[八股记录#^29a1d4]]

#### 10、function、array、object 都是 object 类型，该如何去做区分

[[八股记录#^aac35a]]

#### 11、Promise 如何去使用的？如果 Promise 一直 .then() 得话，会取到是什么值？

[[八股记录#^d09c85]]

#### 12、async await 详细说说？async 和 await 是否需要成对出现？await 除了接异步之外还能接同步吗，比如 await "1"

[[八股记录#^0d4645]]

#### 13、 Promise.all 和 Promise.race 如何使用

#### 14、new 函数本质是做了什么？箭头函数为什么不能 new

[[八股记录#^5649e7]]

#### 15、数组有哪些方法；filter 如何使用；map 和 foreach 得区别；splice 如何使用；sort 如何实现从高按低排序

[[八股记录#^ce187b]]

#### 16、防抖和节流知道吗

[[八股记录#^efa147]]

#### 17、vue2 得 data 为什么不使用对象，而是函数

[[八股记录#^f3899e]]

#### 18、vue2 得 mixins 如何使用，mixins 有哪些问题 Vue3 得 composiabel 函数如何使用

会存在变量和函数覆盖的问题，如果 mixins 相互调用也存在问题

#### 19、v-model 绑定在组件上原理，以及你是这么看待 v-modal 直接绑定在组件上

[[八股记录#^01ae46]]

#### 20. vue2 和 vue3 的 watch 区别

[[八股记录#^70e4aa]]

#### 20、父子组件生命周期加载顺序。如果是两个子组件呢？两个子组件是并行吗？执行的顺序怎么样？

[[八股记录#^15a3c3]]

#### 22、vue router 有路由守卫，有哪些路由守卫，这些路由守卫一般是做什么得

[[八股记录#^2f10a2]]

#### 23、如何使用 ts 为一个类型做扩展/修改一个类型

[[八股记录#^8ef933]]

#### 24、一个函数第一个参数是一个对象，第二个参数只能是对象中得 key，使用 ts 该怎么写

[[八股记录#^c86640]]

## 2024.6.12 杭州积客

### 1、自我介绍 / 你是如何去学习前端的

### 2、你微信小程序分包是如何去做的

[[八股记录#^6b54fd]]

### 3、数据大屏中图表如何去做封装

三层，baseEcharts、lineEcharts、正常使用

### 4、Uniapp 中 微信小程序、app 端、h5 端分别有哪些区别

[[八股记录#^c74cf0]]

### 5、你使用过哪些组件库

### 6、介绍一下你全栈项目中的接口如何去设计，登录如何去做

## 2024.6.13 武汉绿盟科技

### 1、自我介绍

### 2、第一个项目中微信小程序减包和分包如何做的

[[八股记录#^6b54fd]]

### 3、git 使用过吗，有多人协同合作吗？你知道哪些 git 的指令

![[00 assets/e5c18612c8cb387cc1b40303bb4765e7_MD5.png]]

### 4、如果这个时候有一个新的需求，要在你的业务基础上开发，但是不能破坏你原有业务，有什么好的办法吗

创建一个分支，在分支上开发

### 5、ts 之前学过吗？

### 6、img 标签中有哪些标签，分别的作用是什么

[[八股记录#^1b31bb]]

### 7、src 和 href 有什么区别

[[八股记录#^95be53]]

### 8、行内元素和块级元素的区别

[[八股记录#^122020]]

### 9、如何为行内元素设置宽高

[[八股记录#^d05fcf]]

### 7、ES6 中有哪些新特性

[[八股记录#^3408ad]]

### 8、如何理解 JS 原型

### 9、如何理解继承，该如何实现

### 10、如何理解作用域链

### 11、简单介绍一下箭头函数

### 12、如何判断一个对象相等

### 13、typeof 和 instanceof 的区别

### 14、如何去判断一个数组

### 15、vue diff 算法 请介绍一下

### 16、v-if 和 v-show 的区别

### 17、v-for 中 v-key 有什么用

### 18、vuex 如何使用，如何去做持久化存储

### 19、vue 的生命周期介绍一下

### 20、http 和 https 的区别

### 21、http 的请求状态码有哪些

### 22、你知道哪些网络安全的攻击手段

## 2024.10.17 滴滴

### 1、一面

#### 1.1 个人介绍

#### 1.2 请说一下 h5 的 hybird 技术了解吗

#### 1.3 请问下 rpx 和 px 的区别

#### 1.4 微信小程序的生命周期说一下

#### 1.5 请问下 rem 和 vw vh 的区别

#### 1.6 请问下你项目中针对微信小程序的分包和组件裁剪如何做的（感觉要细查一下，问的频次非常高）

#### 1.7 请问下项目中针对包体积优化怎么做的

#### 1.8 请问下 border-box 和 content-box 有什么区别 / 你比较常用那一个

#### 1.9 请介绍一下 flex 布局以及它对应的属性

#### 1.10 请简单介绍一下防抖和节流，手写一下防抖或者节流

#### 1.11 看代码说输出（var 作用域问题、闭包作用域、事件循环问题）

#### 1.12 手写下深拷贝

### 2、二面

#### 2.1 请说一下浏览器输入 url 的过程

#### 2.2 请问下针对于页面静态资源是如何处理的（css 和 js 都算），静态资源的引入是同步还是异步

#### 2.3 针对于框架打包出来的代码，他是怎么处理依赖包的引入问题的

#### 2.4 那么 script 放在那里是最好的

#### 2.5 请问下 HTTP1 和 HTTP2 的区别有哪些

#### 2.6 请介绍下 Vue 生命周期钩子都做了什么（感觉问的是源码里面，Vue 在各个阶段做了什么）

#### 2.7 请说一下 Vue 的响应式依赖究竟做了什么，以及 Vue 是如何去做依赖收集的

#### 2.8 请说一下你系统中的权限管理中，关于 路由加载是怎么做的，路由懒加载是怎么做的，抛开 API 层面来说，说下底层原理如何实现的

#### 2.9 当你输入 npm run dev 到你进入网址调试的整个过程，是怎么做的

#### 2.10 请说一下目前前端环境中，类似 webpack / vite 为什么不可或缺

#### 2.11 请手写下代码，并发请求

#### 2.12 请说一下 Vue Router 中得路由模式，并说一下这两种模式的区别

# 面试待读

## 2024.4.6 日常实习面经

原文链接：[2024 届前端日常实习面经（一） - 掘金 (juejin.cn)](https://juejin.cn/post/7223742591372607548)

> 那我们开始聊一些技术相关的吧，你可以讲一下事件循环机制吗？

事件循环是 js 和 浏览器 / node 调用的一个桥梁，他们通过回调函数的形式来沟通，同时事件循环机制保证 js 可以使用非阻塞的方式执行

> 那浏览器的事件循环机制和 Node 的事件循环机制的区别，你有了解过吗？

1、运行环境不同，浏览器缓存中大部分都是 DOM，网络请求等，而 Nodejs 是 IO、网络请求等

2、对于 Nodejs 的宏任务有优先级区分，分为 timer、io、闲置阶段（preparse）、poll、check、close

3、微任务也有优先级的区分，`process.nextTick` 在微任务的优先级更高，随后才是 Promise 的 then 回调

> Vue 的 nextTick 实现原理

^e1d791

参考链接：[nextTick 实现原理，必拿下! - 掘金 (juejin.cn)](https://juejin.cn/post/7087866362785169416) | [一次弄懂 Vue2 和 Vue3 的 nextTick 实现原理 - 掘金 (juejin.cn)](https://juejin.cn/post/7021688091513454622)

1、nextTick 等待下一次 DOM 更新刷新的工具方法，我大部分都是在获取 DOM 状态的时候使用

2、我们更新数据之后，会触发 watcher 更新，后面会有一个 nextTick 的 flushSchedulerQueue 加入到队列中，flushSchedulerQueue 会排序，遍历执行等一系列操作，如果使用的 Vue2，首先需要做微任务和宏任务的判断，有 Promise、MutationObserver 的微任务，随后就是 setImmediate、setTimeout 的宏任务，如果使用 nextTick 的话，会将回调放入 callbacks 队列中，调用 timerFunc 即可执行

> Vue 如何收集依赖？

参考链接：[深入解析 Vue 依赖收集原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/45081605)

```javascript
class Observer {
  constructor(fn) {
    this.update = fn;
  }
}

class ObserverList {
  constructor() {
    this.observers = [];
  }

  add(observer) {
    this.observers.push(observer);
  }

  remove(observer) {
    this.observers.splice(this.indexOf(observer), 1);
  }

  indexOf(observer) {
    return this.observers.indexOf(observer);
  }
}

class Observerd {
  constructor() {
    this.observers = new ObserverList();
  }

  addObserver(observer) {
    this.observers.add(observer);
  }

  removeObserver(observer) {
    this.observers.remove(observer);
  }

  notify(context) {
    this.observers.observers.forEach((item) => item.update(context));
  }
}

const observer1 = new Observer((context) => {
  console.log("observer1:", context);
});
const observer2 = new Observer((context) => {
  console.log("observer2:", context);
});

const observerd = new Observerd();
observerd.addObserver(observer1);
observerd.addObserver(observer2);

observerd.removeObserver(observer1);

observerd.notify("我要修改了");
```

Vue3 的话使用 Proxy 的 getter 来收集依赖，只要收集依赖的数据发生改变了，setter 就会执行，并且内部维护了一个观察者模式的列表，数据改变就会执行 notify 函数

> 什么情况下 z-index 会失效？

1、完全没有设置 position

2、设置了 transition 和 will-change 创建了复合图层

> 防止 XSS 攻击有用到什么库吗？

XSS 本质是注入的代码和正式版的代码混在一起；如果要防止的话我会使用 js-xss 库来实现

> 你是计科专业的，那数据结构和算法有了解吗？

1、链表

2、树：

3、图：

> 图有几种？

有向图 无向图

> 如何判断链表是否有环

遍历打标记，遍历时遇到已打过的标记就是有环

## 2024.4.8

> 项目中的登录如何实现，以及 JWT 的使用

1、人大的登录不是我做的，但是我知道他在 Header Bearer，也就是 JWT，但是七夕诗墙的登录是我做的，他就是使用的 JWT 技术

2、JWT 是分为 3 个部分，header 保存着加密的信息，payload 是具体存储的数据，verify signature 是 header、payload 和 salt 加密之后生成的

3、一般情况下是登录之后后端发送 token 给你，后期你发送请求在 Header 里面带上即可，后端解密信息，返回对应的数据

4、虽然 JWT 解决了 CSRF、跨域和分布式的问题，但是存在解密性能问题，安全性问题，无法让 JWT 失效

> 说一下原型链，可以用原型链来做什么，使用原型链的优点和缺点

参考文章：[彻底理解：JavaScript 原型和原型链 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/146922194)

1、JS 中每个对象都存在一个特殊的属性，也就是原型，这个原型指向另外一个对象

2、每一个对象，都有一个原型对象与之关联，这个原型对象它也是一个普通对象，这个普通对象也有自己的原型对象，这样层层递进，就形成了一个链条，这个链条就是原型链。

3、通过原型链可以实现 JS 的继承，把父类的原型对象赋值给子类的原型，这样子类实例就可以访问父类原型上的方法了。

4、如果想使用原型来实现继承的话，使用下面的方式

5、优点：父类的方法得到了复用。

6、缺点：子类实例共享属性，造成实例间的属性会相互影响

```javascript
function Person(area) {
  this.area = area;
}
Person.prototype.sayHello = function () {
  console.log("hello~");
};

function Boy(name, age) {
  this.name = name;
  this.age = age;
}

Boy.prototype = new Person("中国");

// 还有很多的继承方式，建议后续再查
```

> 你觉得数组中有哪些方法比较复杂，哪些方法不会改变原数组

reduce 因为他是函数式编程的核心，他能做很多的功能，比如：管道函数；

concat、join、slice、indexOf 等

> 给你两个数组，怎么求交集，你实现的这个时间复杂度是多少

参考我数据结构的代码即可 “349.两个数组的交集”

> 正则表达式匹配五个数字

![[00 assets/e0589afa8400dd2e084b7c37da0d1201_MD5.png]]

> 怎么用 1s 时间将一个元素从左上角滑到右下角

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        padding: 0;
      }

      .box {
        width: 200px;
        height: 200px;
        background-color: rebeccapurple;

        animation-delay: 1000ms;
        animation: move 1000ms ease;
      }

      @keyframes move {
        to {
          transform: translate(calc(100vw - 200px), calc(100vh - 200px));
        }
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
  </body>
</html>
```

[CSS3 动画那么强，requestAnimationFrame 还有毛线用？ « 张鑫旭-鑫空间-鑫生活 (zhangxinxu.com)](https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-动画算法/)

参考链接：[全面理解 requestAnimationFrame - 掘金 (juejin.cn)](https://juejin.cn/post/7202785660666495037)

顺便封装了一个`useAnimationFrame`的`hook`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Element Slide</title>
    <style>
      #element {
        width: 100px;
        height: 100px;
        background-color: red;
        position: absolute;
        top: 0;
        left: 0;
        transition: transform 1s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div id="element"></div>

    <script>
      const useAnimationFrame = (animationFn, animationTime = 1000) => {
        // 类型检查
        if (typeof animationFn !== "function") {
          throw new TypeError("animationFn must be a function");
        }
        if (!Number.isSafeInteger(animationTime) || animationTime <= 0) {
          throw new RangeError("animationTime must be a positive integer");
        }

        let isFinish = false;

        const start = () => {
          let startTime = null;

          const animation = (currentTime) => {
            if (!startTime) startTime = currentTime;
            const progress = (currentTime - startTime) / animationTime;

            if (!isFinish && progress <= 1) {
              animationFn(progress);
              requestAnimationFrame(animation);
            }
          };

          requestAnimationFrame(animation);
        };

        const stop = () => {
          isFinish = true;
        };

        return { start, stop };
      };

      const element = document.getElementById("element");
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const { start, stop } = useAnimationFrame((progress) => {
        const x = (windowWidth - 100) * progress;
        const y = (windowHeight - 100) * progress;

        element.style.transform = `translate(${x}px, ${y}px)`;
      }, 1000);
      start();
    </script>
  </body>
</html>
```

> 怎么用 flex 实现，将一个元素水平居中，垂直方向靠下方，只能用 flex

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        padding: 0;
      }

      .wrapper {
        width: 100vw;
        height: 100vh;
        background-color: pink;

        display: flex;
        justify-content: center;
        align-items: end;
      }

      .inner {
        width: 100px;
        height: 100px;
        background-color: rebeccapurple;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <div class="inner"></div>
    </div>
  </body>
</html>
```

> 了解过画布吗，怎样画一个圆

画布相关的内容查看我的笔记：”前端可视化的内容“

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      canvas {
        width: 300px;
        height: 300px;
        border: 1px solid red;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="300px" height="300px"></canvas>

    <script>
      window.onload = function () {
        const canvasEl = document.querySelector("#canvas");
        const ctx2d = canvasEl.getContext("2d");

        ctx2d.beginPath();
        ctx2d.arc(100, 100, 50, Math.PI * 2, false);
        ctx2d.stroke();
      };
    </script>
  </body>
</html>
```

> 怎样实现用 Promise，一秒钟返回 true

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success");
  }, 1000);
});

promise.then((res, rej) => {
  console.log(res);
});
```

## 2024.4.11

> rpx 什么原理

参考文章：[谈谈像素以及微信小程序的 rpx | BlueSun (huang-jerryc.com)](https://huang-jerryc.com/2017/05/21/talk-about-pixel-and-rpx/)

他可以理解为默认所有设备都是 750 rpx

首先我们从底层往上看，iphone 6 plus 的物理像素是 1920 _ 1080 而逻辑像素是 736 _ 414 我们可以知道 iphone6 plus 的 dpr 是 2.6

而 736 _ 414 是 px 为单位，一个网页其实有很多的设备，也就是存在 667 _ 375 这样设计网页的时候就有大小不一的情况

这个时候微信小程序又抽取了一层，不管什么设备都是 750rpx

如果拿 iphone6 plus 举例子 那他们之间的换算比就是 1080 物理像素 = 414px = 750rpx ，2.6dpr = 1px = 1.81rpx

这样微信小程序从宽度来讲就是自动适配的

![[00 assets/f548800f2f47c946f7b7674e38cddabd_MD5.png]]

如果你想写 网页 的话，有没有类似微信小程序的解决方案？？？？其实可以使用 rem 来替代

参考文章：[less - 如何根据设计图给定基准 fontSize？ - SegmentFault 思否](https://segmentfault.com/q/1010000019940104)

可以参考下面的 js 代码，这样你就可以使用基准宽度来设置全局的宽度了，这样不管什么设备都是 750rem 为全屏

但是使用这样的方式会导致全局的 fontSize 被改变了

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      .box {
        width: 750rem;
        height: 100px;
        background-color: rebeccapurple;
      }
    </style>
  </head>
  <body>
    <div class="box"></div>

    <script>
      const baseWidth = 750; // 设置基准宽度为 750 那么就是 750rem = 750rpx = 设备逻辑像素px
      const deviceWidth = document.documentElement.clientWidth; // 设备宽度
      document.documentElement.style.fontSize = deviceWidth / baseWidth + "px";
    </script>
  </body>
</html>
```

> 通过递归深拷贝；如果循环嵌套怎么办，比如对象 a 里有属性是对象 b，对象 b 又有属性是对象 a

参考文章：[彻底理解并实现深拷贝(循环引用) - 掘金 (juejin.cn)](https://juejin.cn/post/6916511620537532424)

1、首先是如何进行深拷贝

​ 1.1 undefined、任意的函数以及 symbol 值，在序列化过程中会被**忽略**（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如 JSON.stringify(function(){}) 或者 JSON.stringify(undefined)，这是因为 JSON 是网络传输的格式，其他语言不一定有这些类型，所以转化的时候都会删除

​ 1.2 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。对于有循环引用的对象来说，它的嵌套层级是无限深的，所以序列化的时候会进入**死循环**或者**死递归**。

```javascript
const p1 = {
  name: "zjh",
};

const p2 = {
  name: "lyh",
  relation: p1,
};

// p1.relation = p2;

const p3 = JSON.parse(JSON.stringify(p2));

console.log(p3);
```

```javascript
const isObject = (value) =>
  (value && typeof value === "object") || typeof value === "function";

const deepClone = (data) => {
  // Symbol / 对象属性描述符
  const allDesc = Object.getOwnPropertyDescriptors(data);
  const obj = Object.create(Object.getPrototypeOf(data), allDesc);

  const keys = Reflect.ownKeys(data);
  keys.forEach((key) => {
    const value = obj[key];
    obj[key] = isObject(value) ? deepClone(value) : value;
  });

  return obj;
};
```

参考文章：[JavaScript 深拷贝看这篇就行了！（实现完美的 ES6+版本）\_javascript 深拷贝-CSDN 博客](https://blog.csdn.net/cc18868876837/article/details/114918262)

如果想解决依赖循环的话，就要使用下面的方式，使用 WeakMap 来记录 Object 类型，如果依赖直接返回，避免无限递归

```javascript
const p1 = {
  name: "zjh",
  area: {
    provide: "湖北省",
  },
  arr: [
    1,
    2,
    3,
    4,
    {
      name: "zjh",
      age: 15,
      friends: {
        name: "ls",
      },
    },
  ],
  err: null,
};

const p2 = {
  name: "lyh",
  relation: p1,
};

const deepClone = (obj) => {
  const map = new WeakMap();

  const isObject = (value) => value !== null && typeof value === "object";

  const copy = (obj) => {
    const linkBox = Array.isArray(obj) ? [] : {};

    if (map.has(obj)) return map.get(obj);
    map.set(obj, obj);

    for (const item in obj) {
      const value = obj[item];
      linkBox[item] = isObject(item) ? deepClone(value) : value;
    }

    return linkBox;
  };

  return copy(obj);
};

p1.relation = p2;
console.log(deepClone(p1));

```

当然我们还可以写的更加完美

[JavaScript 深拷贝看这篇就行了！（实现完美的 ES6+版本）\_javascript 深拷贝-CSDN 博客](https://blog.csdn.net/cc18868876837/article/details/114918262)

```javascript
const deepClone = (obj) => {
  const map = new WeakMap();

  const isObject = (value) =>
    (typeof value === "object" && value) || typeof value === "function";

  const copy = (data) => {
    // Base
    if (!isObject(data)) {
      return data;
    }

    // Date / Regexp
    if ([Date, RegExp].includes(data.constructor)) {
      return new data.constructor(data);
    }

    // Function
    if (typeof data === "function") {
      return new Function("return " + data)();
    }

    // Map
    if (data instanceof Map) {
      const result = new Map();
      map.set(data, result);
      data.forEach((item, key) => {
        isObject(item) ? result.set(key, copy(item)) : result.set(key, item);
      });
      return result;
    }

    // Set
    if (data instanceof Set) {
      const result = new Set();
      map.set(data, result);
      data.forEach((item) => {
        isObject(item) ? result.add(copy(item)) : result.add(item);
      });
      return result;
    }

    // Array
    if (data instanceof Array) {
      const arr = [];
      data.forEach((item) => {
        isObject(item) ? arr.push(copy(item)) : arr.push(item);
      });
      return arr;
    }

    // Symbol / 对象属性描述符
    const allDesc = Object.getOwnPropertyDescriptors(data);
    const result = Object.create(Object.getPrototypeOf(data), allDesc);

    // 解除闭包依赖
    const exist = map.get(data);
    if (exist) return exist;
    map.set(data, result);

    const keys = Reflect.ownKeys(data);
    keys.forEach((key) => {
      const value = data[key];
      result[key] = isObject(value) ? copy(value) : value;
    });

    return result;
  };

  return copy(obj);
};

const obj = {
  // =========== 1.基础数据类型 ===========
  num: 0, // number
  str: "", // string
  bool: true, // boolean
  unf: undefined, // undefined
  nul: null, // null
  sym: Symbol("sym"), // symbol
  bign: BigInt(1n), // bigint

  // =========== 2.Object类型 ===========
  // 普通对象
  obj: {
    name: "我是一个对象",
    id: 1,
  },
  // 数组
  arr: [0, 1, 2],
  // 函数
  func: function () {
    console.log("我是一个函数");
  },
  // 日期
  date: new Date(0),
  // 正则
  reg: new RegExp("/我是一个正则/ig"),
  // Map
  map: new Map().set("mapKey", 1),
  // Set
  set: new Set().add("set"),
  // =========== 3.其他 ===========
  [Symbol("1")]: 1, // Symbol作为key
};

// 4.添加不可枚举属性
Object.defineProperty(obj, "innumerable", {
  enumerable: false,
  value: "不可枚举属性",
});

// 5.设置原型对象
Object.setPrototypeOf(obj, {
  proto: "proto",
});

// 6.设置loop成循环引用的属性
obj.loop = obj;

const copy_obj = deepClone(obj);

console.log(copy_obj);
```

```javascript
function deepClone(target) {
  const map = new WeakMap();

  const isObject = (target) =>
    (typeof target === "object" && target) || typeof target === "function";

  function clone(data) {
    // 处理 基础类型
    if (!isObject(data)) {
      return data;
    }

    // 处理 Date、RegExp
    // 使用 Date 和 RegExp 的构造函数来创建，
    if ([Date, RegExp].includes(data.constructor)) {
      return new data.constructor(data);
    }

    // 处理 Function
    /*
      1、不能使用 call bind 等方式来调用，这样会导致函数上下文环境丢失
      2、使用下面的方式会导致无法使用 fn :function() {  } 来创建函数
      3、下面的本质其实是 new Function(return function() { ... }) 这时会返回一个return function() { ... } 函数，
         再去执行的话就是就是返回该函数，所以根据引用会找到上下文
    */
    if (typeof data === "function") {
      return new Function("return " + data.toString())();
    }

    // 处理 Map
    /*
      Map 也存在循环依赖 比如该 Map 中存在另外一个对象，该对象中的 Map 引入的该 Map
      如果通过这个方式来解决 Map 的依赖，Set 同理
    */
    // 使用 instanceof 可以检测到 Array / Map / Set，这些类型使用 typeof 只能是 Object
    if (data instanceof Map) {
      const result = new Map();
      map.set(data, result);
      data.forEach((val, key) => {
        isObject(val) ? result.set(key, clone(val)) : result.set(key, val);
      });
      return result;
    }

    // 处理 Set
    if (data instanceof Set) {
      const result = new Set();
      map.set(data, result);
      data.forEach((val) => {
        isObject(val) ? result.add(clone(val)) : result.add(val);
      });
      return result;
    }

    // 处理 Array
    if (Array.isArray(data)) {
      let arr = [];
      data.forEach((item) => {
        isObject(item) ? arr.push(clone(item)) : arr.push(item);
      });
      return arr;
    }

    // 处理 Symbol / 对象描述符
    // Object.create 第一个参数就是传入对象的原型，使用 getProtoTypeof 可以使用原型创建
    const allDesc = Object.getOwnPropertyDescriptors(data);
    const result = Object.create(Object.getPrototypeOf(data), allDesc);

    // 处理 循环依赖
    // 本质是阻止无限递归，如果 Map 中存在就返回，那么浏览器/Nodejs会检测到依赖循环，自动做处理
    const exist = map.get(data);
    if (exist) return exist;
    console.log(data);
    map.set(data, result);

    const keys = Reflect.ownKeys(data);
    keys.forEach((key) => {
      const val = data[key];
      result[key] = isObject(val) ? clone(val) : val;
    });

    return result;
  }

  return clone(target);
}

const obj = {
  // =========== 1.基础数据类型 ===========
  num: 0, // number
  str: "", // string
  bool: true, // boolean
  unf: undefined, // undefined
  nul: null, // null
  sym: Symbol("sym"), // symbol
  bign: BigInt(1n), // bigint

  // =========== 2.Object类型 ===========
  // 普通对象
  obj: {
    name: "我是一个对象",
    id: 1,
  },
  // 数组
  arr: [0, 1, 2],
  // 函数
  func: function () {
    console.log("我是一个函数");
  },
  // 日期
  date: new Date(0),
  // 正则
  reg: new RegExp("/我是一个正则/ig"),
  // Map
  map: new Map().set("mapKey", 1),
  // Set
  set: new Set().add("set"),
  // =========== 3.其他 ===========
  [Symbol("1")]: 1, // Symbol作为key
};

// 4.添加不可枚举属性
Object.defineProperty(obj, "innumerable", {
  enumerable: false,
  value: "不可枚举属性",
});

// 5.设置原型对象
Object.setPrototypeOf(obj, {
  proto: "proto",
});

// 6.设置loop成循环引用的属性
obj.loop = obj;

const copy_obj = deepClone(obj);
console.log(copy_obj);
```

> 重排除了用 css 动画还有什么方式

重排（Reflow）是浏览器在渲染页面时，由于某个元素的大小、位置或其他属性发生变化，导致需要重新计算页面布局的过程。除了使用 CSS 动画之外，还可以通过以下几种方式触发重排：

1. **直接修改元素的样式**：通过 JavaScript 直接修改元素的宽度、高度、边距、内边距、字体大小等属性，这些变化都会触发浏览器的重排。
2. **添加或删除元素**：在 DOM 树中添加或删除元素时，浏览器需要重新计算页面布局，以适应新的元素结构。
3. **改变元素的可见性**：通过修改元素的`display`、`visibility`或`opacity`属性来改变元素的可见性，这也可能触发重排。
4. **窗口大小变化**：当浏览器窗口大小发生变化时，页面布局也会相应调整，从而触发重排。
5. **读取某些属性**：有些属性的读取操作也会导致浏览器触发重排，比如`offsetTop`、`offsetLeft`、`offsetWidth`、`offsetHeight`等。

> ES6 新特性，数组

ES6（ECMAScript 2015）为 JavaScript 带来了许多新特性，其中数组方面也有一些重要的改进和新增功能。以下是 ES6 中数组相关的一些新特性：

1. **扩展运算符（Spread Operator）**：扩展运算符可以将数组（或类似数组的对象）的元素展开成一系列参数。它通常用于函数调用、数组构造和复制，以及与其他数组或对象的合并。例如：

```javascript
function fn(x, y, z) {
  console.log(x, y, z);
}
var arr = [1, 2, 3];
fn(...arr); // 调用fn函数，传入arr的参数
```

此外，扩展运算符还可以用于复制数组、合并数组、解构赋值以及用于字符串等场景。

2. **解构赋值（Destructuring Assignment）**：解构赋值允许从数组或对象中提取值，并按一定模式将其赋值给变量。对于数组，可以按照顺序提取元素；对于对象，可以按照属性名提取值。例如：

```javascript
const arr = [1, 2, 3];
const [a, b, c] = arr;
console.log(a, b, c); // 输出 1 2 3
```

解构赋值在函数参数、交换变量值、从函数返回多个值等场景中非常有用。

3. **Array.prototype.includes()**：`includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果需要，则返回 `true` 或 `false`。与 `indexOf()` 不同的是，`includes()` 使用严格相等（`===`）进行比较。 4. **Array.prototype.find() 和 Array.prototype.findIndex()**：这两个方法用于在数组中查找满足提供的测试函数的第一个元素的值或索引。`find()` 返回找到的元素值，而 `findIndex()` 返回找到的元素的索引。如果数组中没有任何元素满足提供的测试函数，则返回 `undefined`。 5. **Array.from()**：`Array.from()` 方法从一个类似数组或可迭代的对象创建一个新的数组实例。 6. **Array.of()**：`Array.of()` 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。

> keep-alive 组件，以及原理如何实现

文章参考：[彻底揭秘 keep-alive 原理 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903837770203144)

> 如何封装一个组件

[面试官：说说你对 keep-alive 的理解是什么？ | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/vue/keepalive.html#%E4%B8%80%E3%80%81keep-alive-%E6%98%AF%E4%BB%80%E4%B9%88)

> Vue2 与 Vue3 对比

## 2024.6.11 北大软件武汉面经

^ffe056

参考链接：[北京北大软件工程股份有限公司武汉面经\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/377511419699384320?sourceSSR=search)

> 说说数组有哪些方法

数组常见的操作方法有

1、shift() 删除第一个元素并返回

2、pop() 删除并返回最后一个元素

3、push() 尾部添加元素

4、unshift() 在头部添加元素

5、join() 将数组转化未字符串

6、reverse() 反转数组

> 一个页面放三个盒子，左右宽度固定，中间自适应，怎么完成

解决方案：[布局：三栏布局（7 种方法）-CSDN 博客](https://blog.csdn.net/ganyingxie123456/article/details/77054124)

1、使用 position: absolute + margin 来做处理

2、使用 float + margin 来做处理

3、使用 flex 布局

4、使用 table 布局

![[00 assets/449a6df913e97b79fb7f3b4e5b5b2912_MD5.png]]

5、使用 grid 布局

![[00 assets/3a02ff4d63927c2e27605d3ef91acb70_MD5.png]]

6、圣杯布局

![[00 assets/ee0ecaedc827795ec1a6ff6fd87f4c78_MD5.png]]

7、双飞翼布局

![[00 assets/cea32411e54a289a43d0fe37643695a1_MD5.png]]

> es6 新特性

![[00 assets/4f4b8590e4bf1bb90ce3afe182b1644f_MD5.png]]

> vue 生命周期

![[00 assets/56af3bb7d2915f2ec0ad04700f8d7ce9_MD5.png]]
![[00 assets/cb84fc2bfdd583be4e55e4130fcf1467_MD5.png]]
![[00 assets/2e18644a25be715945e9e15fd3f9cbf2_MD5.png]]

当然使用 keep-alive 会多出 deactivated 和 activated 来表示被激活时执行

![[00 assets/b5cfd6cd4c24b8fed7bfa4e39c41b7c1_MD5.png]]

> 数据变化了而页面没渲染出来遇到过嘛

[Vue 数据更新页面却没有更新的几种情况以及解决方法-CSDN 博客](https://blog.csdn.net/jyf_568/article/details/134182625?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-134182625-blog-133255250.235^v43^pc_blog_bottom_relevance_base9&spm=1001.2101.3001.4242.1&utm_relevant_index=3)

> 说说 nextTick

[[实习学习#^e1d791]]

![[00 assets/cb719361a6a87d6b38d8874b724f8542_MD5.png]]

> 说说组件间通信方式

![[00 assets/fc51c1055e8138137e39d3d49fcfd997_MD5.png]]

> 为什么 data 是一个函数而不是对象

![[00 assets/62bb9a956db5583485ae9f3b7675777a_MD5.png]]

> 箭头函数和普通函数区别

## 2024.6.12 绿盟科技武汉面经

> 数组中查找元素的时间复杂度

具体看数据结构：

线性搜索：O(n)、二分搜索：O(log n)、哈希表：O(1)

> 从数组头部弹出一个元素的时间复杂度是多少？

具体看数据结构：

数组：O(n) 因为头部弹出要将数据左移、栈：O(1)、链表：O(1)

> 说一下作用域和作用域链

[面试官：说说你对作用域链的理解 | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/JavaScript/scope.html#%E4%B8%80%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F)

作用域：变量和函数可以生效的区域，作用域决定了代码区块中变量和其他资源的可见性，同时也包含了全局作用域、函数作用域、块级作用域

作用域链：就是一层层楼，依次向上寻找

![[00 assets/4dc413ffd24a1272e42d7d93fa7ce12d_MD5.png]]

![[00 assets/81fb5277ccfc1eacf2c69718815d9767_MD5.png]]

> 做过登录模块吗，简单说一下

> cookie、后端怎么传 cookie

cookie 是客户端维护的小段信息，session 是服务器端维护的小段信息

![[00 assets/230c9b0e9dea1bcc91a1bffe73810ca0_MD5.png]]

![[00 assets/3aaffb4e8f070647bb397e883bf4e28f_MD5.png]]

> 项目中的一些亮点难点，讲一讲印象深刻的项目

> 了解 HTTP 吗，具体说一说 AES 是对称加密还是非对称加密

HTTP 状态码

![[00 assets/cd43d0f5a480c495cac0b550594b79bc_MD5.png]]

对称加密：DES、AES

非对称加密：RSA、ECC

![[00 assets/d45e91a49dd37c423b8f08b74ca1fceb_MD5.png]]

> 敏感信息加密过程 、后端怎么知道这是敏感信息

![[00 assets/fbe3e933b44433be169b6d1fed66e64a_MD5.png]]

> 然后聊了下 Token（太熟了）

token 主要用在登录鉴权方面，**header** 部分保存当前的加密算法，**payload** 部分是具体存储的数据，**verify signature** 部分是把 header 和 payload 还有 salt 做一次加密之后生成的

私钥加密，公钥解密

> 那我问点 JS 基础吧，set 和 map 有啥区别，哪个查找效能高？数组中找一个元素，有几种方法？

![[00 assets/9004cad360e0aef492beb8672cd34fad_MD5.png]]

![[00 assets/5d03597a795e6a83ccfd197d5a87b0ce_MD5.png]]

> 水平垂直居中

## 6

一面：
\1. vue2、3 的区别
构建上的区别
性能上的区别
响应式区别细节
\2. vue3 相应 vue2 不好的地方，什么时候不能用 vue3，兼容性问题
\3. 祖孙组件通信
\4. vuex 的了解
\5. 项目中路由守卫解决 vuex 数据存储问题
\6. hash 模式和 history 模式的区别
\7. 构建工具
\8. webpack 和 vite 的区别
\9. 有配置过 webpack 配置的
\10. 跨域问题
\11. 发上线后如何解决跨域问题，以及部署问题
\12. 地址栏输入 URL 的过程
\13. Token+本地存储处理登录问题
\14. 其他保持登录态的方法
\15. 聊到了 cookie，cookie 的常见属性
\16. sessionStorage 和 localStroage 的区别
\17. 实习项目中封装了组件
\18. 如何在 scoped 中修改样式，scoped 的原理
\19. 预处理器，less 和 css 的区别，有没有用 less 的特性去实现一些复杂的 css
可以聊到主题切换，没料到
\20. 自适应手机页面怎么做
\21. rem 怎么做，其他实现等比缩放的方案（vw、vh）
\22. 隐藏元素的方法
\23. v-if 和 v-show 的区别
\24. vue 生命周期
\25. `深拷贝和浅拷贝的区别，ES6 浏览器 API 实现深拷贝的方法
\26. ？？和？.和三元运算符
\27. 事件循环输出题
\28. async 和 awiat 的理解
\29. 数组去重，filter 方法如何去重
\30. 拍平问题，没写出来，换了一题，递归，不难，面试结束后一下就想出来了
\31. 千分分割数

二面：

\1. 项目中 Token+session 登录，为什么用 sessionstorage
\2. 登录态保持一个月的方法
\3. cookie 安全问题-XSS 攻击，面试官想听 httponly 这个属性
\4. 实现防抖节流，中间穿插箭头函数 this，闭包，定时器是谁的方法
\5. 后台管理系统权限控制问题
\6. get 请求缓存在哪里
\7. 项目中路由守卫解决的相关问题，优化方法
\8. 分页器
\9. 假设点击分页器的第二页之前后台插入了一个排序很靠前的商品，那么用户看到的第二页的第一个商品是之前重复的，如何解决这个问题
\10. 什么时候接触前端
\11. 职业规划

作者：夏静华
链接：https://www.nowcoder.com/?
来源：牛客网

## 7

1、js 有几种数据类型？有什么判断数据类型的方法？
2、原型、原型链、继承怎么理解的？
3、js 的作用域有几种，怎么理解？let 和 const，var 的理解，写一个题
（for (var i = 0; i &lt; 5; i++) { setTimeout(() =&gt; console.log(i), 0) }
for (let i = 0; i &lt; 5; i++) { setTimeout(() =&gt; console.log(i), 0) }
打印结果是什么、为什么？
结果是 5 个 5 和 12345）
4、你知道那些 ES6 新的特性？举例子说一下？promise、Generator、async/await 它们之间的关系
5、浏览器的事件循环
6、写题，打印结果是什么:(1 4 5 3 6 2 7)
console.log('1');
setTimeout(() => {
console.log('2');
}, 0)
Promise.resolve().then((a) = >{
console.log('3');
})
new Promise((resolve) => {
console.log('4');
resolve()
console.log('5')
}).then(() =&gt; {
console.log('6');
})
new Promise((resolve) => {
setTimeout(() = > {
resolve();
}, 100)
}).then(() = > {
console.log('7');
})
7、写题：多重数组扁平化
8、css 有哪些布局？说一下 flex 布局和属性；说一下定位属性 position
9、说一下对 BFC 的理解
10、数据机构，二叉树的中序遍历？栈和队列的区别是？
11、写题，手动实现数组的 filter 和 reduce 方法
12、浏览器的存储

作者：在喝茶的垂耳兔很慢热
链接：https://www.nowcoder.com/?
来源：牛客网

## 8

1.自我介绍 2.项目介绍 3.登录鉴权 token 4.性能优化 预加载懒加载（答的不是很好）
5.http 和 https 的区别
6.CSS3 中的盒模型 7.跨域处理是如何实现的，同源策略哪三个同源 8.深拷贝和浅拷贝 9.强缓存与协商缓存（差异居然没说出来） 10.反问：技术栈主要是 vue2，少部分 vue3，uniapp 也有用。要出勤，jquery 很少用了，后面等 hr 通知。

作者：行不行阿细 GO
链接：[https://www.nowcoder.com/interview/center?entranceType=%E5%AF%BC%E8%88%AA%E6%A0%8F](https://www.nowcoder.com/interview/center?entranceType=导航栏)
来源：牛客网

https://www.nowcoder.com/feed/main/detail/6f167eaf3819433a91e988bfe607cfae?sourceSSR=search

[京东前端一面，还挺基础的 🌝 - 小红书 (xiaohongshu.com)](https://www.xiaohongshu.com/explore/66080ea5000000001b00f631)

https://www.nowcoder.com/share/jump/485685855253044212

[海康威视 前端一面+二面\_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/ade7c10bc02e4819b063918786f860cd)

[美团前端一面凉凉夜色为你思念成河 - 小红书 (xiaohongshu.com)](https://www.xiaohongshu.com/explore/66136231000000001a012c39?app_platform=android&app_version=8.24.5&author_share=1&ignoreEngage=true&share_from_user_hidden=true&type=normal&xhsshare=CopyLink&shareRedId=N0s0OEk4NUE2NzUyOTgwNjY0OTc5OTpC&apptime=1712608785)

https://www.nowcoder.com/share/jump/485685855483296184

[网易前端面试（灵犀部门） - 掘金 (juejin.cn)](https://juejin.cn/post/7087435520993099783#heading-17)

[成都某 985 大二学生前端面试实录，基础很强，强过诸多两年经验，期待一个实习 - 掘金 (juejin.cn)](https://juejin.cn/post/7100915693574422541)
[微医 2024 年校招职位信息-牛客网 (nowcoder.com)](https://www.nowcoder.com/enterprise/1854/discussion)

[某小厂前端面经\_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/7cb8e6c046af4e9282ac187a1e47e68e?sourceSSR=search)

[绿盟科技 前端 日常实习面经\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/629251011705626624?sourceSSR=search)

[20230829 绿盟科技前端面经\_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/1982dce80d7b47a693fa716fec050f75?sourceSSR=users)

https://www.nowcoder.com/feed/main/detail/0174ae538a7c4f3b8a247ffd42daf494

[滴滴前端实习\_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/23a2eabfe3b444e4a91e4018ab6d9f7a)

[腾讯云智前端实习一面\_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/0a54b8cdd1c0456c9952d8f0df3f47ae)

[【25 实习】阿里淘天前端面经\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/619611211214176256)

[美团到家前端实习一面\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/627249541951090688)

[小红书前端一面（68min 挂）\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/622536550903017472)

[古茗前端日常实习一面\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/620970975424729088)

[2023 年一位大三学生的一些中大厂的面试题分享（包含干货分享） - 掘金 (juejin.cn)](https://juejin.cn/post/7219097755737636901#heading-12)

[[面经] 5 年前端 - 历时 1 个月收获 7 个 offer🔥 - 掘金 (juejin.cn)](https://juejin.cn/post/7142690757722243102#heading-2)

[2023 我的前端面试准备 - 掘金 (juejin.cn)](https://juejin.cn/post/7244709476517822501#heading-4)

[【1 月最新】前端 100 问：能搞懂 80% 的请把简历给我 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903885488783374#heading-102)

[牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决\_牛客网 (nowcoder.com)](https://www.nowcoder.com/)
https://www.nowcoder.com/creation/circle/152

[有赞前端实习一面面经\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/353157865047269376)

[画一个圆\_ - 个人主页动态 - 牛客网 (nowcoder.com)](https://www.nowcoder.com/users/352510973)

[【面试复盘】腾讯云智前端暑期实习面经（二面挂）\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/353159650856083456)

[腾讯云智前端实习面（已 oc）\_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/4b5dcdd08a774695bf07efdd42aa0d68?sourceSSR=search)

https://www.nowcoder.com/feed/main/detail/f589972612c4460ca248bf5fd4de331a

[作业帮前端实习一面*笔经面经*牛客网 (nowcoder.com)](https://ac.nowcoder.com/discuss/654547?type=2&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack)

[作业帮前端一面二面面经\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/353156465009565696)

[木仓科技面试\_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/f83f7ca31eb34609afb30a79a0501210?sourceSSR=search)

[中科星图前端实习面经(oc)\_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/581442450464460800)

https://www.nowcoder.com/share/jump/1725935580214

https://www.nowcoder.com/share/jump/1725935704120

https://www.nowcoder.com/share/jump/1725935842591

https://www.nowcoder.com/share/jump/1725935902182

https://www.nowcoder.com/share/jump/1725936546027

https://www.nowcoder.com/share/jump/1725936629874

https://www.nowcoder.com/share/jump/1725951571055

https://www.nowcoder.com/share/jump/1725951754476

# 其他感悟

## webworker 博客校招

https://www.xiaoyuzhoufm.com/episode/6626864fc3e09d8f37c3bde3?s=eyJ1IjoiNjQzYThmNTVlZGNlNjcxMDRhNDliYzNmIn0%3D

1、校友资源，可以去领英，脉脉等找一下
2、2026 年 3 月春招
3、面评可以留很久，衡量好你自己的水平，找一下自己水平偏下一点点
4、拒接实习 offer 不会又影响，只要不鸽别人就行
5、实习面试的时候可以找面试官问下，反问你觉得我这个人如何；去问下公司的业务，了解下工业界如何去使用
6、越早实习越好，实习会提升你的见识，而且是你的背书
7、面试经验越多，你就更自如一点
8、实习并不是学技术，钱从哪里来，钱到那里去，这个业务提供了什么价值，长期的竞争力是对业务的理解
9、学习大佬的工作模式，找大佬问下，前端未来怎么看，思考部门的运作，绩效怎么打
10、实习是个什么工作状态：学东西、转正
11、7-8 月份 会开启提前批，发少量的 offer，而且是意向书，8-9 月份是正式秋招
12、秋招之前必须一直处于面试的阶段
13、拿到 offer 之后不是就确定了，而是多拿，也存在毁 offer 的情况
14、不要贸然冲刺大厂，如果你是小厂就面中厂，中厂都觉得你不错，就去面大厂，面试中查漏补缺
15、大公司招聘公众号也可以看看，外企也可以看看
16、同学通知挺重要的
17、看学校政策，签三方，意向书会有违约金
18、如果该部门是盈利业务，可以优先考虑，因为公司会给部门绩效，不么再给下面的员工
19、可以春招上岸，春招短平快，而且春招不会要求你写论文
20、异步面试回报车票，要提前问
21、等了几天没进度，可以提前问下
22、慢慢练，找能力范围内最好的就行了

## 其他感悟

简历上有开源项目：待定：ckeditor5 关于 font-size 得处理，考虑 i18n

搭建一个自己得组件库开源

个人网站模板找好一点得

找个大厂得实习

每天 1-2 道算法题


# 经验

## 1、2025.3.19 面试

1、因为晚上熬夜，导致第二天得面试效果其实非常差，只发挥了30%，其实问题整体非常简单，如果第二天有面试，最晚12点就要上床睡觉，绝对不拖延

2、也暴露出了对于简历上得部分内容其实是准备得不完整得，需要去做对应得处理

3、在询问之前得实习经历得时候最好能说明白其中得缘由，以及在公司中扮演得角色