# 1、HTML/CSS

## 1.1 SEO 是什么？为什么重要？怎么去做？

![[00 assets/33cffbcbdd06b97bae1cebddf6ad29ab_MD5.png]]

![[00 assets/edbaf8aa11c32df73251790e1a0bbc66_MD5.png]]

![[00 assets/3c4bfbe047fecd4f2dfee741d5a4faa4_MD5.png]]

### 1.1.1 TDK

1、针对 TDK 这项来说，其实网易云音乐就写了很多 meta 标签，其实这些就是百度、搜狐、谷歌 SEO 平台的优化，具体操作可以看下述链接：[网站百度等搜索引擎站点验证指南*网站相关*百度智能门户-AIPage (baidu.com)](https://aipage.baidu.com/article-detail-faq/W4zRmDoB)

2、除了关于 SEO 的部分解释，其实还有 og 协议 的使用方式，该协议主要是用于分享时使用 [javascript - 前端应该知道的：开放图谱协议（The Open Graph protocol） - 前端渔人码头 - SegmentFault 思否](https://segmentfault.com/a/1190000040863000)

![[00 assets/46fba9e85f5b5442ac08e35f3375b6ba_MD5.png]]

### 1.1.2 语义化标签

其实可以在网页写 H1 标签，然后移动到视图外

![[00 assets/842cb27a3d21c0621834e1c04b2019fb_MD5.png]]

### 1.1.3 robots.txt

![[00 assets/25efac7072322b5ea1b79c6980efcd5e_MD5.png]]

![[00 assets/c5013ee086672125819c333834cd33b1_MD5.png]]

## 1.2 script 中的 defer 和 async 分别有什么区别

[javascript - 拒绝 js 阻塞—defer、async 作用和区别分析 - 贝贝的前端 - SegmentFault 思否](https://segmentfault.com/a/1190000017257370)

![[00 assets/45639e926a430c28bea5d5f124beae38_MD5.png]]

1、DOMContentLoaded 回调执行在 defer 执行完成之后才执行

![[00 assets/f3372c6ebcf65e4f325f46507124e54d_MD5.png]]

2、defer 的 script 执行是有顺序的，如果按照下面的顺序摆放就是 demo.js、demo1.js、demo2.js

3、并且这些 script 最好放在 head 里面，因为这样就不用解析下面的 body 就会优先下载 script；你放在 body 里面，那不是先把 DOM 解析完了再去下载内容

![[00 assets/9dda5a41c5563946f197cd1262c8d749_MD5.png]]

4、async 和 defer 本质的区别就是不可控，只要下载完就执行

![[00 assets/dd61fcb17417e589ca9ffec30f62e1c3_MD5.png]]

## 1.3 CSS3 有哪些新特性

![[00 assets/4399ad59f354db76ab8f05c0e11b919a_MD5.png]]

## 1.4 物理像素、逻辑像素、CSS 像素、像素密度、DPR、PPI、DPI

![[00 assets/0a509e480a840f2e09f8281a1b37d798_MD5.png]]

![[00 assets/2e1690ac189a20dd6faec135f3e54dad_MD5.png]]

![[00 assets/ab9e5a50308d564e7c0b3c2fb46cf985_MD5.png]]

![[00 assets/ecd06e0b7e63e7b702b3973e9d05805a_MD5.png]]

## 1.5 @2x 和@3x 图像的作用

1、存在这些图片的本质就是为了适配不同分辨率的设备

![[00 assets/301bd3f62677b6142e62b08a265955b1_MD5.png]]

2、使用媒体查询查看设备的 dpr 来来设置不同的图片，这样可以保证良好的体验

3、但是下述的属性 -min-device-pixel-ratio 其实不算是标准属性，不推荐使用

![[00 assets/412f2038d9c7bd9dc83f4885813d4ab7_MD5.png]]

4、当然比较推荐使用 resolution 来解决

![[00 assets/1a5c4c68d6095c251c616486dce6eeb5_MD5.png]]

## 1.6 什么是 1px 问题，如何去解决，如何画出 0.5px 边框

![[00 assets/8e078a0ebc9c7e07f883e3848e823a0f_MD5.png]]

1、也就是设置 border 为 1px，transform 的 scale 设置为 0.5

2、因为设置了 scale 为 0.5，那么宽度和高度都设置为 200%

![[00 assets/28dc31cb137871ad295b7cc34e70ed5e_MD5.png]]

## 1.7 BFC 理解和作用，如何解决折叠问题，如何解决高度塌陷问题

![[00 assets/af2ce7a5f13a3fd3c6ff40ca9aa3f683_MD5.png]]
![[00 assets/89890d265662238527da3f10e6adf2ad_MD5.png]]
![[00 assets/01895bb7b3e3f2ffa5ed386e00f3e03d_MD5.png]]
![[00 assets/2632fbefb1b15dd4a154feb5fa27d34c_MD5.png]]

### 1.7.1 解决折叠问题

1、如何去解决折叠问题，其实是要理解其中的本质

![[00 assets/d297128c2631372277439a85af9bb157_MD5.png]]

2、我们按照下面的方式来编写对应的代码，其实你写 margin 会存在 折叠问题（手动脑补 margin，上面那个是 margin-bottom 为 100px，下面为 margin-top 为 50px）因为在同一个 BFC HTMl 标签下，所以存在折叠问题

![[00 assets/1596e682bb64f4a8de4a0cbde854f849_MD5.png]]

3、其实下面就可以解决对应的折叠问题，其实本质就是因为 box2 在 html 的 bfc 中，而 box1 在 container 的 bfc 中，所以不存在 margin 折叠问题

![[00 assets/93504d8ff232165dc87203d8994b0a56_MD5.png]]

### 1.7.2 解决高度塌陷问题

1、情况一：item 设置为 float，container 的 overflow 设置为 auto，这样就能解决 BFC 问题，这是因为此时 container 创建了一个 BFC，而在 BFC 内部计算高度的时候，flaot 会额外计算浮动元素下边缘的高度，所以可以直接解决

2、情况二：如果 item 为 absolute 的话，那么在 BFC 中会被直接忽略，所以此时父元素是没有高度的，那么就塌陷了

3、以上情况都是基于父元素高度为 auto 的时候，因为这个时候会动态计算

![[00 assets/4d6f76fdde09bd766bbfe5e66b9d2ed1_MD5.png]]

![[00 assets/666cf4fe128409874c0cef308254e86c_MD5.png]]

## 1.8 不同浏览器兼容性问题如何解决

![[00 assets/fff3608abace0dfd03d5a05873a817e8_MD5.png]]

## 1.9 CSS 样式优先级

![[00 assets/042015ff35b0a4e2167685a719e385bc_MD5.png]]

## 1.10 如何让元素水平垂直居中

^56f71f

参考链接：[面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/css/center.html#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)

1、flex 布局（使用会创建一个新的 BFC）

2、定位 + margin-top / margin-left

3、定位 + translateX / translateY

![[00 assets/015c019d3d3186ec1e12338ad94b948c_MD5.png]]

4、定位 + margin: auto

![[00 assets/16d6d1ff2762af772842b99ff57c67f2_MD5.png]]

5、grid 网格布局

![[00 assets/f845b1e38994867945b59ace6cf4f480_MD5.png]]

6、table 布局方式

## 1.11 请介绍一下弹性布局 / 以及 justify-content 有哪些参数 / align-item 和 align-content 区别

^485760

1、flex 布局得元素被称为 flex 容器，那么子元素都是 flex-item，存在 2 个轴，主轴和交叉轴，flex 还有很多其他得属性，比如：justify-content、align-item、align-content、flex-direction、flex-flow

2、justify-content 参数：`flex-start | flex-end | center | space-between | space-around`，如果是比较新得浏览器还存在 start | end

3、针对 align-item 和 align-content 得区别，本质是针对得对象不同，align-item 针对得是每行得元素，而 align-content 就是下面得元素都是一行
![[00 assets/35a256587dc46a28d49f55503e48d99f_MD5.png]]


[align-items 和 align-content 的区别文章目录 1.stackoverflow 上的回答（翻译）2.自己动 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903911690600456)

[[前端]弹性盒子 align-items 与 align-content 的区别 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/87146411)

## 1.12 请介绍一下 flex: 1 / flex: 1 和 flex: auto 是一致的吗

![[00 assets/ed81e6bdf60a90dce870ae95ce2db3d8_MD5.png]]

> 介绍 flex：1

^fed75c

flex：1 其实是 flex-grow、flex-shrink、flex-basic 组成

1、flex-grow 是剩余拉伸长度，如果父元素还有宽度没占满，就会来计算，比如一个父元素剩余宽度为 200px，按照下述得代码就是 200 / 4 = 50px，那么第一个元素多补 50px，第二个多补 50px，第三个就是 100px

![[00 assets/3bfd23edfb8a391db140dd56845bf0b8_MD5.png]]

2、flex-shrink 表示溢出长度，和 flex-grow 相反，它是多得时候计算，flex-shrink 是少得时候计算。比如说溢出 150px，那么就需要算 A 得压缩率也就是 300 \* flex-shrink / 父元素宽度

![[00 assets/559d260800485a1aaaca809e79197e2b_MD5.png]]

3、flex-basic 表示容器得初始值 ，并且最后宽度使用得优先级是 `max-width/min-width > flex-basis > width > box`

![[00 assets/574354bff7796db7191a6a80dc48bdeb_MD5.png]]

> flex：1 和 flex：auto 区别

^284df6

1、很显然是不一致得，主要是 flex-basic 不一致，auto 就是项目得本身得大小，而 0% 就不会考虑项目本身得大小，而是根据剩余空间拉伸

![[00 assets/f3ea365b6333406303e6e0f8b3b0e6c0_MD5.png]]

2、但是在空间一致得时候 flex：1 和 flex：auto 表现得效果一致

3、如果空间不一致得时候，flex：1 会优先压缩空间，保证空间被平分，而 flex：auto 则是保证内部得完整性，挤压其他项目得空间

## 1.14 子元素设置 padding-top 设置为 100% 是基于父元素得什么来做得 / 3 个正方形盒子水平排布在页面中，随着页面来变化

^d116f9

1、padding-top 是基于父元素得宽度来得，这是 W3C 规定得，原因不明

![[00 assets/e66f362d0079be65be05e9b8015fe895_MD5.png]]

2、这里需要借助到上述得 padding-top 得方案来做

![[00 assets/bb43e6353ca6ac8851a391ad9a659610_MD5.png]]

## 1.15 请介绍一下 CSS 的选择器

^8f7e14

1、.a > .b 是 子代选择器

2、.a .b 是 孙代选择器

3、.a + .b 是 兄弟选择器

4、.a ~ .b 是 同辈选择器

5、.a.b 是 交集选择器，两个都有才行

6、.a, .b 是 并集选择器，一个有就行

## 1.16 rem em vw vh 这些 css 单位各自得区别

^0d241e

1、rem 相对于根元素 HTML 上得 font-size 来设置得

2、em 是相对于父元素上得 font-size，当然也可以是自身，其实继承父元素本质是因为父元素得 font-size 继承下来了，其实本质是继承自身

3、vw 和 vh 是针对视口

## 1.17 img 有哪些属性，分别有啥用

^1b31bb

[< img >图像嵌入元素 - HTML（超文本标记语言） | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#%E5%B1%9E%E6%80%A7)

1、alt 定义图像得描述，一般是无障碍使用

2、decoding 为浏览器提供图像解码方式上的提示，sync 同步解码、async 异步解码、auto 浏览器自动选择

3、fetchpriority 表示获取图像得优先级

4、height 表示图像高度，width 表示宽度

5、loading 表示浏览器应该如何加载图像，eager 表示立即加载、lazy 表示延迟加载，视口接近时再去加载该图像，可以优化部分性能场景

6、src 图像得 url

7、srcset 他会根据 dpr 自动匹配图片
![[00 assets/f59b03dfd942eff80db2f1d09aae56ea_MD5.png]]

8、sizes 在不同得视口下动态设置图片大小
![[00 assets/ed2ac964dd9075d0ba3d1fe271165427_MD5.png]]

## 1.18 src 和 href 区别

^95be53

[html - SRC 和 HREF 之间的区别 - Stack Overflow --- html - Difference between SRC and HREF - Stack Overflow](https://stackoverflow.com/questions/3395359/difference-between-src-and-href/21549827#21549827)

[浅谈 src 与 href 的区别 - Tuzilow - 博客园 (cnblogs.com)](https://www.cnblogs.com/xueyubao/p/14748494.html)

1、src 一般都是 js，href 表示 style、图片、视频等

2、除了这个还有一个区别：src 资源都会阻塞页面，而 href 不会去阻塞，而是正常解析页面

## 1.19 行内元素和块级元素的区别

^122020

1、布局表现不同

- **块级元素**：默认会独占一整行，宽度自动扩展到容器的宽度。即使在同一容器内，多个块级元素也会分别换行。
- **行内元素**：不会独占一行，它们排列在同一行内，直到行满或者遇到换行符为止。

2、可以包含的元素类型不同

- **块级元素**：可以包含其他块级元素和行内元素。
- **行内元素**：一般只能包含行内元素，不能包含块级元素（部分元素如 `<a>` 是个例外）。

3、宽度和高度的表现

- **块级元素**：可以手动设置 `width` 和 `height` 属性，并且这些属性会生效。
- **行内元素**：不能手动设置 `width` 和 `height`，宽度和高度通常由内容决定，无法直接改变。

4、边距和填充的表现

- **块级元素**：可以正常应用 `margin` 和 `padding`，且 `margin` 会影响上下和左右的距离。
- **行内元素**：可以应用 `padding` 和 `margin`，但 `margin` 仅影响左右的距离，对上下没有效果（除非转换为块级元素）。

## 1.20 如何为行内元素设置宽高

^d05fcf

1、使用 inline-block

2、给父元素设置 flex ，这样就可以调整内内部得宽高
![[00 assets/0d401f286b7c9cfd957acfb83be13ec3_MD5.png]]

3、或者使用 float 和 position 来让行内元素脱离文档流来实现
![[00 assets/32c266f758f0c6a8bb53dec94f820ced_MD5.png]]

## 1.21 双栏布局/三栏布局

[CSS 布局——两栏布局/三栏布局整理了一下两栏布局和三栏布局的方法，包括一侧固定一侧自适应的各种方法，三栏布局包括弹性布 - 掘金 (juejin.cn)](https://juejin.cn/post/7007054331828502558)

> 双栏布局

1、flex 布局

2、左边 float: left / 右边 margin-left
![[00 assets/1cb243bfa3c410e9efd3aa8d1b8b7691_MD5.png]]

3、左边 float: left 右边 overflow: hidden
![[00 assets/6eae1fb64467b2d0268140923d3f92b0_MD5.png]]

4、绝对定位
![[00 assets/9b366d7ebac82a23c3b6d395bb4fd1f0_MD5.png]]

> 三栏布局

1、flex 布局

2、绝对定位
![[00 assets/21f3e5a98cd00dacc6b825552c555cc6_MD5.png]]

3、浮动
![[00 assets/fbc0b429b358258463f189fbba4c275f_MD5.png]]

4、圣杯布局，本质是将浮动得元素想左偏移 100%，让其向上移动，实现
![[00 assets/20b73a19c1b9c4f673172746f9bde088_MD5.png]]

5、双飞翼布局
![[00 assets/067124ad012deb10b219249580026f15_MD5.png]]

## 1.22 开发中样式单位怎么用得 / 移动端开发样式单位怎么用 / h5 页面适配各个屏幕得手机要如何做，比如折叠屏

1、开发中如果是电脑端得话大多还是 px

2、如果是移动端的话，那就要看你使用什么框架了，如果你使用得 uniapp 得话它本身就是脱胎于小程序，所以也可以参考小程序得思路，他就是基于 750 宽得屏幕，默认 750rpx 就是整个屏幕

[javascript - 谈谈 H5 移动端适配原理 - 熊的猫 - SegmentFault 思否](https://segmentfault.com/a/1190000044155058#item-1)
如果是没使用框架得话，我看我实习的公司使用的 postcss-px-to-viewport 将 px 转为 vw 来做计算；当然你也可以使用 rem 来做适配，

3、针对于折叠屏其实他暴力得解除了屏幕宽度得限制，宽高比，针对这类机器，要额外做适配，简单的方法就是固定一个最宽的宽度，然后居中显示；如果想复杂一点就是使用比如，使用媒体查询来排布，使用 js 监听屏幕的宽度变化，改变元素的排布方式

## 1.23 单行文本超出的部分显示省略号怎么实现 / 如果出现换行的情况怎么办

[前端 - 可能是最全的 “文本溢出截断省略” 方案合集 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000020920000)

1、如果是单行文字，核心的 css 是 display：none / white-space：no-wrap / text-overflow：ellipsis

2、如果是多行文字的话，就有 2 种实现方法了，核心的语法是 -webkit-line-clamp
![[00 assets/6e3f8057867acf471faf51f25e393c7b_MD5.png]]

而另外一种方式使用使用 js 来手动计算得到
![[00 assets/9dd8c1ae88d2df393051cf2e2ccbfbff_MD5.png]]

不仅仅是上述的方法，还有其他的方式，比如使用伪元素 + 定位来实现，这个思路也可以转为使用定位 + transform 的方式也行
![[00 assets/41a84e3d198661da9e25d585e3774c3b_MD5.png]]

## 1.24 请问下 border-box 和 content-box 的区别 / 各自有什么好处

[面试官：说说你对盒子模型的理解? | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/css/box.html#box-sizing)

## 1.25 静态页面是如何处理 css/js 的 / 静态资源引入是同步还是异步 / 针对于框架打包出来的代码，他是怎么处理依赖包的引入问题的 / 那么 script 放在那里是最好的

我们首先来区分 css 和 图片

1、针对于 css，一开始页面加载，也就是浏览器刚接受到页面，遇到 link 或者 script(async 除外) 的话，会阻塞对应页面的加载，内容都下载完毕之后才会进行页面渲染，以及执行 script（默认模式）

style1.css 是延迟 1s 返回，style2.css 是延迟 5s 返回，script.js 是 1s 返回，script 执行会下载 style3.css，它是 5s 返回；根据图片来判断，初始情况 css 未下载完毕，其实页面不会进行渲染，而是等待初始的 css 下载完毕才会渲染，渲染完毕执行 script（默认模式，async 直接就执行了）此时才是异步的，css 下载完毕再改变
![[00 assets/6291fefe762218e76bd002f10eb8de37_MD5.png]]

2、针对于图片，其实是异步的，不会阻塞 DOM 的加载，而是直接渲染，最直观的例子就是你进入页面先加载文字，后续再加载图片，导致页面下移，[html - 图片加载是异步还是同步？ - SegmentFault 思否](https://segmentfault.com/q/1010000015293987)

3、针对于 js 其实也要看情况，如果是默认模式会阻塞页面的加载，等待页面渲染完成后执行；defer 不会阻塞 DOM 的加载，等待 DOM 处理完毕就执行；async 就是异步加载，下载完毕就执行

4、针对于框架打出来的包，可以看看 vite 和 webpack 是如何打包的

webpack 会将懒加载得 script 放置到头部，而将首页加载得页面放置到尾部，首先 prefetch 是指 “指定用户代理应预先获取并缓存目标资源，因为后续的导航可能需要它。”，意思就是闲时加载

[Web 性能优化之 preload 和 prefetch](https://deore.me/posts/preload-and-prefetch)

[页面资源优化之 preload、prefetch 作为一个社会底层的前端打工人，页面优化应该大多都有做过或者了解过，毕竟如果 - 掘金](https://juejin.cn/post/6908344595998998542)

![[00 assets/fd5e0523273e138051ec3771287f86c8_MD5.png]]

我们可以看到 script 被放在了前面，[为什么 vue script 引入放在顶部？](https://coding.m.imooc.com/questiondetail.html?qid=161912) 根据这个网站的解释是因为 Vue 要先执行，注册一些全局的 API

![[00 assets/94c5424a6a4b00b79c669134a0796801_MD5.png]]

![[00 assets/7fea9a308da6f957451ea52b01d0402f_MD5.png]]

针对不同的脚手架有不同的处理方式，因为 Vite 大部分都使用 ESModule，所以异步加载，放在头部也不会影响整体加载
![[00 assets/d05650c037f563e72ec5e123c18440fc_MD5.png]]

![[00 assets/f0b19a0331392fd98d55a9d53e259878_MD5.jpeg]]
![[00 assets/ff1793351e96a0e97662b26cd355ab2f_MD5.png]]

## 1.26 属性的隐藏显示有什么方法？有什么区别？

[面试官：css 中，有哪些方式可以隐藏页面元素？区别? | web 前端面试 - 面试官系列](https://vue3js.cn/interview/css/hide_attributes.html#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F)

## 1.27 将垂直居中的元素位于底部

![[00 assets/77b5add87d7229c047844696b79fc29c_MD5.png]]

## 1.28 请介绍下定位

![[00 assets/f293b4e6bd816ddaa9980a9edba82e93_MD5.png]]

sticky 当你设置了`sticky`定位，就是`relative`和`fixed`的结合。当你设置了`top...`等方向，就是距离该位置阈值，只要超过了这个阈值就会变为`fixed`定位，固定在滚动元素中

sticky：[[02 CSS3#^6d6071]]

## 1.29 css 伪元素实现设置列表偶数项的样式

![[00 assets/6d0dfee2e11c1ad01f72bd6b1a927370_MD5.png]]

## 1.30 img 的可见宽度是多少

【img的可见宽度是多少？【渡一教育】】 https://www.bilibili.com/video/BV1am62YZEVJ/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

100% 指的是包含块，也就是向上找块盒，然后找块盒的内容盒，那么内容盒是width

如下图的案例，img会向上寻找，找到第一个块盒， 因为div是border-box，那么内部的width是470px，那么img是470px

![[00 assets/0ddbb61f1dd50ad4fae94ecc7c7d67f2_MD5.png]]

## 1.31 outline 和 border 的区别

outline 不会导致页面的重排

border 会导致页面重排

## 1.32 script defer/async 和 link prefetch/preload

【资源提示符【渡一教育】】 https://www.bilibili.com/video/BV1TkKHejEcJ/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/86d7bdb9d993c308c38b8e653abc510d_MD5.png]]

![[00 assets/b5d7f964458443ba9011f4af8c5866b5_MD5.png]]

[preload、prefetch、preconnect 和 dns-prefetch 知多少 preload 提升了资源加 - 掘金](https://juejin.cn/post/6915204591730556935)

会预先加载我们用到得资源 prefetch / preload，写在 link 标签得 rel 中，as 是指明请求资源得类型

prefetch 空闲时加载

preload 时立即加载

## 1.33 a 元素的颜色是什么

【a元素的颜色是？【渡一教育】】 https://www.bilibili.com/video/BV1hyA8eKE5A/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/73ec6a5183a7940de3ea11e58c991a00_MD5.png]]
D

![[00 assets/2f5786edd004c263d85d4ee97b86e997_MD5.png]]
C 因为这里是层叠冲突中的优先级，作者样式代理表是高于浏览器的样式表

本质其实就是样式计算，它是有顺序的
![[00 assets/d9736c3517e0a1fd0f5d4871065c33ec_MD5.png]]
这里就是在第一个步骤，因为有声明值
![[00 assets/fadd2734a7c84510ee7cdcfafa105954_MD5.png]]

## 1.34 表单一定要使用 form

1、我们可以将提交给 form 来使用
【表单一定要用 form【渡一教育】】 https://www.bilibili.com/video/BV1mXftY7ER3/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b
![[00 assets/c567ed89d5bb3571f7cac9b4b8a2fa86_MD5.png]]

## 1.35 宽度适应内容

【宽度适应内容【渡一教育】】 https://www.bilibili.com/video/BV1MXr8Y5E66/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/f5b939b08b6c5a70bbbce7a1841ecc34_MD5.jpeg]]

## 1.36 如何保持图片清晰

【如何保持图片清晰度【渡一教育】】 https://www.bilibili.com/video/BV1S5wEeAEr1/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

本质就是 dpr 变化的时候动态的修改 img 的 src

## 1.37 使用 CSS 来画一个三角形

![[00 assets/d0d7b68d127032ef81d4354d9b1dde03_MD5.jpeg]]

## 1.38 rgba 和 opacity 得区别

![[00 assets/8efe72be14b8432c6d8dc074e9d7ec45_MD5.jpeg]]



## 1.39 脱离文档流有哪些方式

![[00 assets/254b436eab418d0380bab827a361bfc0_MD5.jpeg]]


## 1.40 H5如何实现微信小程序原生的振动等操作，说说思路？

![[00 assets/450ba4b645850cdb0659f77cf70d2454_MD5.jpeg]]
![[00 assets/a13c27487cd51f5a13e27ecbb4523ddc_MD5.jpeg]]
![[00 assets/426b64cecab20b256070dc5f372d20b9_MD5.jpeg]]
## 1.41 哪些CSS方案的组合不合理

【哪种css方案组合不合理？【渡一教育】】 https://www.bilibili.com/video/BV1fYXVYGENw/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/ca1d15872e72942ebbde027d3fdabda3_MD5.jpeg]]

postcss 本身不解决类名冲突的问题，他是做CSS转换

css in js 其中一个功能就是解决了类名冲突的问题，所以不合理

## 1.42 移动端如何适配，rem适配的原理

[[移动端如何适配，rem适配的原理]]

# 2、浏览器

## 2.1 浏览器输入一个 URL 的时候发生了什么

针对 Chrome 得地址栏是一个代码为 Omnibox，omni 代表得全能，如果经历过早期互联网会知道，之前得浏览器是存在一个地址栏和搜索栏，而谷歌将2个功能合二为一，如果你输入 chrome://Omnibox 得话会出现类似得菜单，他会解析URL，然后搜索，有直达地址，再就是搜索引擎，还有一些内部得适配，比如本地文件等，还有 javascript:协议，是为了收集调试使用得


【地址栏输入 URL 回车之后发生了什么？【渡一教育】】 https://www.bilibili.com/video/BV11PfHYdE8E/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

[[02 技术扩展#^e5e468]]

![[00 assets/f671b62c709a9246402456037bec3966_MD5.png]]

![[00 assets/836c877b5cab75a3f7fcd7c6bcc9868b_MD5.png]]
![[00 assets/80c1a6b27f947767758417088345a083_MD5.png]]

### 2.1.1 DNS 解析阶段

[[02 技术扩展#^af6e1f]]

![[00 assets/b7f01765d6f79daf9296ed0f40bfbe8e_MD5.png]]
![[00 assets/8133b0cff1ec23e19feb06afe9553453_MD5.png]]

### 2.1.2 TCP 建立连接

关于 HTTP 的三握四挥解释：[阿里面试： HTTP、HTTPS、TCP/IP、三次握手四次挥手过程？（附全网最具深度讲解） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/103000747)

针对 seq 是序列号 ack 是确认号 syn 表示同步标识

为什么连接是三次握手，而挥手却需要四次，这是因为挥手得时候，这个时候服务器可能数据还没传输完毕，所以

![[00 assets/406cdeecb7dc031e8b2ec313785b943d_MD5.png]]

### 2.1.3 HTTP 连接

![[00 assets/cf4afdc9c37868366f96981238f99b0f_MD5.png]]

### 2.1.4 HTTPS 连接

### 2.1.5 gzip 如何解压

[(8 封私信 / 23 条消息) 开启 gzip 如果浏览器端不支持解压 页面会怎么样? - 知乎 (zhihu.com)](https://www.zhihu.com/question/25871199)

### 2.1.5 服务器响应

比如这里使用 nodejs 来做服务器，这个时候可能是 BFF，然后通过 Mysql

### 2.1.6 前端缓存

[[八股记录#^e70cb3]]

前端缓存又分为 2 类，也就是浏览器缓存和 HTTP 缓存，浏览器缓存主要是 localStorage、sessionStorage、cookie

### 2.1.7 浏览器解析阶段

[[02 技术扩展#^e5e468]]

![[00 assets/8008f349deb23e5b4a720992a6cd5451_MD5.png]]
![[00 assets/2acd27629160628c0ef1535d5bd16b43_MD5.png]]
![[00 assets/fdfb4d9fe52851c230c31637cae65f31_MD5.png]]
![[00 assets/84d8c7405e1994aba3e1aef3b905e17c_MD5.png]]

[CSS 对象模型（CSSOM） - Web API | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/CSS_Object_Model)

![[00 assets/5597546dabb4f07256e50e4a85d3f47c_MD5.png]]
![[00 assets/d543c5af90a5302e4ca986cb296f1248_MD5.png]]
![[00 assets/d11c5ebfa7e2c487341844819ac2c386_MD5.png]]

### 2.1.8 回流重绘

![[00 assets/78db443a59c5042878923bbf38c8a5fd_MD5.png]]
![[00 assets/9aefff1361e710b7a04312980526432d_MD5.png]]

### 2.1.9 合成层

![[00 assets/2ed36f84e3f8d894689140e3e39dbdc0_MD5.png]]

![[00 assets/c7d2896454082ed15547c7d1c52f94fd_MD5.png]]

## 2.2 浏览器内核是什么？常见浏览器的内核有哪些

![[00 assets/f7a7ad2d18bb26f7a27f669be74c535f_MD5.png]]

## 2.3 浏览器跨域是什么，如何解决

^5d2d59

![[00 assets/17a4af574e2943c7223670d544ad366f_MD5.png]]
![[00 assets/c463b2f1ac95afdcbfbd5630399e21d5_MD5.png]]
![[00 assets/b84b2135e9dae9769530b4f958cbff26_MD5.png]]
![[00 assets/4799885e1bc1da6605b8e3d2bcf3dd9f_MD5.png]]
![[00 assets/70e9663305868b33f7db159823f0e8d8_MD5.png]]

如何去解决跨域问题

![[00 assets/2754e151de80c167256c10e690ce05b0_MD5.png]]

> CORS

![[00 assets/91f0fc2fa79546eb0df0b5d12d4dcac8_MD5.png]]
![[00 assets/792c66b1a1e5aafc2c50bbb145febb0f_MD5.png]]
![[00 assets/5d5bd00651012082f651ab8d397c9e44_MD5.png]]

> Vite/Webpack 方案 (Node 服务器)

![[00 assets/2fedb7c7708df063c31b034de102dd1d_MD5.png]]
![[00 assets/a530091ed4fecdb3c43af6e153e44df7_MD5.png]]

> Nginx

![[00 assets/32dbecb3365d820f05cb359b488b8fb5_MD5.png]]
![[00 assets/68c65062a428657bb073947ba1f847ed_MD5.png]]

## 2.4 解释正向代理/反向代理

![[00 assets/a598e4eb0248a9dd5b62a5d265d78cfa_MD5.png]]
![[00 assets/8a81c00b3a377f751a64ccfe40c74b97_MD5.png]]

## 2.5 协商缓存/强缓存

^e70cb3

> 参考文章

[浅解强缓存和协商缓存 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903736196726798)

[http 面试必会的：强制缓存和协商缓存 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903838768431118)

推荐：[中高级前端工程师都需要熟悉的技能--前端缓存 - 掘金 (juejin.cn)](https://juejin.cn/post/7127194919235485733#heading-8)

> 总结

1、前端缓存分为强缓存和协商缓存

2、强缓存之前使用的 Expires 字段来实现强缓存，通过对比本机的时间，但是本机时间可能存在异常，就有问题了，而且在后续的 http 更新都废除了；后续缓存由 cache-control 来控制，存在 max-age 表示最多留多少秒

3、协商缓存存在 2 个方式，读取文件的修改时间，然后通过 last-modified 字段来表示修改时间，Cache-control 设置为 no-cache 表示协商缓存，后续请求都携带 If-Modified-Since 和文件修改时间对比，如果相同就返回 304 使用本地缓存，如果不相同就直接返回资源

4、上述使用 last-modified 来实现的，可以使用 Etag 来实现，因为文件可能只加了注释等代码就要重新请求，或者可以使用 Etag 来实现，他是文件指纹，流程和 第三点 一致，使用 Etag 的话，服务器的开销就更大了
![[00 assets/7f77e4c37b429f2652a139e612240cb1_MD5.png]]

5、针对强缓存使用 200，而协商缓存使用 304
![[00 assets/7d365eb1ec96ee296322612b467826e4_MD5.png]]

## 2.6 讲讲浏览器多进程和单线程

[javascript - 从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 - 程序生涯 - SegmentFault 思否](https://segmentfault.com/a/1190000012925872#item-5-7)

进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

浏览器本质是多进程的
![[00 assets/bd22c61a150d37149f670b9b46a233bb_MD5.png]]

随后就是浏览器渲染这一套内容：浏览器进程、渲染进程、GPU 进程

同时 H5 还有 WebWorker，他向主进程申请开启子线程

![[00 assets/e9edf8d6acb25c2cd713554f80715dc6_MD5.png]]

针对事件循环那一套也差不多，可以参考后面的笔记

![[00 assets/f11f632181b80ef379e00efb3ec60f0a_MD5.png]]

## 2.8 讲讲协程

[JavaScript 中的协程 - 知乎](https://zhuanlan.zhihu.com/p/148462034)

[尝试用通俗的方式解释协程 - 知乎](https://zhuanlan.zhihu.com/p/148152129)

![[00 assets/18bb2290b97b84aeebcd39a09b4a5d5d_MD5.png]]

![[00 assets/58cb7294ee226728606fc37737467b73_MD5.png]]

因为 async / await 是 Promise 和 Generate 的语法糖，那么是不是可以说本质 async / await 将函数的执行权出来

## 2.7 浏览器的垃圾回收机制

[[八股记录#^e692a9]]

## 2.8 讲一下一个 url 每个部分代表什么

[一个完整 URL 的各部分分析 - 知乎](https://zhuanlan.zhihu.com/p/64156835)

## 2.9 浏览器脚本执行与事件处理

【一道浏览器脚本执行与事件处理的面试题【渡一教育】】 https://www.bilibili.com/video/BV1cSP8edEtF/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/216fa7038a8bf102c0e4738fc7baa083_MD5.png]]

A 正确
B 是阻止默认行为得
C 下载会有预下载线程，下载不一定是在文档解析之后进行得，但是解析是放在后面得
D 正确

## 2.10 浏览器有哪些进程？

![[00 assets/64635f3e19541471b0e419e6e3382ddd_MD5.jpeg]]
![[00 assets/491681b78ca3dc4464e4596137996b5a_MD5.jpeg]]



# 3、计算机网络

## 3.1 讲讲 MQTT /MQTT 和 WebSocket 异同/为什么物联网要使用 MQTT

### 3.1.1 介绍 MQTT

[MQTT 协议，终于有人讲清楚了 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/421109780)

1、MQTT 是基于发布/订阅模式的通讯协议，该协议是基于 TCP/IP 协议之上的应用层协议

2、MQTT 最大的有点就是用极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务

3、MQTT 使用发布/订阅模式作为核心，它提供了一对多的消息分发机制，

4、不仅如此，他还有服务质量，比如 QoS 0、QoS 1、QoS 2，分别表示“最多一次”、“至少一次”、“只有一次”
![[00 assets/6b016d12ee8101408bcd5b7562a4b885_MD5.png]]
![[00 assets/f274e5795f94b12f3bfd447568825366_MD5.png]]
![[00 assets/89a78d945f26917747be641a078a5d1d_MD5.png]]

5、并且针对 MQTT 数据包结构：

- `固定头（Fixed header）`，存在于所有`MQTT`数据包中，表示数据包类型及数据包的分组类标识；
- `可变头（Variable header）`，存在于部分`MQTT`数据包中，数据包类型决定了可变头是否存在及其具体内容；
- `消息体（Payload）`，存在于部分`MQTT`数据包中，表示客户端收到的具体内容；

6、目前有很多的 MQTT 服务平台，我用的比较多的还是 EMQ 来做 MQTT 服务平台

### 3.1.2 MQTT 和 WebSocket 的异同

[(7 封私信 / 2 条消息) MQTT 和 Websocket 的区别是什么？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/21816631)

#### 3.1.2.1 相同

1、MQTT 和 WebSocket 都是应用层协议

2、目前底层都是使用 TCP 协议确保可靠传输数据

3、都规定了自己的报文（消息）结构

4、都支持双向通信

5、都使用二进制编码（有别于 HTTP 这一类基于文本编码的协议）

#### 3.1.2.2 不同点

**1、通信模型不同**

WebSocket 是一种简单的报文协议，着重解决浏览器和服务端不能进行双向通信的问题。本质上有点像是 TCP 协议之上的 UDP 协议。WebSocket 仅仅定义了会话的发起方式和报文格式及类型。如何使用报文通信全由应用程序（各浏览器）控制。

MQTT 则是一种比较复杂的消息协议。MQTT 不仅规定了具体的协议编码，还规定了客户端和服务器的通信模型。具体来说就是 MQTT 是一种面向主题（topic）的消息广播协议。客户端可以创建、加入和订阅任意主题，并向主题发布消息或者接收广播消息。除此之外，MQTT 还规定了消息的投放级别（QoS），支持至少一次、至多一次和精确投递三种级别，在协议层规定了是否会产生重复投递。

**2、报文结构不同**

**3、会话协商方式不同**

WebSocket 基于 HTTP/1.1 的 Upgrade 机制协商会话
![[00 assets/12205edd65b1da1cd74040c3683179ea_MD5.png]]

MQTT 协议则需要通过 CONNECT 报文协商
![[00 assets/c44a14d611e0bb340a9b27493bd3a782_MD5.png]]

**4、消息收发方式不同**

WebSocket 收发消息不需要对方确认。因为底层的 TCP 协议会完成可靠传输
![[00 assets/fc56b45c0fb22c3369282b1eeb6c1e07_MD5.png]]

MQTT 收发消息需要根据投递级别进行确认
![[00 assets/fafb362895b139488a094890f07c0b8f_MD5.png]]

**5、保活机制不同**

WebSocket 只规定了 ping/pong 两种报文，但并不强制要求定时收发心跳包

MQTT 则有明确的心跳协商机制。协商会话使用的 CONNECT 报文包含 Keep Alive 头部信息，结构如下
![[00 assets/b9cab1ccb902218193a6060c2ff6a4d0_MD5.png]]

### 3.1.3 为什么物联网要使用 MQTT

（1）使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合；

（2）对负载内容屏蔽的消息传输；

（3）使用 TCP/IP 提供网络连接；

（4）有三种消息发布服务质量(QoS)，“至多一次”、“至少一次”、“只有一次”，分别对应于有效值“0”、“1”、“2”，可供不同应用、不同情境下选择；

（5）小型传输，开销很小，协议交换最小化，以降低网络流量；

（6）使用 Last Will 和 Testament 特性通知有关各方客户端异常中断的机制。

## 3.2 http 的请求状态码有哪些

![[00 assets/fc661671a63bc6e5e76ca53978990685_MD5.png]]

![[00 assets/914daeaee0c4e98c1fdbabb8dfd5f97b_MD5.png]]

## 3.3 你知道哪些网络安全的攻击手段

CSRF / XSS：[javascript - 彻底弄懂 XSS 和 CSRF - 前海拾贝 - SegmentFault 思否](https://segmentfault.com/a/1190000023031910)

## 3.4 HTTP1.1 / HTTP2 区别

[一文读懂 HTTP/1HTTP/2HTTP/3 - 知乎](https://zhuanlan.zhihu.com/p/102561034)

（推荐）[面试官：说说 HTTP1.0/1.1/2.0 的区别? | web 前端面试 - 面试官系列](https://vue3js.cn/interview/http/1.0_1.1_2.0.html#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93)

[前端面试必备 | 微信小程序篇（P1-30） - 牛客网](https://www.nowcoder.com/issue/tutorial?zhuanlanId=Mg58Em&uuid=b48bebe08e474db8b80b853b12bafd48#16x6rp)

【http2 有哪些升级【渡一教育】】 https://www.bilibili.com/video/BV1NPfHYoEgc/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

**HTTP1 阶段**：每次传输一个文件都是建立一个请求，传输完毕立即断开，如果想实现长连接需要使用非标准请求头 Connection：keep-alive

**HTTP1.1 阶段**：默认支持了 Connection：keep-alive，允许在在一次 TCP 连接上进行多次 HTTP 请求和响应，减少了建立连接和关闭连接的消耗和延迟；

同时允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间

还引入了引入了更多的缓存控制策略，如 If-Unmodified-Since、If-Match、If-None-Match 等缓存头来控制缓存策略；更多的请求方法：put、delete、options 等

**HTTP2 阶段**：

![[00 assets/c2c9f2b59e3f55c5ac65da9c3176e59c_MD5.png]]

**多路复用**：HTTP2  复用 TCP 连接，在一个连接里，客户端和浏览器都可以**同时**发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”**队头堵塞**（HTTP2 只解决了 HTTP1.1 的队头阻塞，TCP 队头阻塞是 HTTP3 才解决）”，之前 HTTP1.1 是按照请求次序依次返回

**二进制分帧**：帧是 HTTP2 通信中最小单位信息，HTTP2  采用二进制格式传输数据，而非  HTTP 1.x 的文本格式，解析起来更高效将请求和响应数据分割为更小的帧，并且它们采用二进制编码 HTTP2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件

**首部压缩**：HTTP2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送首部表在`HTTP/2`的连接存续期内始终存在，由客户端和服务器共同渐进地更新
![[00 assets/7ba538f17a1a2f626328a6aed3a274e3_MD5.png]]

**服务器推送**：HTTP2 引入服务器推送，允许服务端推送资源给客户端

HTTP2 也存在缺点：

**建立连接存在延时**，它是 TCP + TLS，TCP 连接需要和服务器进行**三次握手**，即消耗完 1.5 个 RTT 之后才能进行数据传输。TLS 连接有两个版本—— TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致需要 1~2 个 RTT。
RTT（Round-Trip Time）: 往返时延。表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。

**队头阻塞没有彻底解决**：TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认。HTTP2 出现丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。
RTO：英文全称是 Retransmission TimeOut，即重传超时时间； RTO 是一个动态值，会根据网络的改变而改变。RTO 是根据给定连接的往返时间 RTT 计算出来的。 接收方返回的 ack 是希望收到的下一组包的序列号。

**多路复用导致服务器压力上涨**：多路复用没有限制同时请求数。请求的平均数量与往常相同，但实际会有许多请求的短暂爆发，导致瞬时 QPS 暴增

**多路复用容易 Timeout**：大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时。

即使是使用 Nginx 这样的负载均衡器，想正确进行节流也可能很棘手。 其次，就算你向应用程序引入或调整排队机制，但一次能处理的连接也是有限的。如果对请求进行排队，还要注意在响应超时后丢弃请求，以避免浪费不必要的资源。[引用](https://link.zhihu.com/?target=https%3A//www.lucidchart.com/techblog/2019/04/10/why-turning-on-http2-was-a-mistake/)

## 3.5 DNS 是怎么查询的？ 迭代查询和递归查询过程？

![[00 assets/40816c144f5be841b30e5cb7270512ed_MD5.png]]

## 3.6 HTTP 和 HTTPS 的区别

![[00 assets/2ab6f18c77abde3b6dd3488955717328_MD5.png]]
![[00 assets/787501bdc5ea49c5b099fb7e2dd21879_MD5.png]]

## 3.7 HTTPS 一定安全吗

![[00 assets/d4dca61bfdd8a8e8c82ca2f7f7e5fe78_MD5.png]]
![[00 assets/2dc0da8ac7c5d433a68b1a3b4217e428_MD5.png]]
![[00 assets/ef95eb556b9e52825ffa4bdb09197314_MD5.png]]

## 3.8 get 和 post 的区别

![[00 assets/e00eae5e97f1a66ce5709028ea423b2d_MD5.png]]

1、一般默认在浏览器中是 get 请求，post 请求会修改服务器上资源的请求

2、get 是将参数包含在 url 中，post 通过 request body 来传递参数

3、post 请求包含更多的请求头

4、post 在接收数据之前会先将请求头发送给服务器确认
![[00 assets/bc58309ba787897a739f3fa51dee1f8e_MD5.png]]

5、get 会将数据缓存起来，而 post 不会

![[00 assets/d6f376e3587abd06bc46803ec71a50a5_MD5.png]]

## 3.9 post 请求中请求体格式有哪些

![[00 assets/fca1f1d67db418e3eff5f24a03684c03_MD5.png]]
![[00 assets/caea731edd4cce9004fa2b5318f7bfb2_MD5.png]]
![[00 assets/f64a52dad1815a701dfd5fe43085a730_MD5.png]]

## 3.10 DNS 解析和优化

【DNS 解析和优化【渡一教育】】 https://www.bilibili.com/video/BV1yhPyeNE8p/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/25e8483166880d02b67c782f3c70e91c_MD5.png]]
可以加上 dns-prefetch 让浏览器提前加载
![[00 assets/856e503a85d28f799faee7be7ea930bb_MD5.png]]
在前端工程化中我们可以写脚手架，或者使用插件来插入进去

## 3.11 TCP一定要三次握手吗？两次行不行 / 挥手一定要是四次吗？

[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1)

>TCP一定是三次握手吗？两次行不行
![[00 assets/29a6e96b4e12a3269c5b5e840caa2432_MD5.jpeg]]
>挥手一定要是四次吗

![[00 assets/750582d0f6da88d4c046f5d653fa26d9_MD5.jpeg]]

![[00 assets/94077da7f0445d9c9210917cb6a2c3c3_MD5.jpeg]]



## 3.12 预检请求是什么？

![[00 assets/301fe31800079d348c453bbff65ec58f_MD5.jpeg]]
![[00 assets/6461a374a9335a43ff437247c8367117_MD5.jpeg]]
![[00 assets/525ba87325299b0de6251014dfe8f7c7_MD5.jpeg]]
![[00 assets/37ef9d81a33852f1943826dabba91e4f_MD5.jpeg]]

## 3.13 讲讲 websocket

![[00 assets/cadd417c8b558ed4c3e47dbfa5963a1c_MD5.jpeg]]
![[00 assets/841186af978c7cb332c77d473678a966_MD5.jpeg]]
![[00 assets/9e0cba6a6500f71302d78f047ebd9b93_MD5.jpeg]]
![[00 assets/f25b2f9dcb45b77000287224984a282a_MD5.jpeg]]
![[00 assets/c17ab9ef1c8ca51ef87f19b1142f93ed_MD5.jpeg]]


## 3.14 TCP有什么特点？和UDP有什么区别

![[00 assets/dc26e6c663d5e902b4dc3e8f945f807f_MD5.jpeg]]
![[00 assets/a7dc59c2ad90311dd364918d90e9557d_MD5.jpeg]]

## 3.15 TCP的重传机制

[4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6)

## 3.16 html渲染过程

[[html渲染过程]]

## 3.17 HTTP中OSI七层模式有哪些

![[00 assets/c2f830c66993a80e4ef072cac50b6d06_MD5.jpeg]]

## 3.18 TCP/IP网络模型有哪些层


![[00 assets/da555df41c704efb02cc01e0a355722a_MD5.jpeg]]

# 4、JavaScript

## 4.1 取数组的第一个元素，ES6 的方法

![[00 assets/6eb1e5007ad7829f6fa02d42c372940e_MD5.png]]
![[00 assets/fc41512d62a9cae21bd15e45066d7a19_MD5.png]]
![[00 assets/927d02e27a4d5792c18e78aceed8468f_MD5.png]]
![[00 assets/46ba49a7c5293faf8174de2a79a837f7_MD5.png]]

## 4.2 除了 innerHeight + scrollHeight >= scrollTop 还有哪些判断元素进入视口的方式

![[00 assets/3064e1c27466b0f0fda135d648f49b6d_MD5.png]]

## 4.3 JavaScript 引擎有哪些/V8、JS 引擎如何执行 JS 代码

> JavaScript 引擎有哪些

1、其中 JavaScriptCore 就被微信小程序作为宿主环境[developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html#渲染层和逻辑层](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html#%E6%B8%B2%E6%9F%93%E5%B1%82%E5%92%8C%E9%80%BB%E8%BE%91%E5%B1%82)

2、除了下述得几个引擎，还有一个 quickjs，最近我看到社区拿这个引擎丢进嵌入式设备来运行，实现 js 跑嵌入式得方法：[quickjs 在嵌入式中的应用 - 无脑仔的小明 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wunaozai/p/17850789.html)

![[00 assets/fdd4909d777394c180d7d842ddb86b85_MD5.png]]

> JavaScript 引擎如何执行 jS

[[04 JavaScript高级#^315c55]]

![[00 assets/0f0d3f452b14cc6e7b34fd1d14bf1401_MD5.png]]

1、如果深入回答 V8 引擎/JS 引擎 可以查看如下文章：[极速优化：十倍提升 JS 代码运行效率的技巧 (qq.com)](https://mp.weixin.qq.com/s/k3O8dkzT6zpoURg_6ny2ZQ)

![[00 assets/e156a4a795319e9cd0959d4ecd71ea53_MD5.png]]

2、下面是针对 V8 引擎 执行 JavaScript 的处理三个模块的解释

![[00 assets/207b0115c4cbd08301149ac1a5c184a7_MD5.png]]
![[00 assets/d3ae93321c5bd73836af91b4787c82a3_MD5.png]]
![[00 assets/43db551066fb5eb88574dacf4fb98d60_MD5.png]]
![[00 assets/d211a929671290491923885cbd57a2d4_MD5.png]]

## 4.4 内存管理/GC/垃圾回收机制

^e692a9

### 4.4.1 基本介绍

> 认识内存管理

![[00 assets/62d1d3a9feaa8440086975a458675119_MD5.png]]

> GC

![[00 assets/09be56953b658161c874aac3d83cbbec_MD5.png]]

### 4.4.2 引用计数
![[00 assets/d9653284b8ed3a1ee97d546a740b53fa_MD5.png]]

### 4.4.3 标记清除

![[00 assets/780e2cd91aef22ece037f1fad521d3e3_MD5.png]]

1、其实本质就是对于 标记清除 算法进行不同程度的优化
![[00 assets/0909a9566843519767ed64a790b38864_MD5.png]]

2、下面就是 V8 内存管理的方式，但是还是存在疑问，比如新生代空间中 Semi space 内部是否存在 和 老生代空间 一样的 old pointer space 和 old data space 的区分，还是说直接就存在 new space 中

![[00 assets/87abe2c0d3a49c50acf17b7dcd474903_MD5.png]]
![[00 assets/350333e79c4c85ce5ba5e266a3c58d59_MD5.png]]
![[00 assets/fd64e65f5ac68876976c1e3a663c01f9_MD5.png]]

### 4.4.5 什么是垃圾回收机制？并且它是如何在现代编程语言中管理内存的？

![[00 assets/bbcaa85a2157d3267e43c4496cb83102_MD5.png]]

### 4.4.6 V8 引擎的垃圾回收机制具体是如何工作的？

![[00 assets/afee838c3059c93d4dfed91797d583b5_MD5.png]]

### 4.4.7 JavaScript 有哪些操作可能引起内存泄漏？如何在开发中避免?(性能优化)

其实针对闭包，不一定都是内存泄漏，主要还是看情况，闭包主要是需要能访问外层作用域，所以外层作用域不能清除
![[00 assets/cb065dfa99d457c3c9c34041dae17a8b_MD5.png]]

### 4.4.8 闭包和内存泄漏

【内存泄漏和闭包【渡一教育】】 https://www.bilibili.com/video/BV1DDfEYoE1F/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

如果是这样写的话，会导致 doms 无法被释放，导致内存无法清除
![[00 assets/ac70b22e1cec4088a3703f8f147829d7_MD5.png]]

## 4.5 var 、 let、const 区别

^736ca1

![[00 assets/595c3284c518d2b1ac86505d0419b015_MD5.png]]

[面试官：说说 var、let、const 之间的区别 | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var)

1、var 声明的变量

    1.1 全局变量（挂载在 window 中）

    1.2 如果在函数中变量是 局部变量

    1.3 并且会进行变量提升

    1.4 多次声明变量，后面的变量会覆盖前面的变量

2、let 声明的变量

    2.1 只在代码块中生效

    2.2 并且不存在变量提升

    2.3 如果没有声明使用的话会报错，会存在“暂时性死区”

    2.4 不能多次声明变量，会报错

3、const 声明的变量

    3.1 声明之后是一个只读的常量

    3.2 和 let 差不多，只是必须初始化

## 4.6 js 数据类型有哪些 / JS 如何判断数据类型

^29a1d4

Number、String、Boolean、Null、Undefined、Object、BigInt、Symbol

针对基础数据类型都可以使用 typeof 来判断，但是 null 需要单独判断，而引用数据类型，Object 直接使用 typeof，Array 使用 Array.isArray() 就行，Function 使用 typeof 就行，Date、RegExp 使用 instanceof 就行

![[00 assets/353c6f0fe9462d99acf3735776ca7583_MD5.png]]

## 4.7 function、array、object 都是 object 类型，该如何去做区分

^aac35a

1、typeof 不能判断 array 类型

2、instanceof 通过构造函数来判断，不能判断函数

3、Array.isArray() 来判断是否是一个数组

4、Object.prototype.toString.call() 来判断几乎所有数据类型

![[00 assets/60a5705bfa84f383fef8cf85bace759b_MD5.png]]

## 4.8 new 函数本质时做了什么？箭头函数为什么不能 new

^5649e7

1、new 函数本质：创建一个新的对象；将函数原型挂载上去；赋值 this；返回创建的对象

![[00 assets/fb44610e3def144f4a74f637c7c1e77b_MD5.png]]

2、因为箭头函数没有 this、没有 prototype、没有 argument 所以也不能创建

## 4.9 数组都有哪些方法

^ce187b

1、数组有下述方法

![[00 assets/4006e29db83fb819e63677562ff53f82_MD5.png]]

2、splice 可以实现对数组的添加、删除、替换

![[00 assets/bf4fd4e9e0c8e6ed6667bc36d182669c_MD5.png]]

3、sort 从高到底排序

![[00 assets/128b75931e6362b816e583fdc3616ad1_MD5.png]]

## 4.10 防抖和节流知道吗？有哪些使用场景 / 手写防抖和节流

^efa147

[JavaScript “防抖”和“节流”详解与应用 - 掘金 (juejin.cn)](https://juejin.cn/post/7072998572362301470)

（推荐）[JavaScript 实现防抖和节流(含参数/返回值/取消功能)常见的工具函数,防抖和节流都有效的减缓了系统的压力, 在很 - 掘金 (juejin.cn)](https://juejin.cn/post/7075890311649558541)

![[00 assets/c443b0c56c3f4347ec0e780d4b0591e6_MD5.png]]

防抖（回城）：每次触发事件时设置一个延迟调用方法，并且取消之前的延迟调用方法。
![[00 assets/f29e73f7f63f740ac9154ef0bc01c687_MD5.png]]

节流（技能 CD）：n 秒内只运行一次，若在 n 秒内被重复触发，只有一次生效。
![[00 assets/34922cc5f23f1568b0ca1823ad752539_MD5.png]]

下面是相对应简略的版本
![[00 assets/445aaf01362902485e06c583363d833c_MD5.png]]

## 4.11 数组去重，那个数组去重的方法最好

[JavaScript 数组去重的方法（12 种方法，史上最全） - 前端开发随笔 - SegmentFault 思否](https://segmentfault.com/a/1190000016418021)

1、使用 Set 来做去重，但是重复对象无法解决
![[00 assets/9689db30db6aaf2728cb33da6421c08e_MD5.png]]

2、双层 for 循环去重，还有其他的去重，比如 indexOf、findIndex、includes 等

3、使用 sort 来去重，但是这种去重会导致数组原有的数据排列改变

4、利用递归来查询

5、使用 map 数据来去重，其实本质也是一样的

![[00 assets/11e310f8f38208ac079e860d66b77084_MD5.png]]

## 4.12 事件循环

[面试官：说说你对事件循环的理解 | web 前端面试 - 面试官系列](https://vue3js.cn/interview/JavaScript/event_loop.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)

[[09 NodeJS#^80c5ef]]

![[00 assets/31f5421eae2b0e6f9e36217b5b8d4650_MD5.png]]

### 4.12.1 浏览器

[setTimeout+Promise+Async 输出顺序？很简单呀！ - 掘金 (juejin.cn)](https://juejin.cn/post/7016298598883131423)

基本按照常规的来做即可，下面这个比较特别

![[00 assets/211cd6138d649c5ecc518fb2c9a4c9c0_MD5.png]]

### 4.12.2 NodeJS

### 4.12.3 执行顺序

^7d1439

右边代码是顶部的代码

> 执行顺序：promise1、2、then1、queueMicrotask1、then3、setTimeout1、then2、then4、setTimeout2

![[00 assets/af42d1eff8bf183f296027e167e5961a_MD5.png]]

> 执行顺序：script start、async1 start、async2、promise1、script end、async1 end、promise2、setTimeout

1、这里的最主要的点就是关于 async1() 函数执行时，async2() 该如何去做

2、因为直接就是函数执行，所以是同步代码，所以直接执行 async2，后面的 async1 end 才是属于微任务里面的

![[00 assets/8d876f3f4966497d2aa4956a73f635de_MD5.png]]

> 执行顺序：0 1 2 3 4 5 6

1、这里的 Promise.resolve() 会推迟 2 次 微任务队列，为什么这么说呢？，因为一开始执行 0 和 1，后面再去执行发现是 Promise.resolve(4)，那么就推迟 2 次，然后这个时候就会执行后面的 2 和 3，再就是 Promise.resolve(4)

![[00 assets/a46b7a4cf6fa523a8d1808afde9d77ae_MD5.jpeg]]

2、为什么会存在这个问题呢？这是因为浏览器实现的时候就有这个问题

3、除了这种情况还有吗？其实还有，那就是返回 thenable 的时候是推迟一次，如果是返回同步的话就是正常入队列

4、如果是上述代码 thenable 的情况，那就是 0 1 2 4 3 5 6

![[00 assets/48af605e0aa3ad35dffd227b35286d12_MD5.png]]

5、如果是同步的话就是如下结果

![[00 assets/9f9d12bd2a822fb25a5bae64f2702023_MD5.png]]

> 执行顺序：script start、async1 start、async2、promise1、promise2、script end、nextTick1、nextTick2、async1 end、promise3、setTimeout0、setImmediate、setTimeout2

![[00 assets/039cb3e106b2f329c9089c41dd66051d_MD5.png]]

> 执行顺序：log-promise、async start、log-end、promise resolve、log-promise1-then 、log-timeout

![[00 assets/d29119f7e1ad9f06b402da767e4d49a0_MD5.png]]

> 执行顺序：1 3 6 4 5 2

![[00 assets/72045b48115602068e85bc591a7b8076_MD5.png]]

> 为什么是这样的执行时机：第一个是 5 2 的原因是因为，先调用了 resolve，只是修改了 Promise，但是回调函数并没有执完成，所以先把 5 放进微队列了，然后再放入 2

第二个则是直接放进宏队列了，此时第一个 Promise 已经完成了，执行 resolve，那么第一个 Promise 进入微队列

![[00 assets/b24646a714109a18608ea133ca955e23_MD5.png]]


## 4.13 ES6 有哪些新特性

^3408ad

let/const、解构赋值、模板字符串、箭头函数、函数参数默认值、剩余参数、Symbol、迭代器、生成器、Promise、Set、Map、class、模块化、Proxy、Reflect

## 4.14 暂时性死区

[ecmascript-6 - ES6 中 let 暂时性死区详解 - 前端拾零 - SegmentFault 思否](https://segmentfault.com/a/1190000015603779)

![[00 assets/021f4b29ed47a2ad4fcd41a7b0e4f5cc_MD5.png]]

## 4.14 函数柯里化如何做

函数柯里化场景：[javascript - 简述几个非常有用的柯里化函数使用场景 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000015281061)

与其说是函数柯里化，不如说是大部分都是基于闭包缓存

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    return function (...nextArgs) {
      return curried.apply(this, args.concat(nextArgs))
    }
  }
}

// 使用示例
const sum = (a, b, c) => a + b + c
const curriedSum = curry(sum)

console.log(curriedSum(1)(2)(3)) // 6
console.log(curriedSum(1, 2)(3)) // 6
console.log(curriedSum(1)(2, 3)) // 6

```
	
## 4.16 原型/原型链

### 4.16.1 基本介绍

![[00 assets/559135c7d9ab3cbec0afa91dfe1154f1_MD5.png]]

![[00 assets/a02a3418a3c0c41816f1d173c9aa2a0e_MD5.png]]

![[00 assets/9fe2d6e6288f7142e7a379bddf874e0f_MD5.png]]

![[00 assets/8d6a1005c811c5b231995e69aaafe610_MD5.png]]

### 4.16.2 函数 prototype

![[00 assets/1ff93050ed8bb8706979afcdc673c4ec_MD5.png]]

![[00 assets/42da4c7598634f1968397084ea0affb3_MD5.png]]

### 4.16.3 原型继承关系

这个其实可以这样记忆，分为 3 个模块也就是 function Foo、function Object、function Function
![[00 assets/ba74ac73f2612ac2e7835c0bc0cc7da0_MD5.png]]

### 4.16.4 输出结果

![[00 assets/831f3db98608b34ff190c288e1f7c5b2_MD5.png]]
true true

### 4.16.5 原型得作用是什么？

![[00 assets/ea8006004494278c795879cb35ad72c6_MD5.png]]

### 4.16.6 原型选择题

【一道JS原型链与继承的面试题【渡一教育】】 https://www.bilibili.com/video/BV1Zp91YAEGH/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/9548ca6a302256246cba72ac1f71015f_MD5.jpeg]]

## 4.17 请简单介绍一下箭头函数和普通函数

【一道 JS 箭头函数的面试题【渡一教育】】 https://www.bilibili.com/video/BV1cSP8edEsY/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/57cdead769ae0f161cf4de1702d03ca8_MD5.png]]

A 正确
B 不能改变 this
C 箭头函数中是严格模式，没有 arguments
D 不确定
E 正确
![[00 assets/c05bc71479ea2a17d2bb9112e1c501e5_MD5.png]]

## 4.18 如何判断对象是否相等

## 4.19 typeof 和 instanceof 的区别 / instanceof 如何实现

[面试官：typeof 与 instanceof 区别 | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/JavaScript/typeof_instanceof.html#%E4%B8%80%E3%80%81typeof)

![[00 assets/fcccb6c2a3a0c16f606b316786ed9019_MD5.png]]

instanceof 主要是查找对象上的原型来实现的，针对 instanceof 本质就是使用 Object.getPrototypeOf 来实现的 判断原型是否在这个对象上面

![[00 assets/b13e0cc61702972bdfb79cbe9d401d0f_MD5.png]]

## 4.20 如何去判断一个数组

1、使用 typeof 肯定是判断不了的，他会返回 object

2、使用 instanceof

3、使用 Object.prototype.toString.call(obj)

4、使用 Array.isAarray()

## 4.21 sort 原理

之前一直都是使用快排来做，在 Chrome 70 之后就变成了 timesort [在 V8 中排序 ·V8 系列 --- Getting things sorted in V8 · V8](https://v8.dev/blog/array-sort)

## 4.22 JS 的运行原理

### 4.22.1 基本介绍

![[00 assets/0eed2ca97b691311c602325f66cdcd99_MD5.png]]

> 初始化全局对象

![[00 assets/a77ac6f476e170d8fc5d6d3925dba6ec_MD5.png]]

> 执行上下文

![[00 assets/145562ae6952422ff37f4e9b3405f68f_MD5.png]]

> VO

![[00 assets/a6b2a074df55f328628675b8fa3fc3d3_MD5.png]]

> 全局代码执行过程 - 之前

![[00 assets/b3a067d269ba3d176d99512c2e0e1513_MD5.png]]

> 全局代码执行过程 - 之后

![[00 assets/206a443707a722442223d1220a8b1380_MD5.png]]

### 4.22.2 函数执行

![[00 assets/53d90b20bc1823fbaa6ca9bbdaa77cf2_MD5.png]]

![[00 assets/e24795708792c27cd6acec74aa5c34e5_MD5.png]]

### 4.22.3 作用域/作用域链

![[00 assets/6a788c81a6fc1a3220f384b272c3611b_MD5.png]]

![[00 assets/2ba04ef2d9ef66e47d9f664d49188054_MD5.png]]

### 4.22.4 复杂代码执行内存图

> 执行到 outer 函数

![[00 assets/5cd5626352f40f77c4ee2289ee74f199_MD5.png]]

> 执行完 outer 函数，并返回 inner 函数

![[00 assets/33316f168b48f9414f55f764ce54ac4d_MD5.png]]

> 执行 inner 函数（作用域访问）

![[00 assets/387f789df712b82a983efb89aeaed05b_MD5.png]]

### 4.22.5 作用域提升面试题

![[00 assets/43524828f24a05c1e4d2171bd2edc939_MD5.png]]

### 4.22.6 新的 ECMA 代码执行改变

1、VO、GO、AO、scope chain 的名称和形式都有所改变
![[00 assets/3186cd3be93819217eb1c6ebaefcf951_MD5.png]]

![[00 assets/22d183eff99211ed8c995b96fbbfc0e8_MD5.png]]

2、在 ES6 之后变成这样的结构
![[00 assets/b92fe8c973edd726efc1b475cb5508e2_MD5.png]]
![[00 assets/767c54a94563550efe487a51e7f6d133_MD5.png]]

![[00 assets/8e9e568a2fea20510665fdb1f87e4538_MD5.png]]

![[00 assets/63d39f49fe7003ec148713127de803eb_MD5.png]]

### 4.22.7 ES2025 代码执行改变

![[00 assets/a8a83a390838b1b7b57909476afb01b7_MD5.png]]

![[00 assets/2cc30c5b42f04791542842751c54d386_MD5.png]]

![[00 assets/9eba124d7663dc69541e19d2f1485fc8_MD5.png]]

![[00 assets/e3b92123d5c681c94559b18fb775804a_MD5.png]]

## 4.23 new Function() 和 eval() 的区别

## 4.24 闭包

### 4.24.1 基本介绍

【什么是闭包？是否会造成内存泄漏？【渡一教育】】https://www.bilibili.com/video/BV1aTcdezEXs?vd_source=8992a13080c32977bce93a5140823f3b

本质也就是函数 + 词法环境
![[00 assets/0b087bf3277aff545984de177b353715_MD5.png]]

![[00 assets/64899e194c6a82cc8791e1c04fc65f2f_MD5.png]]

![[00 assets/38755e6f6946c4f20e767782dba116b7_MD5.png]]

### 4.24.2 内存泄漏

![[00 assets/8e9feebe74b1774d11957f01a519df24_MD5.png]]

![[00 assets/1f015c85b604db8b254d930aec6eb5cd_MD5.png]]

![[00 assets/374f91d38fdc993e5c23e56cb0d5b343_MD5.png]]

## 4.25 请解释一下什么是变量提升？为什么 JS 会存在变量提升机制

![[00 assets/e451650e2c4649f86d66bfa863f50689_MD5.png]]

## 4.26 变量提升机制有哪些潜在的缺点？它可能导致哪些具体问题？

![[00 assets/5b752c1660844ed5b9e72ccf9ed5665e_MD5.png]]

## 4.27 如何定义作用域？请举例说明不同类型的作用域

![[00 assets/8bc5c82d4f32d78b435133dec95bf76a_MD5.png]]

## 4.28 请解释什么是作用域链及其在 JS 中的作用

![[00 assets/80fc81b2a4b147ab1b4f5884cebf6a4e_MD5.png]]

## 4.29 闭包是什么？分享闭包的理解，以及它在 JS 中的用途

[面试官：说说你对闭包的理解？闭包使用场景 | web 前端面试 - 面试官系列](https://vue3js.cn/interview/JavaScript/closure.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)

![[00 assets/ba19807d05d16875c53a0ec5321a9d01_MD5.png]]

## 4.30 能够详细说明说明是执行上下文？它是如何影响 JS 代码的执行

![[00 assets/90a16bf49979c14403960ccdc76c7e33_MD5.png]]

## 4.31 JS 代码的执行过程是怎么样的

![[00 assets/4b621a5a80a80e260db9f959fb9bced0_MD5.png]]

## 4.32 JS 中产生的 AO、GO、VO、LE、VE、ER 都是什么对象

![[00 assets/677d2ef9ce9994c8336a369600a4f5aa_MD5.png]]

## 4.33 请解释 JS 中的原型概念以及原型链是什么？

![[00 assets/1ddbf69a2efd4b3f53dafbeede52446c_MD5.png]]

## 4.34 为什么 JS 需要存在原型和原型链，它的目的是什么？

![[00 assets/d1fa0dbc7362438af5fddde03f0fbbdb_MD5.png]]

## 4.35 原型链的终点是什么，如何打印出对象的原型链的终点

![[00 assets/2934b0df666ec698ef66a272c1012bb2_MD5.png]]

## 4.36 this 绑定

### 4.36.1 基本介绍

![[00 assets/cf1381dd493815708c5c2ba1d9d3b51d_MD5.png]]

### 4.36.2 绑定规则

![[00 assets/a55f091cf597019b65e23d0ac79bcd0c_MD5.png]]
![[00 assets/36edec4f16bc9b2e8bee4f6f29d4e6f1_MD5.png]]

### 4.36.3 绑定优先级

![[00 assets/3440004387a04fb6eafd0b98efd10a70_MD5.png]]

如果要回答的话，其实还有一个就是 class 中的 super，它的优先级是高于显式绑定，这是一个特殊的 this 绑定

![[00 assets/6d05591222f3f4657946b288c6210f57_MD5.png]]

### 4.36.4 面试题

> 1

![[00 assets/9a10639da467c68c8f86e1a9db3f7c6e_MD5.png]]

> 2

1、针对箭头函数，他是从外层作用域来查找；这里有一个误区就是对象其实不算作用域
2、因为箭头函数没有 this，所以你是要 call 来显示绑定没啥用
![[00 assets/6093758b325e88811826d74eda3859bd_MD5.png]]

> 3

1、这里重点需要关注的是 person1.foo2() 的调用，和上面的 { } 不一样，我们使用函数来创建对象，函数内部其实是有作用域的

![[00 assets/b18ae2565f27aa30521954f8f55a09d6_MD5.png]]

> 4

![[00 assets/36c43dbaaadcad0829134e29c0b52912_MD5.png]]

## 4.37 Proxy/Reflect

### 4.37.1 Proxy 基本介绍

![[00 assets/00a490df1f3d420b02ebf685771f775c_MD5.png]]

![[00 assets/18dd971d4b851b5f048830910eb71a28_MD5.png]]

### 4.37.2 Reflect 基本介绍

【什么是 Reflect?有什么作用？【渡一教育】】https://www.bilibili.com/video/BV167NbeQExD?vd_source=8992a13080c32977bce93a5140823f3b

具体可以查看：[[Reflect]]

![[00 assets/a0049b3d1f9ec3057eda91cd80f6cf16_MD5.png]]

![[00 assets/2385ae85f90f4a35b7a53d6c0646d84a_MD5.png]]

1、我们使用 proxy 代理的对象修改了 height，按照下图的代码，就会执行 set height，这个里面就会修改\_height 的数据，如果使用 `target[key] = value` 的写法，修改\_height 不会触发代理对象，因为这个时候的 this 就是 info 本身，没有走代理对象

2、如果你想在 set height 中的\_height 被修改的时候走代理对象就按照下图的写法来，使用 Reflect.set()，然后传递第四个参数 receiver
![[00 assets/fc19f0e95a957384cd9e3b8939be37dd_MD5.png]]

![[00 assets/97399d337af1402bea68979062dedcd5_MD5.png]]

## 4.38 解释 JS 中的 Proxy 对象是什么以及它是如何工作的，用于哪些场景

![[00 assets/fd3f0cd2cce0f2e2aeab25b7b8da59f3_MD5.png]]

## 4.39 Proxy 和 Object.defineProperty 之间的区别

![[00 assets/bd15f3271de6d18a82bf1fd2c37b3522_MD5.png]]

![[00 assets/85f9b582487e11b9db84169cc65e857b_MD5.png]]

## 4.40 Map 和 WeakMap 有什么不同？请解释 WeakMap 的特性

![[00 assets/ddc2ff330d9869f17a408a5cffab89fd_MD5.png]]

## 4.41 什么情况下使用 WeakMap 而不是 Map

![[00 assets/0d9fd2bc5e6841fae0b522f29fb860a8_MD5.png]]

## 4.43 JSONP 是什么，原理，实现一个场景

[JSONP 跨域原理及实现 - JavaScript 进阶之路 - SegmentFault 思否](https://segmentfault.com/a/1190000041946934#item-3-3)

> 是什么 / 原理

jsonp 的本质就是使用没有同源策略的 script 发送一个请求，然后服务器端返回这个回调函数，拿到响应执行，它可以解决跨域的问题，但是不能发送 get 请求不支持 post 请求，同时支持 http 请求，不能解决不同域连个页面之间如何进行 js 调用问题

> 实现

![[00 assets/63aaad9f5812da18c3755c6cf9252cde_MD5.png]]

> 安全问题

![[00 assets/f98202b0dab9fb7713974f6da7f4fee6_MD5.png]]

## 4.44 如何统计当前网页出现过多少个 html 标签？

![[00 assets/054a0521ee6cab4660cbe00b1e245610_MD5.png]]

## 4.45 SessionStorage 和 locaStorage 的区别

![[00 assets/2121c68348b1b3ee78ec5c7377a109ac_MD5.png]]

## 4.46 为什么 js 要有微任务

^7c3720

[JavaScript 为什么要有微任务？ - 知乎](https://zhuanlan.zhihu.com/p/498370214)

因为浏览器是 宏任务 -> render -> 宏任务 -> render

![[00 assets/9fb688102171e1677576e17a521fe365_MD5.png]]

所以就是 宏任务 -> 微任务 -> render 他离渲染是更近的

![[00 assets/a4cf45eeaf57b4fc929ba5b7351bd6d6_MD5.png]]

## 4.47 == 可以用来判断 null 吗

自然是不行的，使用 == 就会导致 null == undefined 是相等的

![[00 assets/03773e2b02006a4e4fea41a58aae5d1d_MD5.png]]

## 4.48 prototype 与 proto 的区别

![[00 assets/0dfb94a34331bc6d083f92a1204aaa02_MD5.png]]

## 4.49 死循环/无限递归分别有什么问题

【死循环、无限递归会导致什么后果【渡一教育】】https://www.bilibili.com/video/BV1pzkyYVELA?vd_source=8992a13080c32977bce93a5140823f3b

1、如果只是死循环、无限递归的话，就是如下的情况。死循环无响应是因为任务一直在执行，渲染帧插不了手。而无限递归是因为函数一直压入函数执行栈中，而函数执行栈有大小限制，所以会出现栈溢出
![[00 assets/f47156c4b2ad9d288d9663e3fd08d4d9_MD5.png]]

2、如果是如下的代码，不会导致卡死，是因为你调用了 delay 的话，首先是一个微任务，然后微任务之后就是宏任务，而宏任务 setTimeout 优先级并没有那么高，此时渲染帧就有空隙了
![[00 assets/c9db325af635f7b0ebcc351b4d8b82bf_MD5.png]]

3、如果你是 await 1 的话就是 await Promise.resolve(1) 此时就是微任务，而微任务的优先级又是高于渲染的，所以会导致卡死无响应 [[八股记录#^7c3720]]
![[00 assets/050d0b92d07303a4a11920b17dc00040_MD5.png]]

4、如果是无限递归再压入队列的话
![[00 assets/4be0310a733336ffd1b626daed38f0f7_MD5.png]]
本质其实如下，那么每次调用的时候都因为宏任务/微任务，存在等待，所以函数都会直接 return，然后再是 m() 执行，所以不会导致栈溢出，而且因为是宏任务，也不会导致卡死
![[00 assets/1ccf2a1b51e5ca23e043502f916b75f8_MD5.png]]

5、这个也不会导致爆栈，但是会导致卡死，因为微任务很多，来不及进行渲染帧
![[00 assets/8771bc43e83e26d3b5aa2c1e25ccfa3e_MD5.png]]

## 4.50 如何判断函数是否标记了 async

【字节面试题：判断传入的函数是否标记了 async【渡一教育】】https://www.bilibili.com/video/BV199k9Y9EJM?vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/2f7a6941994850f913af24f26e3651db_MD5.png]]

## 4.51 样式的获取是否会导致重排

## 4.52 如何判断一个属性是否存在

【如何判断一个属性是否存在?【渡一教育】】https://www.bilibili.com/video/BV1dBcJekEHU?vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/7489d4a60a21982668ec4390a70fb011_MD5.png]]

## 4.53 获取尺寸尺寸的方式有哪些？区别是什么？

【获取元素尺寸有多少种方式?有何区别？【渡一教育】】https://www.bilibili.com/video/BV1YCcJeuEuY?vd_source=8992a13080c32977bce93a5140823f3b

1、el.style.width 本质是读的 DOM 树中的值，也就是 sytle 中写什么就会读什么，不会导致回流

2、getComputedStyle 它是得到计算样式，而且是得到确切的值，不会得到 %，auto，而是 px，但是会导致回流和重绘

3、offsetWidth、scrollWidth、clientWidth，布局树中的信息

4、getBoundingClientRect 获取视觉上的信息

![[00 assets/d6d000aebcba0ddbf75d1d293129b746_MD5.png]]

## 4.54 什么时候重绘/重排

【何时发生重排、重绘？【渡一教育】】https://www.bilibili.com/video/BV1YTcdezEW1?vd_source=8992a13080c32977bce93a5140823f3b

【浏览器对回流的优化【渡一教育】】 https://www.bilibili.com/video/BV1wSP8edEpw/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

1、针对重排，更改是异步的。但是读取是同步的，因为你需要
![[00 assets/47dac2b5aff7e9098aa89693933fb785_MD5.png]]
![[00 assets/d1d0b457a0b2b02027130f7eb04e6c73_MD5.png]]
![[00 assets/694308f5f7553ab7db8d9e1fada12532_MD5.png]]

2、
![[00 assets/f0fa4624eae3905496deec502a011bcc_MD5.png]]

【下列对回流和重绘描述正确的是？【渡一教育】】 https://www.bilibili.com/video/BV1dNPYepEh1/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b
![[00 assets/57c95a920dc4d2d97e33399576d4c43b_MD5.png]]
都错了，其中 B，如果一条条修改会合并在一起，不一定比直接修改 className 好

## 4.55 DOM 树和布局树是不是一一对应的？

【何时发生重排、重绘？【渡一教育】】https://www.bilibili.com/video/BV1YTcdezEW1?vd_source=8992a13080c32977bce93a5140823f3b

DOM 树和布局树是有一定的关系，但是并不是一一对应的

1、使用 display:none 的话并不存在布局树

2、针对 ul li 的话，li 前面存在伪类元素
![[00 assets/27c06f8d97bfb7842dd598f4ecccdbe6_MD5.png]]

3、块盒（div）不能直接出现内容，但是允许你去写，如果你直接写文本的话，会在外面包裹一个匿名行盒
![[00 assets/681aea55292481f89e1c2ea11ab45417_MD5.png]]

## 4.56 null instanceof Object / instanceof

【请选择结果为 true 的表达式【渡一教育】】https://www.bilibili.com/video/BV1bLcdePEtg?vd_source=8992a13080c32977bce93a5140823f3b

instanceof 是判断原型链的，null 虽然是 object，但是还是原始类型，不能通过原型链来判断，所以 1 instanceof Number 也是 false

NaN 和任何数据比较都是 false

## 4.57 如何动态执行 JS

【动态执行 JS【渡一教育】】 https://www.bilibili.com/video/BV16EPaeREPf/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/8263056581eb1b019cc0343c53ecb56e_MD5.png]]

![[00 assets/5eb71408a08de4b8beae5c76890f7982_MD5.png]]

## 4.58 函数作用域题目

![[00 assets/23514ecdc57ebee1a328919c1f2013b5_MD5.png]]

3 2 1

![[00 assets/48946d0c182761e73155e17f09b84240_MD5.png]]

4 3 4 5

如果此时来看 全局 a=3 作用域 a=4 实例 a=5
第一个直接在作用域上找到了，第二个则是因为 setTimeout 是全局的 this，也就是 windows，第三个也是作用域上的，第四个则是找上层作用域，此时就找到了 5

## 4.59 那种动画实现方式效率最高

【下面哪种动画实现方式效率最高？【渡一教育】】 https://www.bilibili.com/video/BV167NbeQEXj/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/6bc37708c15aa21358953389c63d0705_MD5.png]]

A 因为 left 都修改了，那么就会一直重绘，所以是从布局开始

B 因为他是在 script 中去执行，所以会修改 DOM 树，也会修改 cssom 树，也就会从主线程开始执行，那么就是解析->样式计算得流程

C 他不会影响主线程，只会影响 合成线程 画

D JS 修改得话，会改变原生得 DOM 树

## 4.60 cookie 有哪些属性

![[00 assets/9564274aff3e1290ee93b107c7847665_MD5.png]]

abcd

针对 cookie 有如下得属性
![[00 assets/c3cfef9984123aad776aa83cac95f3c4_MD5.png]]
![[00 assets/6b251a3499b8e083383829f2000afa73_MD5.png]]

## 4.61 cookie 和 session / 在浏览器关闭时清除cookie有什么方法 / cookie可以实现跨域共享吗？

[[cookie和session介绍]]

【一道关于 cookie 与 session 的面试题【渡一教育】】 https://www.bilibili.com/video/BV1gkA8eqEBa/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/937a8f2f42db25ccd63d5c3940837868_MD5.png]]

a：session 是保存在服务器

b：会话 cookie 浏览器关了就消失了

c：正确

d：cookie 被禁止可以使用其他方式来发

![[00 assets/bff18f6ac0aee126891c8c0574db3107_MD5.jpeg]]

## 4.62 哪些数据在栈，哪些数据在堆

![[00 assets/0c8e417ac5667995ce720bc62f6a0d70_MD5.png]]

【哪些数据在堆上，哪些数据在栈上？【渡一教育】】 https://www.bilibili.com/video/BV1aTcdezEd5/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b
![[00 assets/984c5bb05f4ef693cebe8c62e58d981b_MD5.png]]
![[00 assets/926d1f50be84aaa35eb5d510e9cd66c9_MD5.png]]
![[00 assets/7da812c185da3f0b40fa658b1b5dab12_MD5.png]]

## 4.63 CommonJS 和 ESM 的区别

【CommonJs 和 ESM 的区别？【渡一教育】】 https://www.bilibili.com/video/BV1FgcneDE76/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/77acb8b991b5f65cd325bf80b4811135_MD5.png]]

![[00 assets/0249fa056d0c4d63f7c3d6feb056bad9_MD5.png]]

## 4.64 解构面试题

【一道解构的面试题【渡一教育】】 https://www.bilibili.com/video/BV1cEciehEBF/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/da4cbe65fb269b60a5bf9b42213164e9_MD5.png]]

## 4.65 JS 执行栈顺序

![[00 assets/3d869a3f9c6a0fee35703e1b20afbb64_MD5.png]]

## 4.66 比较大小

![[00 assets/729ee27bcd8d415a76b513267e90992c_MD5.png]]

A

这里是从左向右运算，我一开始以为是从右向左运算

1 < 2 < 3 ===> true < 3 ===> true
3 < 2 < 1 ===> false < 1 ===> true

## 4.67 创建 webworker 时，如何不指定特定的文件

【创建 webworker 时,如何不指定特定的文件？【渡一教育】】 https://www.bilibili.com/video/BV1T8KKeuEmz/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/ebbb5b4dbff7c3b8221d86322d450f93_MD5.png]]

![[00 assets/cddd943ae242259f159a5d53adc34d2e_MD5.png]]

这本质就是工程化的内容，希望把主线程的代码和 worker 代码压缩到一起

## 4.68 有多个 IP 地址，如何在最短的时间内找出 RTT 最小的 IP

^196451

【2024 年遇见过最好的面试题【渡一教育】】 https://www.bilibili.com/video/BV1gkA8eqEes/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/3cf22370b96c2c1c26ff8631c2c18ebb_MD5.png]]

假设有 9 个 IP 地址，3 个并发，那么每次都将 IP 地址填入到每个并发里面，只要一个成功就都弹出，然后记录最短时间

再填入 3 个 IP 地址，如果没上次记录的时间短，就弹出找下一批

## 4.69 实现私有字段

【实现私有字段【渡一教育】】 https://www.bilibili.com/video/BV1cBKwe7EQJ/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

1、使用 symbol 来做字段，只要 symbol 不导出就是私有字段，但是现在可以获取对象的所有的 symbol key
2、使用 ES2022 的#来表示私有字段，但是这个兼容性不算很好
![[00 assets/8e063b81efdca40317b052e5fe833394_MD5.png]]
3、获取使用 weakmap 来做私有字段的记录也可以
![[00 assets/ea948f62fa8fb80a3a86cb96fa1ea98d_MD5.png]]

## 4.70 Proxy 比 defineProperty 到底好在那里 / Proxy 和 defineProperty 介绍

【Proxy 比 defineProperty 到底好在哪【渡一教育】】 https://www.bilibili.com/video/BV1hGKpeREtG/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

【Proxy 和 DefineProperty【渡一教育】】 https://www.bilibili.com/video/BV1X2fEY8Eas/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/f530246b460f5927c68d5095e29f6657_MD5.png]]

1、Proxy 监听的是整个对象，只要对象修改了那么就会收到通知。和 defineProperty 监听属性是不同的
![[00 assets/ba9ad44504356559936e1022bf734f48_MD5.png]]

> 介绍

1、针对对象的操作本质就是一系列内部的基本操作
![[00 assets/ddf4096ab81ff0111ec3a4423d16cbf5_MD5.png]]
![[00 assets/206468c895eb2e8bd3c528b3e0f7e01d_MD5.png]]
使用 Object.defineProperty 的本质就是 下面的 DefineOwnProperty

2、函数的本质就是对象，只是下面多了 call 和 construct
![[00 assets/1cc4350c46dc762fb2628c5c772905ca_MD5.png]]

3、Proxy 的本质就是在拦截所有的对象基本操作 `[[SET]]...`，但是使用 Object.defineProperty 本质其实是内部的一个基本类型

## 4.71 JS 不存在 JS 引擎线程

【JS 引擎线程并不存在 【渡一教育】】 https://www.bilibili.com/video/BV1hSftYJEMC/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

JS 引擎线程本质就是渲染主线程启动然后执行 JS

## 4.72 如何实现一个只读属性

【如何实现一个只读属性【渡一教育】】 https://www.bilibili.com/video/BV1kVNbesEv5/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/4446d99641f1a6a4dadfcfe887b0efa9_MD5.png]]

3、使用 Object.freeze

## 4.73 隐式类型转换

【一道隐式类型转换的面试题【渡一教育】】 https://www.bilibili.com/video/BV1KcfHYfEdL/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/a2d85033506c1b7a7f0730b0281bfd09_MD5.png]]

D

如果你将原始类型当作对象来做处理的话，那么就会转换引用类型，最后是一个包装类

这里的 s.c 和 s.d 会在赋值的时候临时拉出来一个 new String() 来使用，但是在执行之后，这个临时的对象就消失了

![[00 assets/b5fe1d3e9e51a3a2d0204724b0d90d38_MD5.png]]

C

因为你直接使用的引用类型，不存在临时的

## 4.74 ESModule 的工作原理

【ESModule 的工作原理【渡一教育】】 https://www.bilibili.com/video/BV1uLf8YHEhE/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

1、在浏览器的环境中使用 esmodule，我们引入 ./main.js 那么就会拼接为完整的 url 地址来请求资源
2、他会去解析顶级静态导入，如果我们在代码后面的 import ，他会自动导入到头部

![[00 assets/065357a3eca2cc3735208ba8b511b60c_MD5.png]]

![[00 assets/9ef7bb81f08e53b91cd5f1735d1de754_MD5.png]]

## 4.75 迭代解构题目

【一道解构的面试题【渡一教育】】 https://www.bilibili.com/video/BV1cEciehEBF/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/754b502728c4fe97c8e5394de06ce0d8_MD5.png]]

## 4.76 如何实现跨标签页通信

![[00 assets/bbb007836f2683ea3e5b7708bae3f0aa_MD5.jpeg]]

## 4.77 关于构造函数正确得是

![[00 assets/26dd0b845ea52ff4c75a466f4eafd121_MD5.jpeg]]

C


## 4.78 JS 有什么办法来实现继承

![[00 assets/385abad24d9bda2e302ba50ccdb2d5b8_MD5.jpeg]]
![[00 assets/e219ca72cd6d2f29f0ee14b953a364e3_MD5.jpeg]]
![[00 assets/efcabe8dc0acb92847ce5f07ea790a40_MD5.jpeg]]

## 4.79 for in 循环可以遍历对象自身及其原型链上可枚举的属性

for in 会遍历原型链上的可枚举属性


## 4.80 ES6里面的this指向相比于ES5有什么区别？

![[00 assets/bcd3d40c24e03316ed7d587bc7d945d9_MD5.jpeg]]

## 4.81 Fetch 相比于 XHR 的优势

【Fetch API相比于XHR的优势【渡一教育】】 https://www.bilibili.com/video/BV13YoXYnEz6/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/95b4615deab08a02346d558f27b0d4ae_MD5.jpeg]]

![[00 assets/9075ec7bec301a92a2d45993c86231c4_MD5.jpeg]]

## 4.82 什么是函数二义性？如何区分构造函数和普通函数？

【前端面试：什么是函数二义性？如何区分构造函数和普通函数？】 https://www.bilibili.com/video/BV1t3ZYYoE2c/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/973df2d9644d65a1b507001d371a5be9_MD5.jpeg]]

## 4.83 文件上传表单字段

【文件上传表单字段【渡一教育】】 https://www.bilibili.com/video/BV1TLXVYREWt/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/1dc0bad81c3b24245019808a2c0d2074_MD5.jpeg]]

## 4.84 如果你要实现一个splice，怎么做

![[00 assets/e98de1f6e98dfac9c965eea9f1085ef6_MD5.jpeg]]

## 4.85 for of 为什么无法遍历对象

![[00 assets/79445a7498efdeeff5497b984181cc31_MD5.jpeg]]

## 4.86 js如何判断2个对象相同

![[00 assets/6d8356154a67485c6f88d747e6b5a7cf_MD5.jpeg]]
![[00 assets/d0f53d3e10c8f8c0a72c40b12bc4c5e7_MD5.jpeg]]

## 4.87 箭头函数哪些场景不能使用

[[箭头函数哪些场景不能使用]]


# 5、VueJS

## 5.1 Vue2 和 Vue3 的生命周期

![[00 assets/a17a5bb5c208f17a1736e4b85a9e45ff_MD5.png]]

## 5.2 Vue2 mixin 用法

^89b01c

[混入 — Vue.js (vuejs.org)](https://v2.cn.vuejs.org/v2/guide/mixins.html)

## 5.3 封装组件需要考虑哪些东西

^8f69e9

## 5.4 Vue 数据传递有哪些方式

^85f217

[一篇文章看懂 Vue.js 的 11 种传值通信方式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/262530502)

1、props/emit

2、provide/inject

3、slot

4、ref 获取组件实例来调用内部方法

5、eventbus

6、pinia/vuex

## 5.5 Vue2 为什么 data 不能是对象而是函数

^f3899e

![[00 assets/62bb9a956db5583485ae9f3b7675777a_MD5.png]]

## 5.6 v-model 原理

^01ae46

1、v-model 绑定的本质是进行如下操作

![[00 assets/f37c896116110717c0b590a9076fc7f6_MD5.png]]

如果是 Vue2 的话可以直接使用如下方式来做修改

![[00 assets/c89abc5e464f678aee0ef2404d6b8c00_MD5.png]]

2、对于 Vue3 的 v-model 使用如下方式来做处理

[搞懂 vue3 中 v-model 的用法 - 掘金 (juejin.cn)](https://juejin.cn/post/7225133152489750587?searchId=20240611232256A9D7A6367AA0FBFFF345)

![[00 assets/16a87af1b61beaf3631a10721f8b992d_MD5.png]]

如果使用 defineModel 的话就是使用这样的方式

![[00 assets/07273d100c5a0f6c98dfb9229f5ed031_MD5.png]]

3、当然也推荐使用 v-model 来做使用

## 5.7 vue2 和 vue3 中 watch 区别

^70e4aa

[Vue3 与 Vue2 在 watch 上的区别 | JeacsonBlog (jeacsonsnake.com)](https://blog.jeacsonsnake.com/learningNote/vueNote/VUE3/VUE3_Vs_VUE2_In_Watch.html)

1、使用方法的区别

![[00 assets/4bf9a3401710c31f33af9adb6d49c197_MD5.png]]

2、vue2 可以监听单个响应式数据，vue3 可以监听多个响应式数据

![[00 assets/1856d18e3a89cb125584514d6b5bcd47_MD5.png]]

3、如果你愿意去查看官网来做对比得话其实知道对应得区别，这个是 Vue2 得 watch 得写法

![[00 assets/d6420ce8ac3f07a2ea7fa3c2e9928bc0_MD5.png]]

4、对于 Vue3 得 watch 来说，其实有很多全新得 API 来做使用，可以参考下图，其中 flush 和 onTrack / onTrigger 是比较新得
![[00 assets/f3bf2d62e3039f1f713c6a4153aaf443_MD5.png]]

5、flush：[回调得触发时机 | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/essentials/watchers#callback-flush-timing) “post”

关于 flush 得 post 也可以参考这个文章：[vue3 中侦听器配置项 flush:"post"与 nextTick 区别？ - SegmentFault 思否](https://segmentfault.com/q/1010000042325613)

    a. Vue3 目前维护着 pre、queue、post 3个队列，如果你是正常得更新数据的话就是进入到 queue 队列中，这里得正常更新是指 render，也就是渲染；

    b.  一般情况 watch 是 pre 队列得，也就是 watch 回调得执行在 render 之前；

    c. 如果你设置了 flush 为 post，那么就是 render 之后，也就是更新完 DOM 再去执行回调函数

    d. nextTick永远在 pre、queue、post队列后面，再去执行

    e. 很多人就要问了，flush 为 post 在什么业务场景使用呢？

![[00 assets/8f4b7f3d72ef652d2600a84fc68ce4e2_MD5.png]]

那么 flush：sync 有什么用呢？表示响应式数据更新立马执行 flush: sync 得 watch 回调函数，甚至在 pre 队列之前

![[00 assets/c72f7429e8488258acd192c92bb772b0_MD5.png]]

那么他有什么用呢？

![[00 assets/ead04634ad6c4db8f537abb8f186204b_MD5.png]]
![[00 assets/2441b19539449ee273ca68069da58d05_MD5.png]]
![[00 assets/a3a5f966e6153d1cdbf4a8c49410d63e_MD5.png]]

6、除了上述得东西，还有 onTrack 和 onTrigger 选项，这是用于调试使用，解决了调试得问题

![[00 assets/9045264526c2d047c927f0162d9cb7d1_MD5.png]]

## 5.8 父子组件生命周期加载顺序。如果是两个子组件呢？两个子组件是并行吗？执行的顺序怎么样？

^15a3c3

1、父子组件生命周期加载顺序如下（Vue3 setup 语法糖），所以是父组件 beforeMount 之后才挂载子组件

![[00 assets/f8df3f304b708aee25c43c3cd364149c_MD5.png]]

2、如果是两个子组件的话，顺序如下：串行，只有在第一个组件加载到 onBeforeMounted 才换下一个，所以总结为单个组件不管嵌套与否都会执行 onBeforeMount 为止，才开始执行子组件或者兄弟组件，然后才是对应的 mounted 挂载

![[00 assets/da61f49e07f2169b4f60b01f601e709c_MD5.png]]

## 5.9 Vue2 和 Vue3 的区别

[一个问题干懵面试官 ：Vue2 与 Vue3 的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7203195123433734203)

[[vue2和vue3对比]]

总结如下：大致分为 响应式、运行时、编译器 方面的区别

1、**响应式**：Vue2 时期使用 defineProperty 进行监听，但是存在一个问题后续想添加监听的数据就不行了，只能使用 Vue.$set，显然不符合自动响应式的规范。所以 Vue3 使用 Proxy + Reflect，但是 Proxy 只能使用复杂数据类型，对于基础数据就使用 ref，ref 本质就是一个 RefImpl 类，内部绑定 set 和 get

![[00 assets/10a63a7f8c387ad8fc66e08260e1aa42_MD5.png]]

2、**运行时**：在 Vue3 中将 渲染函数 和 宿主环境 拆分了，通过接口的方式对接了，为什么这样做呢？这是因为 Vue3 需要跑在不同的设备中，比如浏览器、服务器（SSR）、桌面端、移动端等，所以做了拆分，可以让 Vue3 跑在不同的环境中

3、编译器



## 5.10 vue diff 算法 请介绍一下

## 5.11 v-if 和 v-show 的区别

## 5.12 v-for 中 v-key 有什么用

## 5.13 Vue 生命周期钩子都做了什么？

[javascript - Vue 3 生命周期完整指南 - 终身学习者 - SegmentFault 思否](https://segmentfault.com/a/1190000039680245)

[组合式 API：生命周期钩子 | Vue.js](https://cn.vuejs.org/api/composition-api-lifecycle.html#onmounted)

[Vue 生命周期总结（四个阶段，八个钩子函数）-CSDN 博客](https://blog.csdn.net/hello_woman/article/details/127507138)

（推荐）[面试官：请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？ | web 前端面试 - 面试官系列](https://vue3js.cn/interview/vue/lifecycle.html#%E4%B8%89%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B)

![[00 assets/d5258be53af0ec0465aed85524fa2dfb_MD5.png]]

![[00 assets/da7666e7f0c041884ec10b8a8c603046_MD5.png]]

## 5.14 Vue 响应式如何实现 / Vue 是如何收集响应式依赖的

这部分内容可以先理解响应式原理中得代码 [[Vue 原理]]

假设这里有一个对象 { name: "zjh", age: 18 } 那么你套一个 reactive 方法就会返回 new Proxy() 的代理对象，这里返回 infoP 内部含有 get / set 方法，如果你在类似 watchFn / effect 这类函数中调用那么就会记录 activeFn，如果存在就会被放到依赖中，比如我这里在 watchFn 调用对应的 infoP.name，首先就会一层层给 infoP 创建一个 weakMap，weakMap 中放着 infoP 的 key，如果此时 name -> new depend()，依赖都会放进 depend 中去；如果你修改了 infoP.name 那么就会触发 Proxy 的 set，此时就会在上述的 depend 中寻找并且依次执行内部收集到的 fn

这里拿 reactive 举例子，使用 reactive 他本质是调用 createReactiveObject 函数，内部会针对不同的内容使用 ProxyHandler，如果是 Map、Set、WeakMap 的话就是 Collection，只有 get 的代理，这里有一个细节就是，它内部维护了一个 proxyMap，如果对象已经响应式创建过就直接返回创建好的 Proxy

这里拿内部代码中的 effect 函数来举例子，首先我们传入的函数是被包裹到 ReactiveEffect 函数中，我理解为是上述的 activeFn，后续会执行执行 ReactiveEffect 内部的 run() 方法，它的本质就是将 fn 执行一遍，当你执行的时候，内部响应式就会触发 get 方法，此时内部会触发 track 函数来执行，此时就是针对对象创建 weakMap，为 key 内部填充 depend，然后 depend.track() 再将 activeEffect 收入依赖中

如果你修改对象，那么就会调用 trigger 函数，内部一个个执行

## 5.15 ref 和 reactive 的区别

## 5.16 Vue 和 React 的区别

[【5 年以上前端】Vue 和 React 的区别看这里 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000043837947#item-1)

## 5.17 vue 双向绑定如何实现

[面试官：双向数据绑定是什么 | web 前端面试 - 面试官系列](https://vue3js.cn/interview/vue/bind.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A)

## 5.18 Vue 编译过程

## 5.19 Vue 自定义指令

![[00 assets/d6f9ed56fd2a55d66982d7ecf1db1ddb_MD5.png]]

## 5.20 为什么需要虚拟 DOM

【为什么需要虚拟 DOM？【渡一教育】】https://www.bilibili.com/video/BV1fir3YGEC7?vd_source=8992a13080c32977bce93a5140823f3b

## 5.21 Vue 项目有哪些常见优化手段

【vue 项目有哪些常见优化手段?【渡一教育】】https://www.bilibili.com/video/BV1pzkyYVETd?vd_source=8992a13080c32977bce93a5140823f3b

性能优化：[[八股记录#^96541f]]

![[00 assets/76f811f8179e6c1f2dcd545502362360_MD5.png]]
![[00 assets/faf9c3b7db1ecce3bcbb9b164dd43020_MD5.png]]

## 5.22 静态资源动态访问

【静态资源的动态访问 【渡一教育】】https://www.bilibili.com/video/BV1k8cde9Etf?vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/3d6c76f6fde43dad55d7b5a5b6fabce8_MD5.png]]

1、标签静态链接路径
![[00 assets/e63d5dbea402987d88dd69f7e272d339_MD5.png]]

2、使用 url() 来获取
![[00 assets/08d04b072873717ee2958c71fb490158_MD5.png]]
将文件豆放进 public 中，这样可以直接访问，但是会丧失文件指纹
![[00 assets/79d218a55a0711a9372fc7c02f08a876_MD5.png]]
或者一个个导入
![[00 assets/72c60c266d6fad9075708fab2dc5d8d5_MD5.png]]

3、动态导入，使用 import 来做导入，需要带有静态的地址，这样才能打包，不然无法分析，因为 js 是动态的只有执行才知道结果
![[00 assets/e47606a31a98a27ba07c62ad6835bdd3_MD5.png]]

4、使用 URL 构造器，使用这样的方式会避免打包 js 文件出来，直接就是 图片
![[00 assets/ea54533aee3c04a8fe4f2cfb689a0236_MD5.png]]
![[00 assets/6d67af742332455fb764fb9a50608d83_MD5.png]]

## 5.23 Vue2 可以 $forceUpdate 强制组件渲染？Vue3 如何强制渲染组件

【vue3 该如何强制渲染组件?【渡一教育】】https://www.bilibili.com/video/BV18LcdePEgL?vd_source=8992a13080c32977bce93a5140823f3b

## 5.24 watchEffect 运行结果

只触发三次，因为响应式的本质就是函数对应的数据，这里使用 watchEffect 会收集 user.addr 和 user.addr.p 的响应式依赖，但是会不会收集 user.addr 的依赖呢？其实不会，因为 本质是基于 Proxy 的，需要读取属性才会，这里响应式本身就是 user

1、sichuan 本身触发一次收集依赖
2、beijing
3、jiangsu
![[00 assets/eb5f4c5183f2275eea35e67909eafebd_MD5.png]]

## 5.25 Vue 响应式的本质

![[00 assets/7c8b06647404c1fb5fc8bab4622529cd_MD5.png]]

## 5.26 watch 运行结果

【一道 vue3 中 watch 函数的面试题【渡一教育】】 https://www.bilibili.com/video/BV1isfHYGEEX/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/ee2d9e5a217ededf9ec61da2195ebc7f_MD5.png]]

3 3

我们使用 watch 得时候，响应式会先执行一遍，此时 a 和 b 收进依赖中，那么此时打印得是 3，我们在修改了 a 和 b 之后那么又会执行一遍，此时又是 3，因为 watch 函数返回值相同，那么就不会执行后面得 val 函数，最终输出 3 3

![[00 assets/6b726c1af27b8d3848032fc39b7ef900_MD5.png]]

输出 4 5

因为针对第一个函数得返回值是不变得，所以即便我们后面 state.c++ 之后依旧是不变得

![[00 assets/fc12b183b9f030610f11498c286da7e4_MD5.png]]

输出 4 5

因为 a 都是同一个对象，所以不变。但是这里就有一个疑问了，这是比较地址值还是比较对象内部值得关系

![[00 assets/b671b01c9940320466663a91cfe3bec4_MD5.png]]

输出：1

因为在响应式收集得时候，只会关联读取数据，而这里得 state.c 是赋值，这是不关联得，所以即便后面 ++ 修改也是没用得

![[00 assets/a94341a5b9ba8344a53f3fb568eb6e07_MD5.png]]

4

因为此时 C 不是响应式数据

![[00 assets/d85b3382277acfe4474ff6ea72774dc9_MD5.png]]

1 1

因为这里得 getC 函数 本质其实是在读取，而且此时作用域直接读取得就是 state 中得 c

![[00 assets/dbac9d8ecd0785fa663b117156df14d5_MD5.png]]

{ a: {}, c:4 }

响应式只会关联里面得成员，如果只是使用 `state` 是不会关联得

![[00 assets/90c174821503bf27bb1f9b306c59bef7_MD5.png]]

1 0

和上述的类似

## 5.27 watchEffect 异步问题

【watchEffect 中的异步问题【渡一教育】】 https://www.bilibili.com/video/BV1RPPheLE25/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b
![[00 assets/036f9a3cc03aad903ce15be4fe610a43_MD5.png]]

因为我们使用 `watchEffect` 的时候会收集依赖的，但是这里是异步的，在执行到异步就已经结束了

## 5.28 script setup 和之前的语法差异在那里/究竟到底做了什么

【script setup 到底做了什么 【渡一教育】】 https://www.bilibili.com/video/BV1MmNJe3EpJ/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/f6e3cefaf101b9441494bba2aaf73700_MD5.png]]

1、setup 这里多了一个 expose()，expose 会暴露实例成员
2、针对 setup() 和 setup 语法糖暴露的方法都是不一样的
![[00 assets/72176ff3a9c639c3546d20a3d645a7d9_MD5.png]]

![[00 assets/2086150c93688fa60ca9c608ac1f114a_MD5.jpeg]]

## 5.29 双向绑定的效率问题

【双向绑定造成的效率问题【渡一教育】】 https://www.bilibili.com/video/BV1wxf8YyEkP/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

如果你使用双向绑定 v-modal，可以使用 .lazy 来提升双向绑定的效率

## 5.30 Vue3 模板中的 ref 的实现原理

【vue3 模板中 ref 的实现原理？【渡一教育】】 https://www.bilibili.com/video/BV18LcdePEPM/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/1e3a055839de320044469272aa0f07b1_MD5.png]]

## 5.31 Vue在框架层面在模板编译的时候做了哪些优化

![[00 assets/758ac3ee179b8658a0c1f962bb5bbaa9_MD5.jpeg]]
![[00 assets/626db081413f9bffaf9bfb0bcb84cf8f_MD5.jpeg]]
![[00 assets/105344a013ebb9173cc9fa13d94f1f7c_MD5.jpeg]]
![[00 assets/bef8858b833521dccda610fe3df6f990_MD5.jpeg]]
![[00 assets/36df1d466580a297539def596823ecd7_MD5.jpeg]]
![[00 assets/83fff3d4632dfce3763fdf57b3a95342_MD5.jpeg]]
![[00 assets/dc011d5091e3ef8c246a9a78859f6479_MD5.jpeg]]
![[00 assets/af18f2742b9a226fd4e18d1151c3896d_MD5.jpeg]]

## 5.32 如何去区分静态变量还是动态变量

![[00 assets/2deeaf5ab9c6434799c9ff2e770a4ffc_MD5.jpeg]]
![[00 assets/2b91a5de7bddce33adc9af5cfd0f0b52_MD5.jpeg]]
![[00 assets/ef911fa7e11c5ec37b488b6c767d96f8_MD5.jpeg]]
![[00 assets/485a9fb851d7180f2db922c531cc0e59_MD5.jpeg]]
![[00 assets/365c38961ccbca91e0beea4bb8b1523e_MD5.jpeg]]
![[00 assets/fb0a8f59d716a69dd4987f60ab5bba47_MD5.jpeg]]


## 5.33 模板编译这一块具体是如何编译的？模板编译里AST抽象语法树了解吗


![[00 assets/188d43ca77249b7d667ec4d5c1f24dc3_MD5.jpeg]]


## 5.34 讲讲 Vue2 和 Vue3 双向绑定得区别



## 5.35 Vue3 得 Teleport 是什么？在什么场景下会使用到？

![[00 assets/a484a311b6bd561caff57a695a4fb5b1_MD5.jpeg]]

## 5.36 Vue3 中的 Suspense 是什么？如何使用它来处理异步组件？

![[00 assets/e733ae6d25a8da1db276f80ef9f5e1f8_MD5.jpeg]]

## 5.37 Vue 样式穿透

他得本质就是编译之后添加 hash
![[00 assets/9bc9adeb7fb37d29ba1264a54153eeff_MD5.jpeg]]

## 5.38 Vue 中 method 和 computed 得区别

![[00 assets/30c5cbb174e46c1f61ff46ac848bc7c4_MD5.jpeg]]

## 5.39 Vue中得插槽

插槽得本质就是一个函数

## 5.40 虚拟 dom 有什么好的地方？ 框架为什么要设计虚拟 dom？

[[虚拟 dom 有什么好的地方？ 框架为什么要设计虚拟 dom？]]

## 5.41 Vue和Jquery的区别

![[00 assets/2a05357ef2150eba9a84158dc98a182f_MD5.jpeg]]

## 5.42 Vue响应式原理

[[Vue响应式原理]]

## 5.43 vue中keep-alive的原理是什么

[[vue keep-alive原理]]

## 5.44 vue2 中的 this 是什么东西

![[00 assets/996b5e978f837dea34741bfc2dcae884_MD5.jpeg]]

## 5.45 vue中父组件调用子组件的原理

[[vue中父组件调用子组件中的方法的原理]]

也就是模板编译的时候就获取子组件的实例

## 5.46 Vue和React的对比

[[Vue和React对比]]

[面试官最想听到的Vue和React区别 - 知乎](https://zhuanlan.zhihu.com/p/25242471112)

[对比一下Vue和React ? —— 9个方面给你答案总体来说，Vue 和 React 都是优秀的前端 UI 框架,各有 - 掘金](https://juejin.cn/post/7288597387799805986#heading-12)


## 5.47 Vue中computed和watch的区别

![[00 assets/b0adfc990702f1ac4cb26af1ca2a48ae_MD5.jpeg]]

# 6、NodeJS

## 6.1 事件循环如何处理

![[00 assets/015826bba243648f023e3d20f2461e26_MD5.png]]

## 6.2 epoll 和 ipoc

[技术派-epoll 和 IOCP 之比较 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/106957967)

Linux 的 epoll、macOS 的 kqueue、Windows 的 IOCP；为了抹除各个平台关于这些差异，libuv 出现了，他主要聚焦的就是异步 IO，也就是 NodeJS 使用的底层库

![[00 assets/3ad1580bb709decaae07340363b4ea84_MD5.png]]

![[00 assets/25859657d29fb35dfbd98adcf96d56c6_MD5.png]]

## 6.3 当你输入 npm run dev 到你进入网址整个过程

[当输入 npm run 后发生了什么在前端开发的工作当中，使用 `npm run dev` 的命令启动本地开发环境，是再 - 掘金](https://juejin.cn/post/6971723285138505765)

你输入 npm run xxx 的时候会在 node_module 下面的 .bin 来查找对应的可执行文件，而可执行文件的本质就是调用内部的 js 的文件；但是这里为什么需要使用 npm run xxx 呢？这是因为你直接输入 vue-cli 系统其实不知道，所以这里使用 node 的 npm 来代为执行
![[00 assets/453948145eaee3cccdca37b252f476a1_MD5.png]]
而内部为什么是 3 个文件呢，本质还是操作系统不同的可执行文件的区别
![[00 assets/ebd7b9a088f99145b054bc49fc3e5d49_MD5.png]]
执行完 js，那就是对应打包工作的活了，webpack 根据 entry 查找，期间根据模块引用关系依次构建依赖图，然后各个文件经过 loader plugin，最后输出处理完的文件

## 6.4 xss 攻击

[前端安全系列（一）：如何防止 XSS 攻击？ - 美团技术团队 - SegmentFault 思否](https://segmentfault.com/a/1190000016551188)

如何防止：

1、输出验证和过滤，使用 join、validator 等库来做验证

2、在将用户输入输出到 HTML 页面时，使用 HTML 实体编码，确保特殊字符不会被解析为 HTML 或 JavaScript

3、通过设置 Content Security Policy 头来限制允许加载的资源来源。CSP 可以帮助防止恶意脚本的执行

4、使用一些安全库，如 helmet，可以帮助设置一系列安全相关的 HTTP 头


## 6.5 corepack 是什么？解决了什么问？

![[00 assets/0163fa59356157d28a84dc23b684a75b_MD5.jpeg]]

## 6.6 Nodejs中如何封装一个接口，原生是如何做的

![[00 assets/fa604dc4080e7aebc84a6e701c593954_MD5.jpeg]]

## 6.7 Node.js 的事件循环 和 JS的事件循环的区别之处？

![[00 assets/48d6373c4aa360971dcb2f4008f9f5c7_MD5.jpeg]]
![[00 assets/be4766edf5818619aa9892fa092b1380_MD5.jpeg]]
![[00 assets/36d32dd78c3818f71d00cc6994490e17_MD5.jpeg]]
![[00 assets/85977d9b3ad4d45336816d5b818ba6ae_MD5.jpeg]]
![[00 assets/8941fb7aa52964023e939877be475135_MD5.jpeg]]

## 6.8 讲一下缓存、消息队列、数据库

[[讲一下缓冲、消息队列、数据库吗]]

## 6.9 我现在使用pm2多线程开启node服务，那node服务针对写入操作怎么处理的，会冲突吗

![[00 assets/91cfd524a7b6a373adfd5218ede2974b_MD5.jpeg]]
![[00 assets/174e78045a229d71264f328e9d28b072_MD5.jpeg]]
![[00 assets/5d06a4ee9673b5e9933b27e9b2a8e883_MD5.jpeg]]
![[00 assets/3af4ab853bb1d08efafeacb5e0d28f7d_MD5.jpeg]]

# 7、Uniapp

## 7.1 Uniapp 中 微信小程序、app 端、h5 端分别有哪些区别

^c74cf0

app 端：H5+、nvue、renderjs 等，对应的 h5 和 微信小程序也有对应的插件

![[00 assets/536ee408a1dfaa3e38008cd08056d498_MD5.png]]

## 7.2 Uniapp 做微信小程序的优势

[使用 uni-app 开发小程序，比直接原生开发小程序好在哪里 - 跨端开发 - SegmentFault 思否](https://segmentfault.com/a/1190000020839825)

1、都是纯 Vue 开发模式，不需要学习原生微信小程序的模式，开发更友好

2、生态更好，开发更快

3、后期迁移好做，如果你按照 Uniapp 的规范开发可以很轻松迁移到其他端，配合条件编译

4、因为微信小程序双层架构的原因，setData 每次传递数据量过大或频繁调用都会导致性能问题；但是 Uniapp 针对 setData 做了单独的优化

它借鉴了 westore JSON diff 库的实现，在 setData 之前，对历史数据比对出差量数据，再执行 setData

除了上述的差量数据，最后会合并成一条数据一次更新

## 7.3 1. uniapp 打包小程序的背后的原理？

![[00 assets/aa0b12ff162fc23c89328199fe864c32_MD5.jpeg]]
![[00 assets/6d7c936159051378d937d48a2ad14d96_MD5.jpeg]]
![[00 assets/a0806db6cb277a9679b85ccb62f6c146_MD5.jpeg]]
![[00 assets/8ddb682968a6fea53e1d4706ddbab96e_MD5.jpeg]]
![[00 assets/f4db1d4ecf8c262e362a08bd7101f9ae_MD5.jpeg]]
![[00 assets/bf711a6fff9cf7859613c9e6a7605c65_MD5.jpeg]]



# 8、Axios

## 8.1 Axios / fetch / XMLHttpRequest 那个好

## 8.2 Axios 你一般是怎么使用的 / axios 出现解决了什么问题

> 怎么去使用

1、如果是针对日常的使用直接使用 如下的方式即可
![[00 assets/9aaf40e8d7a4769941b50febecd849e3_MD5.png]]

2、如果是项目我一般使用如下的方式来编写
![[00 assets/7a78dc8038e143e4f5fda641fa378b6c_MD5.png]]

> 解决了什么问题

![[00 assets/451459115d1457f0d4d8da4a774683dc_MD5.png]]

## 8.3 axios 底层原理实现

[[axios底层原理]]

## 8.4 ajax 和 fetch 对比

[Ajax 之战：XMLHttpRequest 与 Fetch API 在本文中，我们将研究早期 XMLHttpReques - 掘金](https://juejin.cn/post/7090890245238947848#heading-2)

fetch 更加现代化，编写更加简单，在请求头、响应对象都有优势；fetch 有第二个参数，可以控制缓存策略，凭证控制（控制不发送 cookiet，ajax 默认发送）、重定向控制，还有数据流的支持，对于服务器也是支持的

ajax 可以监听进度，针对超时可以控制，中止支持

## 8.5 axios的拦截机制

[[axios的拦截机制]]

# 9、微信小程序

## 9.1 微信小程序分包怎么做的

^6b54fd

[基础能力 / 分包加载 / 使用分包 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html)

分包推荐：[性能与体验 / 启动性能 / 代码包体积优化 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start_optimizeA.html#_1-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%85%E5%8A%A0%E8%BD%BD)

1、普通分包：他可以去依赖主包来使用，也必须依赖主包来使用

2、独立分包：如果是这样的话，就要不依赖主包的资源，比如项目中部分场景是不需要依赖主包的独立页面，可以使用独立分包

## 9.2 微信小程序架构是什么样的

小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。

![[00 assets/da84c0e965199e02547d571c647bff72_MD5.png]]

## 9.3 微信小程序生命周期说一下

> 组件生命周期

![[00 assets/a772255dd7af21009903ec163298e6e5_MD5.png]]

同时因为组件是挂载到页面中，所以页面和组件也有很强的关联

![[00 assets/7e17105b9f20b750c6cbe8b8df194c9f_MD5.png]]

> 页面生命周期

关于页面的生命周期，首先就是视图层和逻辑层，他们会进行初始化操作，随后逻辑层进行 onLoad 和 onShow 这里适合进行网络请求

视图层初始化完毕会发送一个 Notify 给逻辑层，此时逻辑层发送消息给视图层，视图层完成初次渲染，会发送 Notify，此时逻辑层为 onReady

如果该页面关闭就会 onHide，再次显示就是 onShow，页面卸载就是 onUnload

![[00 assets/c9c30fba5870f9352ab734155295f42b_MD5.png]]

![[00 assets/135243426bb13c1b413bc2ff4a966c05_MD5.png]]

> 应用生命周期

![[00 assets/fa400d72e3d590917cccae7f9ca6e23a_MD5.png]]

## 9.4 小程序的 API 做了什么处理，能够做到全局变量的隐藏，如果是你，怎么设计 ？

[[小程序的 API 做了什么处理，能够做到全局变量的隐藏，如果是你，怎么设计 ？]]

# 10、TypeScript

## 10.1 请说一下你对于 TS 得理解

^71ef7f

[[10 TypeScript#^160a62]]

## 10.2 TS 如何为一个类型做扩展/修改一个类型

^8ef933

1、使用交叉类型来扩展类型

![[00 assets/d318200733d288b38d7a23edc706539f_MD5.png]]

2、如果想修改的使用下面的方式

![[00 assets/fb1ef4a791363ff885696fdbc08e7e9c_MD5.png]]

3、使用下面的方式来对类型进行增减

![[00 assets/2a59cac26cab0099905063142a5da7cd_MD5.png]]

## 10.3 一个函数第一个参数是一个对象，第二个参数只能是对象中得 key，使用 ts 该怎么写

^c86640

![[00 assets/48efbd0ed4bbcf7028050f419f404d70_MD5.png]]

## 10.4 TS 的泛型使用

![[00 assets/913280ba36934cfa41d3caa5c56056fe_MD5.png]]

## 10.5 any 和 unknown 的区别，怎么使用 unknown 将泛型赋值给一个 string 类型

![[00 assets/c1d91cd453d89a0e73bc29112d7a4425_MD5.png]]

1、方法一：使用类型断言

![[00 assets/34ad5fe043e89566cc0372e6a7878fec_MD5.png]]

2、方法二：使用类型检查

![[00 assets/10bac14af17d507c221740092ba0169f_MD5.png]]

## 10.6 说说 typescript 中的 interface 和 type 的区别分别的概念

![[00 assets/bec931afc9b53b1d61d2acfe61d38c5a_MD5.png]]

![[00 assets/b89ac205056464debb5c21c9e0107c01_MD5.png]]

![[00 assets/c5b677ceb5404e606cee7a10433e1294_MD5.png]]

## 10.7 讲讲TS中内置的工具有哪些

![[00 assets/eaba6a2cb58e9ae22e9c228755d94cd5_MD5.jpeg]]


# 11、笔试题

## 11.1 作用域指向

> 1 this 输出什么？如果让 this.name 输出 456

this 输出看情况，如果浏览器环境就是输出 123，如果是 node 环境的话就是 undefined，node 环境中有一个 global 的对象，var 塞不进去

printName 改为箭头函数，调用 printName 使用 call
![[00 assets/5956112e910221423b4d7b412d328da5_MD5.png]]

> 1 2

![[00 assets/112d7f3c592afca7915e1c5b281611c0_MD5.png]]

## 11.2 原型笔试

> 1 下述代码输出，如果删除 return 输出什么

原始输出： 2 3 undefined
删除 return 输出：1 7 8 因为 this.a = 1 是挂载到对象中的属性，而下面的是挂载到原型，肯定是优先找到对象中的属性
![[00 assets/6f52c7eb56f43f7fd2fa4ee47a7d6d4f_MD5.png]]

> 2

![[00 assets/518b4bc32aabf8aff6c2f46409743b15_MD5.png]]

![[00 assets/21cb922da3bb948731b000f01937f7aa_MD5.png]]

## 11.3 联级查找数据

![[00 assets/9a55223a4fe609253812a1c5d71ddf23_MD5.png]]
解决 1
![[00 assets/8189909fadeccd541bc95cc5718e8b67_MD5.png]]
解决 2
![[00 assets/4b1618e3d4577ef9d3c525590b82ec1e_MD5.png]]

## 11.4 用 reduce 写一个数组拍平，拍平 n 层

![[00 assets/7c03a38ad17d5ca81716a32ed46afa29_MD5.png]]

## 11.5 带 pid 的数组转树

![[00 assets/bc28fbf0558cd66be75691c35fc31a9f_MD5.png]]

## 11.6 算法

### 11.6.1 最长回文子串

![[00 assets/4c053f12e5600545054b20d6f86bf4a6_MD5.png]]

### 11.6.2 字符串匹配

![[00 assets/22b2bcff2062d7894bf9e577bd47787f_MD5.png]]

### 11.6.3 大数相加

[JS 面试题：实现大数相加（详细注释理解版）这是一道还算常见的原生 JS 算法面试题，手写代码实现非负的大数相加，JS - 掘金](https://juejin.cn/post/7023043356443803678)

![[00 assets/ed0e40bee21fb9ce3d8d0a6dc5d4cb31_MD5.png]]

### 11.6.4 杨辉三角

![[00 assets/097b39f30564e3575dc5d9addf13e7cf_MD5.png]]

### 11.6.5 二叉树的深度遍历

## 11.6 发布订阅模式，实现一个 EventBus 类，具备 on、off、once、emit 方法

![[00 assets/0a9756729975aa7a7e818c3dea7914d6_MD5.png]]

## 11.7 手写一个 Vue 弹窗

![[00 assets/6afbba20cdcd13f47fd13e0bcaed3ccb_MD5.png]]

![[00 assets/51a038f367c1dcfb8aef9db01e203c4f_MD5.png]]

## 11.8 通过二分乘除实现 Math.sqrt( )功能

![[00 assets/82b1cc8e0d874d71a3d0c9dd3b980eef_MD5.png]]

## 11.9 实现 26 进制的转换

![[00 assets/a1fab270392fb89b44b334c8c2c0f607_MD5.png]]

## 11.10 并发请求

![[00 assets/b262dca9b0d397f55aa4bbc3ffa7f693_MD5.png]]

## 11.11 红绿灯实现

![[00 assets/196183c829c5baa8376365d9cdb75f85_MD5.png]]

## 11.12 设计模式

### 11.12.1 工厂模式

![[00 assets/d0fa143e41311934d71496e9043ad04e_MD5.png]]

### 11.12.2 适配器模式

![[00 assets/83a39fff126ce4cca2072e92d5d78120_MD5.png]]

### 11.12.3 单例模式

> class 写法

![[00 assets/fe77d80403a076503322c73d68ba2b53_MD5.png]]

> 函数闭包写法

![[00 assets/56aa900d95f61ac5429bf2c7efa422bd_MD5.png]]

## 11.13 手写深拷贝

![[00 assets/32368ab311b32e6983f4630880ae8950_MD5.png]]

## 11.14 并发任务控制

## 11.15 链式调用和延迟执行

【链式调用和延迟执行【渡一教育】】 https://www.bilibili.com/video/BV1DvPCekEAD/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/57ee52b7342a756dae50104b4e3a8e34_MD5.png]]
![[00 assets/756b448644046e62bdb25ba555f30c1f_MD5.png]]
![[00 assets/ac58b9d1b7e24a1bf79bb328f72dcd48_MD5.png]]
![[00 assets/29af573dcd8b9566e1439299f7545921_MD5.png]]

## 11.16 数组转树

![[00 assets/1ad17387dfbadce597b55db91cb25f11_MD5.png]]

## 11.17 算法LRU

[[算法LRU]]

## 11.18 二叉树中序遍历


## 11.19 无重复字符的最长子串


## 11.20 lodash的get函数


## 11.21 实现promise.all



# 12、正则表达式

## 12.1 判断一个字符只有字符和数据

![[00 assets/3ab40c170c4174f8392e47c018dded8e_MD5.png]]

## 12.2 正则匹配选择

![[00 assets/1ffdc4ed37113ce7d20efdc7c5ffa27e_MD5.png]]

# 13、业务场景

## 13.1 权限管理了解过吗？RBAC 权限管理，如何做到没有权限不加载对应的代码，菜单和页面呢？

^25cb6b

[面试官：vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？ | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/vue/permission.html#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E5%81%9A)

## 13.2 你的项目部署会区分环境吗？比如测试、预发、线上，还是只会部署线上？

1、如果只是前端环境得话，可以用 process.env.NODE_ENV 来实现

2、如果是针对前端得灰度，我知道可以使用 nginx + lua + apollo（阿波罗）来实现整体得灰度发布；或者还有一个技术方案就是使用 bff + apollo

## 13.3 大屏适配怎么做

[大屏数据可视化——屏幕适配方案(多分辨率下）\_数据可视化低分辨率怎么调-CSDN 博客](https://blog.csdn.net/Sophie_U/article/details/109582687)

使用 body 计算 scale 来做适配

## 13.4 请说一下你系统中的权限管理中，关于 路由加载是怎么做的，路由懒加载是怎么做的，抛开 API 层面来说，说下底层原理如何实现的

首先前端需要编写一个包含全部页面的完整路由表，在 VueRouter 中的 beforeEach 中，校验是否登录了，如果登录了就会请求该用户的路由信息，比对前端的完整路由表信息，此时使用 VueRouter 的 addRoute 来动态添加路由信息；因为我们将信息写入了 beforeEach 中，如果刷新页面也不会影响动态添加路由信息，如果我们输入网址那么就会触发 VueRouter 的路由加载，因为页面内容都是懒加载，所以路由匹配才会下载对应的内容

## 13.5 有一个 menu，想进入页面的时候就定位到上次最后进入的那一个，怎么做？

使用 localStorage 来存储，

## 13.6 后端传给你 10w 条数据，前端怎么去处理

大致分为如下操作

> setTimeout

![[00 assets/63c180028cf43077dd7b48729ee6a367_MD5.png]]

> requestAnimationFrame

![[00 assets/c536095e03a324098d357a89c70e02de_MD5.png]]

> 文档碎片 + requestAnimationFrame

![[00 assets/24bf573c88d845223abead7414a69418_MD5.png]]

> 懒加载，本质是分页加载

![[00 assets/b3e8d2d497a1501a56b37359a655098d_MD5.png]]
![[00 assets/a47c6312f38f355af61adccda0c64f4e_MD5.png]]

> 虚拟列表

[「百毒不侵(三)」结合“康熙选秀”，给大家讲讲“虚拟列表”虚拟滚动，就是根据`容器可视区域`的`列表容积数量`，监听用户 - 掘金](https://juejin.cn/post/6966179727329460232#heading-4)

## 13.7 虚拟列表如何实现原理

[「百毒不侵(三)」结合“康熙选秀”，给大家讲讲“虚拟列表”虚拟滚动，就是根据`容器可视区域`的`列表容积数量`，监听用户 - 掘金](https://juejin.cn/post/6966179727329460232#heading-4)

[「前端进阶」高性能渲染十万条数据(虚拟列表)在工作中，有时会遇到需要一些不能使用分页方式来加载列表数据的业务情况，对于此 - 掘金](https://juejin.cn/post/6844903982742110216#heading-6)

![[00 assets/d5df72411ae72909fbf564da56438c2b_MD5.png]]

## 13.8 前端项目部署

## 13.9 现在要做一个秒级的倒计时，要用 setTimeout 来做，它会有什么风险点(比如倒计时的一秒一定是精确的一秒吗)。setTimeout 的执行机制是什么？

![[00 assets/2bfe03d14ba4e28a5544e9f9e38131b4_MD5.png]]

会由单独的定时器线程来控制，定时器事件完毕之后会推入到事件队列中等待主线程执行

![[00 assets/3fe0deed24a9afc8d8d8c50f2fab715e_MD5.png]]

## 13.10 你在开源项目的选择是什么样的

1、Star 是否够多，作者是否又名，社区内讨论是否活跃

2、最后的更新时间、Issues、Fork 的数量、开源协议

3、当前业务是否和开源库契合

## 13.11 如何实现弹窗拖动

1、使用如下的方式来确定

![[00 assets/d9ab1088af33d28c7eb965e19f79bad1_MD5.png]]

## 13.11 如何减少白屏时间

[如何减少白屏的时间 | HZFE - 剑指前端 Offer](https://hzfe.github.io/awesome-interview/book3/topic-white-screen-optimization)

![[00 assets/ded62e4e24201e3a0fd05e6da9721375_MD5.png]]

1、是否是依赖文件过大引起的。采取缓存，或者通过 cdn 解决

2、是否是请求过度导致的。可以采取合并请求的方式。

3、是不是 dom 渲染过重导致的，比如长列表。可以采取分页加载、懒加载以及采取 requestAnimationFrame 先展示部分数据。

4、动画导致的。采取 GPU 加速等措施

## 13.12 同一个 URL 如何实现适配手机和电脑

【同一个 URL 如何实现适配手机和电脑？【渡一教育】】https://www.bilibili.com/video/BV1HzkyYGEGd?vd_source=8992a13080c32977bce93a5140823f3b

1、流体布局：不是很推荐，如果只是简单网站的话
2、媒介查询，一般都使用这个来做，但是后期维护会导致难度加大，并且为了做单独适配需要额外为 2 个端编写额外的适配代码
3、服务器可以通过 HTTP 请求判断 user-agent 来查看，通过 nginx 来做资源分发
4、如果是 SSR 的话就更加简单了，可以直接根据返回的 user-agent 来做设备判断，然后指定渲染的内容即可

![[00 assets/b88317d8d0f39467b46a0efda27e014f_MD5.png]]

## 13.13 什么是 CSS 原子化？优劣是什么？

【什么是 CSS 原子化？优劣势是什么？【渡一教育】】https://www.bilibili.com/video/BV11YCEYLEDi?vd_source=8992a13080c32977bce93a5140823f3b

优势
1、复用性高
2、开发效率的提升（AI + tailwindcss）

劣势
1、团队中很难推下去
2、可读性很差 -> 可以使用 CSS 组件化 （tailwindcss 可以将多个类合并）
3、打包体积 -> css tree-sharking

## 13.14 QPS 达到峰值的时候，如何做处理

1、针对前端的话第一个就是尽可能利用缓存
2、针对 CND 预热的解释如下
![[00 assets/45f57ef1a8fd1c98346b7cd82c082128_MD5.png]]
![[00 assets/c94fe1a98fdaee169f955373eced5649_MD5.png]]

3、再就是针对前端的处理，最好就是添加提示，降低体感时间就行
![[00 assets/fece95ecd71a840d6d4732c50a0c115c_MD5.png]]
4、针对后端的话也可以上 RabbitMq 来做削峰填谷，将消息放进消息队列中，在后面再去慢慢那消费
5、前端的部分图片也可以使用新的图片格式，比如使用 avif 图片格式，这个格式比 webp 又少 20%，针对图片内容的返回又可以使用 picture source 来做处理
![[00 assets/2926a5010e92c368a5cf135e3be225ff_MD5.png]]
或者使用内容协商机制来做处理 [内容协商 - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation)

## 13.15 任务的中断和恢复

## 13.16 如何实现精确的 setInterval

【如何实现精确的 setInterval?【渡一教育】】https://www.bilibili.com/video/BV1Dm62YZEeS?vd_source=8992a13080c32977bce93a5140823f3b

1、使用 webworker 其实算是一个比较好的解决方法，但是需要自己来做封装函数功能
![[00 assets/bcd87401dc6f6848303d084afdd695de_MD5.png]]
、

## 13.17 如果后端响应巨量数据，如何避免性能问题

【后端响应巨量数据，如何避免性能问题?【渡一教育】】https://www.bilibili.com/video/BV1pzkyYVEKt?vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/19355904f2a3e6c35c7eb15129bdbc50_MD5.png]]

## 13.18 100 万个任务执行，如何保证页面不卡顿

【100 万个任务执行，如何保证页面不卡顿?.【渡一教育】】https://www.bilibili.com/video/BV1HzkyYVEox?vd_source=8992a13080c32977bce93a5140823f3b

本质是将任务给分片来执行
![[00 assets/90e0adb37317537c6954b88158188fee_MD5.png]]

## 13.19 用户登录前如何确定他是谁

【用户登录前，如何确定 ta 是谁？【渡一教育】】https://www.bilibili.com/video/BV1Qm62YZEz6?vd_source=8992a13080c32977bce93a5140823f3b

1、使用 uuid 就是把全局唯一的 id 发送保存起来，在每次请求页面的时候携带这个 cookie 然后返回 AB 测试的页面

2、ip 地址也可以判断，但是国内是个大局域网，局域网套局域网，一个家庭或者社区可能都是同一个 ip 地址，所以不好

![[00 assets/39f2e75948bcba0773522a17a96f3425_MD5.png]]

## 13.20 浏览器如何知晓服务器传递资源的类型？

【浏览器如何知晓服务器传递资源的类型？【渡一教育】】https://www.bilibili.com/video/BV1AzkyY5EWh?vd_source=8992a13080c32977bce93a5140823f3b

主要是通过 Content-type

## 13.21 网络请求使用 messagepack 来压缩 json 体积，提升网络请求性能

## 13.22 页面加载后发生大量 ajax 请求如何优化

【页面加载后发生大量的 ajax 请求，该如何优化？【渡一教育】】 https://www.bilibili.com/video/BV1M8KKeuEEk/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/5722b73eed4269702989ef4295ff988c_MD5.png]]

针对前端来说可以写一个 BFF 层来做接口聚合；我们也可以写一个请求队列；我们针对一些幂等性（只要参数相等返回数据相等）得网络请求就可以缓存起来；HTTP2 中可以压缩头部；多域名并发，因为浏览器一次性针对一个域名只能发几个，我们就可以多搞几个域名可以并发更多得请求；使用 HTTP2

## 13.22 如何消除异步得传染性

```javascript
// 用于消除异步得传染性高阶函数
// 目前为实验阶段，暂时使用 fetch 来做处理
function sanitizeAsyncContagion(fn) {
  const cache = {
    status: "pending", // pending, fullfilled, rejected,
    value: null,
  };

  const oldFetch = window.fetch;
  const newFetch = function (url) {
    if (cache.status === "fullfilled") {
      return cache.value;
    } else if (cache.status === "rejected") {
      throw cache.value;
    }

    const promiseFetch = oldFetch(url)
      .then((res) => res.json())
      .then((data) => {
        cache.status = "fullfilled";
        cache.value = data;
      })
      .catch((rej) => {
        cache.status = "rejected";
        cache.value = rej;
      });
    throw promiseFetch;
  };

  // @ts-ignore
  window.fetch = newFetch;

  try {
    fn();
  } catch (promiseFetch) {
    if (promiseFetch instanceof Promise) {
      promiseFetch.finally(() => {
        // @ts-ignore
        window.fetch = newFetch;
        fn();
        window.fetch = oldFetch;
      });
    }
  }

  window.fetch = oldFetch;
}

function getUser() {
  return fetch("https://registry.npmjs.org/@kg-cli/cli");
}

function main() {
  console.log("main1");
  console.log(getUser());
  console.log("main2");
}

sanitizeAsyncContagion(main);

```

![[00 assets/43ea280523d6d538df5193e54eb6204b_MD5.png]]

他得核心原理就是我们在创建了一个 fetch_promise 之后将 fetch_promise 抛出异常，此时函数中断运行，然后使用 promise.finally 来接住即可再来执行一遍即可，本质函数执行了 2 遍，第一遍是为了创建 Promise，第二遍则是 Promise 状态修改之后再来执行一遍函数，完成流程
![[00 assets/329e37f8ae819ab9577d2181b5b442d3_MD5.png]]

## 13.23 jwt 和 cookie/session 取舍

现在大部分小公司会使用 jwt 方案，因为数据是存在客户端得，session 则是存在服务端得，服务器压力较大

## 13.24 文件指纹是什么？它在前端工程化中得作用是什么？

![[00 assets/3f5352f8b5ddeae2f5674577ac514bdc_MD5.png]]
![[00 assets/3253666c0021a410f69784ffe74c8b1b_MD5.png]]
![[00 assets/c5f4e971ec2f1bb587069abbd84c8b54_MD5.png]]

## 13.25 有哪些跨域方案？真实项目如何选择？

【有哪些跨域方案?真实项目中如何选择?【渡一教育】】 https://www.bilibili.com/video/BV1pzkyYVEx1/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

[[八股记录#^5d2d59]]

CORS、代理、JSONP；推荐使用代理

![[00 assets/00993a0cf85e7f3364b0ebbafa2a8c00_MD5.png]]

## 13.26 单道方式，任务 A、B、C 如何执行，可以获得最短平均周转时间

![[00 assets/84d6757d98c97bc66e5b00ec323acc30_MD5.png]]

## 13.27 如何实现自动检查更新

本质就是下面的 2 个方法，检查远程资源
![[00 assets/31eb1e31951a6ec578043d8e91252954_MD5.png]]

## 13.28 有多个 IP 地址，如何在最短时间内找出 RTT 最小的 IP

【2024 年遇见过最好的面试题【渡一教育】】 https://www.bilibili.com/video/BV1gkA8eqEes/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

[[八股记录#^196451]]

## 13.29 列表分页，快速翻页下的竞态问题

【快速翻页时，如何保证始终显示最后一页的内容？【渡一教育】】 https://www.bilibili.com/video/BV1utKKe6EVY/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

请求顺序和响应顺序不一致，比如你发送第一页和第二页的请求，但是第一页的响应是后到的，那么页面上显示的是第一页的数据

1、比较 requestId（page，size 也可以），在响应的结果中和 page、size 进行比较，只取最后一个即可

2、取消请求，每次点击就自动请求上一次请求就行
![[00 assets/5235ef3a39fa155520cd1b6016bf39f9_MD5.png]]

## 13.30 上传文件时如何展示上传的速率

![[00 assets/abe85c2f72b20bf1a2b6da6d41e66e1e_MD5.png]]

其实就是使用 XHR 来监控

## 13.31 单点登录模式解析

【单点登录的模式【渡一教育】】 https://www.bilibili.com/video/BV11aPyeeEwM/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/3b9de655604b0c700bdc98807049d421_MD5.png]]

1、登录方便
2、如果这个人违规就可以直接控制

![[00 assets/ed010523e47bfd9af297a6c42ad47f62_MD5.png]]

1、这种可以大大减少服务器的压力，因为 token 存在用户中
2、但是对用户的控制减低了

![[00 assets/2c9882a86173268dab1a3d32cd94f85d_MD5.png]]

1、所以有了双 token 的处理方式，一个长 token REFRESH，只有认证中心认识，每次拿着这个 TOKEN 就会从认证中心返回一个新 TOKEN，这个新 TOKEN 在子系统中是认识的
2、这样每隔一段时间就会请求一次，实现了对用户的控制

## 13.32 高量级任务执行优化

【高量级任务执行优化【渡一教育】】 https://www.bilibili.com/video/BV1G2fEYhEeM/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

1、这里需要解释一下为什么宏任务是卡顿，这是因为每个浏览器需要通过任务量来判断是否渲染，会匀出一部分渲染出去，所以会导致卡顿
![[00 assets/897d18dbd83a760dd4da0885500d4c65_MD5.png]]

2、所以我们需要判断是否有渲染的时机，可以使用 requestAnimationFrame 或者 requestIdleCallback 来判断，但是 requestIdleCallback 对于 safari 支持不是很好
![[00 assets/60d0639b13de1d2272b82f1406cadae5_MD5.png]]

## 13.33 脚本加载失败如何重试

【脚本加载失败如何重试【渡一教育】】 https://www.bilibili.com/video/BV1fEPCeWE93/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

本质 script 加载失败之后直接使用 script onerror 来做事件代理然后再插入 script 执行即可
因为部分 script 是有顺序的，可以使用 document.writer() 来做阻塞

## 13.34 如何实现 token 无感刷新

【token 无感刷新【渡一教育】】 https://www.bilibili.com/video/BV1NaPyevEH6/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

本质就是在 axios 的响应拦截器中实现，只要无权限就重新请求即可
![[00 assets/2f0ccd8853a061e0cf6ed22b07ed521e_MD5.png]]

可能存在一个问题就是我们正常刷新长 token，但是这个时候有很多短 token 的请求，这样就会频繁触发长 token 的请求，我们可以使用下面的 promise 单例
![[00 assets/201303295bb489e9654ba75e86a3b631_MD5.png]]

## 13.35 cookie 现在被弃用了吗？

【互联网公司都在弃用 Cookie？值得思考的面试题】 https://www.bilibili.com/video/BV11XNbeZEF2/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/e4585d3eb55a5af739243579cf5f4a05_MD5.png]]
![[00 assets/29b151b76ce93e363c393887ad5e96d6_MD5.png]]
![[00 assets/393e957310fb4cd65a17be5cb6e0bc26_MD5.png]]
![[00 assets/db8f2217c922737456aeea707e0bf981_MD5.png]]

所以不同情况不同处理

## 13.36 什么时候使用 webworker

【什么时候使用 webworker?【渡一教育】】 https://www.bilibili.com/video/BV11PfHYdEMB/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/3c7b4f73d3561f4d7049edb83c51c91d_MD5.png]]
![[00 assets/44716a10268a8fa94edeb7e6030de849_MD5.png]]
![[00 assets/429d932c74bfa97f7db167ab0539875a_MD5.png]]
![[00 assets/1bae1aa731021cced11e6c4ef0f685d8_MD5.png]]

## 13.37 如何设计一个沙盒（sandbox）

[[如何设计一个沙盒 sandbox]]

## 13.38 当用户不断点击的时候如何防止他多次点击

[[当用户不断点击的时候如何防止他多次点击]]

## 13.39 给一个div，通过样式设置为长方形，如何判断鼠标是在长方形对角线的上边还是下边

[[给一个div，通过样式设置为长方形，如何判断鼠标是在长方形对角线的上边还是下边]]

## 13.40 移动端如何实现1px边框，为什么

![[00 assets/2907f1d21d5d209b3b46b27feac51a55_MD5.jpeg]]
![[00 assets/6a84d1d06d993ecc62b2ea930cdba70c_MD5.jpeg]]
![[00 assets/aef3977e731291ca5daf306d237d7eff_MD5.jpeg]]

## 13.41 图片懒加载原理

[[图片懒加载原理实现]]

![[00 assets/cb40f92f4b9f1e2e90f8e74ec636c2a7_MD5.jpeg]]
![[00 assets/a65a0e027b85b43ca1f92cdd0065543d_MD5.jpeg]]


## 13.42 一个长数组的处理阻塞了页面如何处理

![[00 assets/15666d6a24443ab571503ad5ed6572f2_MD5.jpeg]]
![[00 assets/96ae9d5b925e4e6c39c315329691eb97_MD5.jpeg]]




# 14、Promise

## 14.1 Promise 如何去使用的？如果 Promise 一直 .then() 得话，会取到是什么值？

^d09c85

Promise.then() 的返回值是什么，它会返回一个新的 Promise，所以为 undefined

![[00 assets/b497e73bf32c4561a9683203148286ea_MD5.png]]

## 14.2 async await 详细说说？async 和 await 是否需要成对出现？await 除了接异步之外还能接同步吗，比如 await "1"

^0d4645

1、async 和 await 是用同步的方式来执行异步的操作；并且被 async 标记的函数会返回一个 Promise；async 本质是 generator 生成器函数 和 Promise 的语法糖，generator 函数和普通函数的区别就是左上角多了 \* 使用 yield 来表示中途暂停点，每次调用 next 就是下一个执行点；

2、其不用成对出现的

3、是可以接同步的函数

![[00 assets/130fa0741dc7934918c21afa5e7f7b44_MD5.png]]

4、如果你是 await 1 可以看作是 await Promise.resolve(1)

## 14.3 异步处理方案

^00d87d

### 14.3.1 回调函数

![[00 assets/c73b676328b660e771ab3bed631f3764_MD5.png]]
![[00 assets/800cd1303e684004f8703e00ae00e12c_MD5.png]]

### 14.3.2 Promise 方案

[[05 ECMAScript#^872c8d]]

![[00 assets/a4f59c31d8a40fea4fbbd4173e7e2920_MD5.png]]

### 14.4.3 Generator 方案（手写 asycn/await）

[[05 ECMAScript#^bbfc74]]

1、使用生成器就可以实现如下的效果，其实和 Promise 是差不多的
![[00 assets/4a1c586c06ff5ef814cfcd01f7bca5fa_MD5.png]]

2、但是下面的调用实在太麻烦了，我们就可以去封装一下，参考下图就可以实现
![[00 assets/ec3dbbee13d0985cba43f88cc22731d9_MD5.png]]

![[00 assets/83060d2b38a996b8c055bfd0cd9427c4_MD5.png]]

### 14.4.4 async/await 方案

#### 14.4.4.1 针对 Generator 理解

1、其实在 ES6 是没有 async / await，所以就有了上述的生成器方案；换个角度来讲其实 async / await 是 Promise 和 Generator 的语法糖
![[00 assets/6d34c5fb9f610c4f9d796a02dc6f9fcf_MD5.png]]

#### 14.4.4.2 针对 async/await 的细节

1、async 的返回值有对应的细节，可以查看后面的面试题 [[八股记录#^7d1439]]

![[00 assets/98307de0abddea806c4cb39057eecbff_MD5.png]]

2、await 的使用和返回值

![[00 assets/ed1636660e0ca675d7426395c21b27f2_MD5.png]]

## 14.4 手写 Promise

[coderwhy/HYPromise: 实现一个完整的、符合 Promises/A+规范的 HYPromise (github.com)](https://github.com/coderwhy/HYPromise)

## 14.5 解释什么是回调函数，以及它在异步编程中的作用和存在的缺点

详细可以查看异步处理方案 [[八股记录#^00d87d]]

![[00 assets/c4cdff5268296b52fb58ea5d6660cee9_MD5.png]]

## 14.6 如何解决所谓的“回调地狱”

![[00 assets/2d96e332dfd111c409c798389b626bb7_MD5.png]]

## 14.7 什么是 Promise？引入 Promise 的原因是什么？

![[00 assets/4ce43a68134ea8a39429612155fc165e_MD5.png]]

## 14.8 解释什么是生成器以及它在异步编程中如何被使用

![[00 assets/4f4e1d8ee7ce1ebc08284d248d114ab7_MD5.png]]

## 14.9 描述 async 和 await 的作用，以及 Promise 相比有什么优势和不同

![[00 assets/25acec83ce10247338c5dc90a5143834_MD5.png]]

## 14.10 Promise 各个都代表了什么

> Promise.all()

![[00 assets/7f28bcbcf6476d08a42657691a520f7e_MD5.png]]

> Promise.allSettled()

![[00 assets/c301df0540b78abee0752a31a832d1a7_MD5.png]]

![[00 assets/83e1a250b4236a1c99708e3a46b9fa1b_MD5.png]]

> Promise.race

![[00 assets/52e470abfe90d6cf9538cfc91dff67e9_MD5.png]]

> Promise.any

![[00 assets/ae3ec03d7ac0617d53166589dfcd4c89_MD5.png]]

## 14.11 Promise 选择题

【一道 promise 的社招面试题【渡一教育】】 https://www.bilibili.com/video/BV1cSP8edEXP/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b
![[00 assets/7ad2a58f2a072f681a22a946170ab251_MD5.png]]

2 5 6 4 3 1

我一开始得答案是 2 5 6 3 4 1

这里可以这样理解，resolve（3）执行得时候只是改变了 Promise 得状态，但是这个回调函数并未执行完， 所以先放进微队列得是 Promise.resolve(4).then(console.log) 在回调执行完毕之后才会将 3 得回调放进微队列

## 14.12 Promise 解决了什么问题？

![[00 assets/350e979bca79c0b08c65acf38f65a629_MD5.png]]

## 14.13 为什么在浏览器中要添加微任务

![[00 assets/e2390b5dfce31ffe0d1a05079bff06eb_MD5.jpeg]]
![[00 assets/f65aad2034a7c6d21008c5f004f72e0d_MD5.jpeg]]
![[00 assets/42e6a1e9d2f7ea4a09b5804bd2aa2be3_MD5.jpeg]]

## 14.14 Promise 状态吸收

【你知道promise会吸收状态吗？【渡一教育】】 https://www.bilibili.com/video/BV1L491YhEvj/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

>执行顺序：true、3

这里得 Promise.resolve() 直接返回 p1

![[00 assets/d6b4ce9a97f9f6c8da1c00856e60656f_MD5.jpeg]]

>执行顺序：3 1 4 2

如果把一个 Promise 丢进 resolve 和 reject 得时候，会吸收 p1 得状态，并且吸收得这个过程就是进微队列得

1、首先打印 3
2、因为 p1 执行完毕，打印1，那么p1进微队列，因为p2返回Promise，那么吸收P1这个动作进微队列
3、然后再是吸收完毕，p2完成进入微队列，此时打印4
4、再来打印2
![[00 assets/d880ffe8c22816defeb677586275c37b_MD5.jpeg]]

## 14.15 Promise的实现

[[Promise的实现]]




# 15、VueRouter

## 15.1 vue router 有路由守卫，有哪些路由守卫，这些路由守卫一般是做什么得

^2f10a2

1、分大类的话有进入路由守卫和离开路由守卫，但是按照作用域来讲是全局、独享、组件路由守卫

![[00 assets/781fe1243a5cac4e7431a11622a931a6_MD5.png]]

2、如果你使用路由的话也有下述的生命周期

![[00 assets/da626c2ae4ed38e3c42a625d5fbe691e_MD5.png]]

## 15.2 请说一下 Vue Router 中得路由模式，并说一下这两种模式的区别

[Vue--Router--路由模式--种类/区别/原理\_vue 路由模式的区别-CSDN 博客](https://blog.csdn.net/feiying0canglang/article/details/122756784)

针对于 Vue router 其实有 3 种模式，Hash、History、Abstract 模式

> Hash 模式

Hash 模式：使用 url 的 hash 值作为路由，Vue 的默认路由模式、支持所有浏览器。

根据 MDN：Location 接口的 hash 属性返回一个 USVString，包含 URL 标识中的 '#' 和 后面 URL 片段标识符，被称为 hash。例如：http://www.abc.com/#/article，hash 的值为 `#/article`

1、第一个#后的所有字符，都会被浏览器解读为位置标识符，它只用来表示页面位置（一个锚点）。这些字符都不会被发送到服务器端。

2、单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。

3、每次改变#后的部分，都会在浏览器的访问历史中增加一个记录。见：此文

4、window.location.hash 表示 hash 值。此属性可读可写。

5、使用 window.addEventListener("hashchange", fun) 可以监听 hash 的变化

Vue 的 Router 的 hash 模式的原理是：使用 window.addEventListener("hashchange", fun) 监听 hash 的变化，hash 变化之后，根据这个新的 hash 找到相应的页面，然后更新视图。

后端不需要额外配置，原因：#及之后的字符不会被发到服务器例如：http://www.abc.com/#/article在Vue Router 中有对应的路由，而我直接输入了http://www.abc.com/#/article/id，Vue Router 中没有对应路由。此时并不会报错。原因：只有http://www.abc.com会被发送到服务器。

缺点：不美观（url 中带了个“#”）

> History 模式

History 模式：使用 History API：pushState() 和 replaceState() 方法。但是只有 HTML5 之后支持。

window.history 提供了两类 API：跳到某个浏览记录：back(), forward(), go()；添加/修改历史记录：pushState(), replaceState()

这些方法都只修改当前 url，不会向后端发起请求。

原理
1、Vue 监听 url 改变这个事件：window.addEventListener('popstate', fun);
2、Vue 在切换页面时，使用 pushState(), replaceState()来修改当前的 url
3、切换页面之后，popstate 事件被触发，调用相应的回调函数更新视图
![[00 assets/62ca594a4097c9439a3a432d2035547c_MD5.png]]

> Abstract 模式

Abstract 模式：支持所有 JavaScript 运行环境（包括 Node.js 服务器端）如果发现没有浏览器的 API，路由会自动强制进入这个模式。

![[00 assets/b3fc8e3723636222a11dba882e045cba_MD5.png]]

## 15.3 vue-router有哪些核心实现api

[[vue-router的核心实现api]]

## 15.4 vue-router的中的动态权限管理是如何做的

[[vue-router的中的动态权限管理是如何做的]]

因为我们编写的时候会写一个完整的路由表，只要导入使用了这个路由表那么打包的工具就会把里面的 import() 都打包进去，那么在路由表动态添加映射的时候，输入对应的路由就会去请求该路由下的js文件，那么就实现了加载
# 16、Git

## 16.1 你知道哪些 git 的指令

![[00 assets/e5c18612c8cb387cc1b40303bb4765e7_MD5.png]]

## 16.2 git 如何做回滚

![[00 assets/f70f0a3d5900bf4c1984b0c77c758084_MD5.png]]

## 16.3 git rebash和git merge有什么区别

[[git rebash和git merge有什么区别]]

# 17、Pinia/Vuex

## 17.1 vuex/pinia 如何使用，如何去做持久化存储

【状态仓库持久化【渡一教育】】 https://www.bilibili.com/video/BV1seRnYkEhu/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

其实本质就是如下图所示

![[00 assets/a88036ee0ca5e055032fa9709cbedbae_MD5.jpeg]]

## 17.2 为什么vuex设计了一个mutations，而pinia不需要

[[为什么vuex设计了一个mutations，而pinia不需要]]

## 17.3 vuex pinia 的实现原理

[[vuex pinia的实现原理]]

## 17.4 vuex的底层原理实现

[[vuex底层原理实现]]

# 18、Webpack/Vite

## 18.1 webpack 和 vite 得区别

在开发层面，webpack 每次都会对下面的文件依赖进行模块化处理，而 vite 是直接使用的浏览器对于 ESM 的支持，因此不需要重新打包，热更新也是基于原生模块的加载

在构建层面：webpack 更加成熟，有丰富的优化插件，以及代码拆分；而 vite 是基于 rollup 的，但是生态和插件丰富程度上不如 webpack

## 18.2 vite 为什么比 webpack 快

[Vite 为什么快呢？快在哪？说一下我自己的理解吧前言 大家好，我是林三心，用最通俗易懂的话讲最难的知识点是我的座右铭，基 - 掘金 (juejin.cn)](https://juejin.cn/post/7040750959764439048)

【vite为何可以秒启动？【渡一教育】】 https://www.bilibili.com/video/BV1uqoXYUEbu/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

1、对于下载的依赖方面，使用的 esbuild 来进行预构建依赖，esbuild 又是使用 go 来编写的，快了 10-100 倍

2、针对于源码部分变动比较多。但是也不是一次性都加载完，而是根据路由来加载，并且以 es module 的方式交给了浏览器，这样就提升了很多；而之前的 webpack 是将所有的文件都打包成模块再依次进行加载

![[00 assets/94ef4548c3098eeaaf13a256b126e7e9_MD5.png]]
![[00 assets/795ee755724a084f4367d7e741e140b8_MD5.png]]

3、同时针对更新缓慢的问题，vite 还使用了 http 缓存，直接使用缓存信息

## 18.3 有没有看 webpack 配置在哪一块可以分开获取 bundle 不同场合

![[00 assets/37da551b404b7f3274a76f81bf031e0b_MD5.png]]
![[00 assets/10cb356fce11ebadbebbddab89f1f79f_MD5.png]]

## 18.4 webpack 中 plugin 和 loader 得区别

[面试官：说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？ | web 前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/webpack/Loader_Plugin.html#%E4%B8%80%E3%80%81%E5%8C%BA%E5%88%AB)

（推荐）[字节面试题：webpack 的 loader 和 plugin 有什么区别？Webpack 是一个非常强大的模块打包工具，它能够处 - 掘金 (juejin.cn)](https://juejin.cn/post/7411046020841259043)

1、loader 就像一个翻译官，会将不同得文件转为 js 模块，它可以实现链式调用，串联成一个管道，以及异步处理；而 plugin 就像一位全能选手，可以在整个构建阶段实现对文件得增删改，plugin 基于构建阶段得钩子来实现

2、作用范围不同：loader 主要用于文件转换；plugin 可以在整个构建阶段做任何自定义逻辑

3、触发时机不同：loader 只在解析文件得时候触发；而 plugin 在整个构建任意阶段被触发，通过 webpack 提供得钩子

4、执行顺序：loader 形成一个处理链条；而 plugin 按照配置文件中一次顺序执行

5、总体而言：loader 适用于文件级别；而 plugin 适用于更复杂得构建任务

6、这么说 plugin 这么厉害，loader 岂不是没用，肯定不是得，既然分出来肯定有自己得道理，webpack 其实无法处理非 js 得文件，这个时候就需要 loader 出手转为 js 模块，而且 loader 得链式调用也很灵活，loader 配置也相对简单很多，易于理解；可以理解为 loader 和 plugin 分别是菜刀和锅，要用菜刀切菜才能再丢进锅里面才能将菜炒熟

![[00 assets/9b32b8081a154ca601412dbbee6a1136_MD5.jpeg]]
![[00 assets/f0ed7c6ee9ea9baafbe21ad5da5bafc8_MD5.jpeg]]
![[00 assets/2aaaf265ad97a69ce8f17decc82539f5_MD5.jpeg]]


## 18.5 常用的 loader / plugin 有哪些

[分享 12 个 Webpack 中常用的 Loader 初衷： 整理一些常用的 loader 分享给大家，方便知道在什么场景下该用什么 l - 掘金 (juejin.cn)](https://juejin.cn/post/6942322281913778206)

style-loader / css-loader / sass-loader / postcss-loader / babel-loader / ts-loader / html-loader / file-loader / url-loader / vue-loader

## 18.6 请说一下目前前端环境中，类似 webpack / vite 为什么不可或缺

[面试官：说说你对 webpack 的理解？解决了什么问题？ | web 前端面试 - 面试官系列](https://vue3js.cn/interview/webpack/webpack.html)

1、可以使用模块化的方式来开发

2、现在很多的前端框架，比如：Vue、React 等工具陆续出现，内部有很多自己的语法，需要打包工具进行打包

3、使用一些高级的特性来加快我们的开发效率或者安全性，比如通过 ES6+、TypeScript 开发脚本逻辑，通过 sass、less 等方式来编写 css 样式代码

4、在开发效率上，监听文件的变化来并且反映到浏览器上，提高开发的效率，发完成后我们还需要将代码进行压缩、合并以及其他相关的优化

## 18.7 webpack 的构建流程

[面试官：说说 webpack 的构建流程? | web 前端面试 - 面试官系列](https://vue3js.cn/interview/webpack/build_process.html#%E4%B8%80%E3%80%81%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B)

![[00 assets/a3db3a174d32af7e6d4d33714e7ef674_MD5.png]]

将 options 收集完毕之后，就会对 compiler 对象进行初始化，该对象掌控者`webpack`声明周期，不执行具体的任务，只是进行一些调度工作，在我实习中的项目就引入了 unplugin-vue-component 来解决组件全局引入的问题，unplugin-auto-component 就封装了方阿飞，本质也是对 watchRun、compilation 阶段进行监听

![[00 assets/c84ef29d52474f88cc36638ccd374640_MD5.png]]

后面就根据 entry 找到所有的入口文件，依次进行如下流程

![[00 assets/4f0f16d77a974cefe7c66532a1328de4_MD5.png]]

![[00 assets/0bdee7291bd9e3a53b2bb10c0e019a4e_MD5.png]]

## 18.8 打包分析和优化

【打包体积的分析和优化【渡一教育】】 https://www.bilibili.com/video/BV1dLN3eFEXD/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

## 18.9 如何清理源码里面没有应用的代码，主要是 JS、TS、CSS

【如何清理源码中没有被应用的 JS、TS、CSS 代码？【渡一教育】】 https://www.bilibili.com/video/BV1n7NbeXEj1/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/aac355ebcd72f325a0805c2ee69c517b_MD5.png]]

![[00 assets/a61d1612f1ff1038cc81a9ddb131f681_MD5.png]]


## 18.10 webpack 和 vite 在本地开发的时候底层热更新的实现有什么区别

![[00 assets/680f16bc1b0058cf6e15a8e005c0c922_MD5.jpeg]]
![[00 assets/8757a2a9ef4d89111edfbbba43041c58_MD5.jpeg]]
![[00 assets/ab597590d74eef54a8b8447a3ce38437_MD5.jpeg]]

## 18.11 vite 是如何处理 commonjs 模块

![[00 assets/e88531c8e27ffb983e011da6eef92bc9_MD5.jpeg]]
![[00 assets/25d7030d58814f0074421da548c58d21_MD5.jpeg]]
![[00 assets/4c0ea6ae8fd2ececd66423caf356d5ac_MD5.jpeg]]

## 18.12 Webpack 怎么建立模块间的依赖关系

![[00 assets/76151801d7e3b58f293720e3ec347a8a_MD5.jpeg]]

## 18.13 webpack 如何提高构建速度

![[00 assets/9041f79b7469db74263e4170d20f8d05_MD5.jpeg]]


## 18.14 webpack loader输入什么产出什么

[[webpack loader输入什么产出什么]]


## 18.15 webpack 动态加载的原理、热更新

[[webpack 动态加载的原理、热更新]]


## 18.16 ES6转ES5有哪些方法？

本质使用 babel 来做转换，如果你使用 webpack 的话就使用 babel-loader 来做转换

![[00 assets/05a8e77fb3030d7bae87d6208e1ea2b7_MD5.jpeg]]

## 18.17 babel-loader底层原理

[[bable-loader底层原理]]

## 18.18 vue-loader底层原理

[[vue-loader底层原理]]

## 18.19 webpack打包处理common.js与ES6 Module的区别

[[webpack打包处理common.js与ES6 Module的区别]]


## 18.20 bundle和chunk的区别

[[bundle和chunk的区别]]

# 19、设计模式

## 19.1 装饰者模式

1、其实在 Vue 源码中 mount 方法就是很典型的装饰者模式

![[00 assets/b1ffa0a316ea024f9b528afce5de85ff_MD5.png]]


## 19.2 设计模式选择

【下图属于哪种设计模式？【渡一教育】】 https://www.bilibili.com/video/BV1oW91YaE7A/?share_source=copy_web&vd_source=8992a13080c32977bce93a5140823f3b

![[00 assets/28e8ba3b6e7f8c94242b50b0a945e7a1_MD5.png]]

C

## 19.3 发布订阅模式与观察者模式的区别

[[发布订阅模式与观察者模式的区别]]

# 20、数据结构

# 21、Koa

## 21.1 Koa2 是否使用了生成器

[KOA2 框架原码解析和实现 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/59608760)

# 22、Vue 源码解析

## 22.1 createApp

1、整体调用如下，可方法查看，下面来讲讲里面比较有意思的地方

![[00 assets/f70d57c069ab7e9e04cf264c4f81bf0c_MD5.png]]

2、在创建渲染器的时候使用了单例模式，意思就是永远都是那个渲染器

3、Vue3 还对渲染做了分层，如果你是不同的平台，只要写不同的 rendererOptions 即可实现渲染
![[00 assets/ffe5b6d4aa1fdef0768b8a5cac0f8529_MD5.png]]

4、createRenderer 函数的本质就是调用内部的 baseCreateRenderer，通过传递不同的参数来区分
![[00 assets/b63514c11f2c8141e1fc4f39189d402a_MD5.png]]
5、baseCreateRenderer 内部的代码非常的多，这里就不介绍了，其实最终就是返回 3 个函数
![[00 assets/8506797a075ff042eae4f9cd39a16b91_MD5.png]]

6、createAppAPI 就是如下操作，创建一个 app
![[00 assets/d291df1c49e466e15ac308cd7c0e5cea_MD5.png]]
7、查看内部可以知道 app 下面的各种全局方法
![[00 assets/454dca441bb8c6e69fe88bcef47f6ffd_MD5.png]]

8、最后还有一个 mount 来挂载，其实使用了 装饰者模式，在原有的 mount 方法基础上添加
![[00 assets/bcfce53c0ed3a949d6ee5c2bb5e4d608_MD5.png]]
9、如下图就可以看到，做了很多额外的处理，比如统一 DOM，解析 innnerHTML 等
![[00 assets/9e07fc928e9ba722aca5561ad260542b_MD5.png]]

## 22.2 vnode

1、我们在 mount 的时候就会执行 createVNode
![[00 assets/e3dfc9e7eb8bcb3d2319d73d3af9a345_MD5.png]]
2、对于 createVNode 就会执行如下的函数，其实本质最后就是 `_createVNode`
![[00 assets/da479913158f5f24203b15cf47994f98_MD5.png]]
3、对于最后的 `_createVNode` 本质就是使用 createBaseVNode
![[00 assets/c4eac814d61af3c49f073dd4e731ab19_MD5.png]]
4、最后就是返回 vnode
![[00 assets/0f3233f7a9f5d323c329049290793aaf_MD5.png]]

## 22.3 diff 算法

![[00 assets/01f215559ad3a9b8663a919cb90e3af9_MD5.png]]

### 22.3.1 block diff

1、如果你想查看更新可以在如下得函数中进行 debugger

![[00 assets/b14bf1830a72626f85f3d3d0d6675956_MD5.png]]

2、在 componentUpdateFn 中有一个 nextTree，里面就有一个 dynamicChildren 来表示动态更新得数据

![[00 assets/da16ff70bdbb3299fae1c324278366ca_MD5.png]]

![[00 assets/a99e7426e7452df1da16c2b5cbc9b21b_MD5.png]]

![[00 assets/cea28ccdcf9af0bb8a7bdbfb4bdfd870_MD5.png]]

3、这里得 type 是 Fragment，所以进入到 processFragment 中

![[00 assets/d323c01cc939ecfb4da6f5fbdac08784_MD5.png]]

4、我们再往后面调试，可以看到会进入到 patchBlockChildren 中，这里就是我们说得 block diff

![[00 assets/9298169265a0d1115abf4e05ab969ea1_MD5.png]]

如果你想说之前得 unkey diff 和 key diff 呢？在后面的 patchChildren

![[00 assets/7a38663142f91578b320be42b0c57d79_MD5.png]]

### 22.3.2 无 key diff

目前页面如下：
![[00 assets/e9bdc859a33e05516686a744f2795478_MD5.png]]

1、其实无 key 的情况不算很复杂，和上述的 block diff 其实差不多，首先是如下的 dynamicChildren，名称列表本质也是 fragment
2、剩余的过程和上述的 block diff 其实差不多，这里不做介绍
![[00 assets/5597fc9f33fb51f2c75a63564175cbcb_MD5.png]]

3、第一次还是会进入到 patchBlockChildren，这是因为要对外层的 div 和 button 进行 diff 操作
![[00 assets/d5ae12eb91bcdfe0851f7e12f1bb634b_MD5.png]]

![[00 assets/d8dcd946d52d6553c37daac7fa5d8f3a_MD5.png]]

4、我们再往后调试就可以看到进入到 patchChildren，根据上面描述，如果是外层的就会使用 patchBlock 的模式更新，而内部的列表就会使用 patchChildren 来进行更新
![[00 assets/380c845f4d49f65a9d14b8c81a1109c1_MD5.png]]

5、因为没有 key，后面就会进入到 patchUnkeyedChildren 来进行更新
![[00 assets/232ebbf39a3313e422bc64e16f5444e5_MD5.png]]

6、如果按照下面的方式就会进入到比对的算法，其实很简单，就是一个个比较，多了就删除，少了就挂载
![[00 assets/7446651b521c4fb2431f523d7cc15e1d_MD5.png]]

### 22.3.3 有 key diff

目前调试的代码如下

![[00 assets/61dc97a39bbaa6f498d5c897d145f8ad_MD5.png]]

1、进入到 有 key diff 算法可以参考上述的 22.3.2 中的解释

2、具体的实现可以参考视频的介绍

3、针对有 key 的 diff 计算，首先是 头部节点比对、尾部节点比对、剩余节点比对、随后创建一个 newIndexToOldIndexMap 数组，计算出最长递增子序列

4、Vue2 对比 Vue3 主要是差异是处理完首尾节点后，对剩余节点的处理方式；

vue2 是通过对旧节点列表建立一个 { key, oldVnode }的映射表，然后遍历新节点列表的剩余节点，根据 newVnode.key 在旧映射表中寻找可复用的节点，然后打补丁并且移动到正确的位置；

vue3 则是建立一个存储新节点数组中的剩余节点在旧节点数组上的索引的映射关系数组，建立完成这个数组后也即找到了可复用的节点，然后通过这个数组计算得到最长递增子序列，这个序列中的节点保持不动，然后将新节点数组中的剩余节点移动到正确的位置。

## 22.4 reactive

### 22.4.1 响应式系统搭建

1、使用 npm run dev reactivity 来生成响应式 js

2、使用 effect 函数来包裹，如果 person 修改就会执行

![[00 assets/7f5d9ba7ad8fcab6e04a40bed06f90e0_MD5.png]]

3、下面就是 reactivity 收集依赖的数据结构
![[00 assets/ce2075bf8b30f901838a1860ba1496bf_MD5.png]]

### 22.4.2 代码查看

1、其实本质就是创建一个 Proxy 代理对象放回，并且会将该创建的对象放进 proxyMap 中，这样就可以返回一样的对象了
![[00 assets/e4b4d2677696942992e9cbede2f60e41_MD5.png]]

2、针对不同的类型，使用不同的代理，查看下图可以知道 COLLECTION 使用 collectionHandlers，而对象使用 baseHandlers

![[00 assets/106f0c41469c314fdc4591efb0308ea6_MD5.png]]

3、这个是对于对象的 Proxy 代理，可以看到这里使用了继承来处理 get，剩余的来填充 set...方法
![[00 assets/14123c3fad4e9f71dea9b83f26c59ea0_MD5.png]]
而针对 Collection 的代理，只有一个 get
![[00 assets/d3391fc38e323aa3521ee25812f5776e_MD5.png]]

## 22.5 effect 函数

1、其实这个 effect 函数的本质和之前写的响应式原理很像，本质就是先执行 effect 函数，同时标记 activeEffect，如果此时响应式 get 触发了就会将该 activeEffect 放进依赖中，如果以后响应式数据再去执行 set() 的话就会去执行放入依赖的 activeEffect。具体可以参考我之前的响应式原理的代码

2、一开始先执行 effect 函数，我们传入的函数其实被包裹到 ReactiveEffect 中，后续就会执行 e.run() 方法

![[00 assets/e1e59a23e4b3b99d0b5753179d28536e_MD5.png]]

3、最后会通过这个方法来执行 fn 函数
![[00 assets/32cd0cf5b83b0a316a6f17e169094d97_MD5.png]]

4、当你执行的时候，内部的响应式就会被触发 get，这个时候就会触发 track 函数
![[00 assets/d934236b09ab8fa96e620b27ad6dc065_MD5.png]]
内部会针对各个数据做 map 映射，会给各个 key 都做映射，key 下面也会去做 fn 的映射
![[00 assets/c16b9b2de2cd0cafa75872def59905f1_MD5.png]]

5、这里就会将 activeEffect 放进依赖中，如果后续
![[00 assets/06c208f1cb65695825dd0f172afd8218_MD5.png]]
![[00 assets/537b1418254e066cd3dff6cf999a038f_MD5.png]]

6、如果你触发响应式的 set，他就会层层拿到你的依赖来执行
![[00 assets/47a7c9641909e3adf49f4b9139da4551_MD5.png]]
他会拿到 depsMap，也就是装 activeEffect 函数的 map，然后再去依次执行
![[00 assets/246ccd86a0ae598fc8d4a1140d8f63a6_MD5.png]]

7、这其实就是一套流程

8、如果是下述的情况，其实就只会收集 isNick 和 nickname 的依赖
![[00 assets/80c0218295d793d155e4eb94e75b9509_MD5.png]]

## 22.6 ref

1、其他它的源码也非常简单，和上述的 effect 是一致的

2、其实 ref 的本质就是使用 createRef，底层其实就是创建一个 new RefImpl()

![[00 assets/376a6362f262c1ed7c7d939e192fdae0_MD5.png]]
![[00 assets/8722d8a9a1cd09805061d56b7ba91d9e_MD5.png]]

3、针对 ref 来说，它底层还做了针对对象传入 ref 的处理，如果你是传入对象就会进入到 toReactive，这个时候就会判断是否使用 reactive 来做代理了
![[00 assets/5d8bd38b3b0d271e44cb01a545ae10fa_MD5.png]]
其实 ref 的本质就是 get 和 set 来实现的，和上述的 reactive 是一致的，如果你 get 的话就会收集依赖，收集依赖也是差不多的。但是还是存在差异的，就是 reactive 内部有很多的 key 所以针对每个 ke 也都要收集依赖，但是 ref 就不需要，直接针对值收集依赖就行
![[00 assets/a5ce8315ed3f3578d74a95a0f4a84254_MD5.png]]

## 22.7 computed

1、下图其实就是最终的原理图，其实本质就是执行多次依赖收集

![[00 assets/05f225fb9c33d4ff05c3acef6a11d1e4_MD5.png]]

2、其他它的本质很简单，就是一个嵌套，如上图代码所示来简单说一下。effect 依赖收集执行一次，此时就会执行 fullName.value 也就是 get 函数，此时就行依赖收集，那么就会将 effect 中的函数收集到 fullName 依赖中，只要 fullName 修改就会执行内部的依赖函数。

3、当你执行之后就会执行内部 computed 内部的函数，也就是 return 的函数，此时就会碰到 firstName 和 lastName，这个时候又会将 computed 内部的函数丢进 firstName 和 lastName 依赖中，只要 firstName 和 lastName 被修改，就会执行内部的依赖，此时 fullName computed 内部的函数就会被执行，值被修改那么 fullName 内部也会执行依赖函数，此时 effect 函数也会被执行

4、上述就是一整套流程，computed 内部也是创建一个 computedRefImpl 类

![[00 assets/1cd8b78eda7efdaa667cbdf70ee6f42d_MD5.png]]

![[00 assets/7a9b57f0f6fecb21620890055ae9940e_MD5.png]]

5、这里还要讨论一个 computed 是否可以缓存，其实本质就是内部有一个 DIRTY 脏值 来做判断，在你第一次创建的时候 computed 就是一个脏值，此时会重新执行依赖。如果 computed 内部的响应式发生改变的话 computed 就会变成 DIRTY 值 重新执行

## 22.8 watch

1、如果你理解了上述的响应式原理其实这个也很简单，我们拿下图来举例说明。下图中 name 为一个响应式 ref，最后 watch 会将传入的 name 转为一个 getter 函数，将这个 getter 函数丢给 name 的响应式依赖，此时 name 发生修改，就会执行 getter 函数，这个 getter 函数又会去执行内部的函数

![[00 assets/a5493be88de18c60c76e173f209823e1_MD5.png]]

2、watch 底层是调用的 doWatch

![[00 assets/07ade0ed2b14c469e376a1646ca876ed_MD5.png]]

doWatch 里面有一个调度系统，有 post、sync、pre 调度，这个可以参考官网，还有 baseWatch 会将传入的传入转为 getter 函数，然后丢进依赖中
![[00 assets/fe3ef14965ef571cdc36c8be6b437f25_MD5.png]]

## 22.9 watchEffect

1、底层其实就是 effect 传入，最后 vue 底层会给你自定义一个 getter
![[00 assets/39f4ebb2e56e080294ef440dfd520099_MD5.png]]

2、同时这里 doWatch 和上述得 watch 一样，会有很多得调度函数
![[00 assets/5667ed9ccfe5d51aab37193d32518ce3_MD5.png]]

3、也就是这里，如果传入得 source 是一个函数，并且没有 cb 得话，就可以认定为 watchEffect，此时会自定义一个 getter
![[00 assets/afe7c95c8694574c1a82c845e6c88a1e_MD5.png]]

## 22.10 编译器

### 22.10.1 基本介绍

![[00 assets/4dc0deace7803eae54a0bbb406d1231e_MD5.png]]
![[00 assets/f348e28b13a2a581b05e4d72f517b0ac_MD5.png]]

### 22.10.2 代码分析

1、其实 compile 是在这个位置，也就是 runtime-core 中得 component 中

![[00 assets/bcaac4a29fcd5fc509343e53c76f594b_MD5.png]]

2、这里 template 就是模板，其实本质就是下面得 compile

![[00 assets/16d47f1c09eb592ade60472d130adbb7_MD5.png]]
![[00 assets/a75bcf57b2dee97e0885fd29c48b3f19_MD5.png]]

3、这就是最终生成得 ast 树

![[00 assets/4578bcb4e41d594bf8aa3823785dc1d8_MD5.png]]

4、最终上面得代码会转化为如下得代码，最终就是 render 函数

![[00 assets/d02e8858f73733ecdf0df8465d0ba4f4_MD5.png]]

## 22.11 调度系统

### 22.11.1 基本介绍

![[00 assets/32d5a973b9c76b052599265265714bcf_MD5.png]]

### 22.11.2 代码介绍

1、更新操作在 微任务 中执行，所以说更新 UI 是异步得；下图就是调度系统得核心代码

2、针对 queuePostFlushCbs 本质是有 2 个队列得，pendingPostFlushCbs 和 activePostFlushCbs 这 2 个队列，

![[00 assets/eb612eaa88a085d8ad9c9fcf0616b802_MD5.png]]

## 22.12 nextTick

[[vue中nextTick的原理]]

1、下面就是全部的代码
![[00 assets/567725aebfe98fb03b9341a0ff5ae270_MD5.png]]

2、这个其实就是 nextTick 的原理
![[00 assets/94f0bf3005671382abe2dad55734d624_MD5.png]]

## 22.13 keepalive原理

![[00 assets/4cbf7ce844196b2b487addf229364ea9_MD5.jpeg]]


# 23、Pinia 源码解析

# 24、性能优化

^96541f

![[00 assets/e41cd04c8690592f308778ab4a0721a1_MD5.png]]

## 24.1 架构设计

![[00 assets/7933331c8ee9ee5178741a655ccf0878_MD5.png]]

![[00 assets/2190bced3971a2a640401487a39fda9f_MD5.png]]

![[00 assets/daf7e521ab5c1d00c0e7edb02b4ecabf_MD5.png]]

![[00 assets/3eb0c5801c3779e8d5de14355f8fbf0e_MD5.png]]

![[00 assets/fbdfae953656d3875dd0bca8b3c80ca5_MD5.png]]

## 24.2 项目开发

> 框架优化

![[00 assets/6e0f8d77cc4dbfba3dcd394d4cd5ddc9_MD5.png]]

> 公共代码开发

![[00 assets/3aae2bc5f5f6ed696cf5dbc59619ecad_MD5.png]]
![[00 assets/f90d347ef5c480dd16a158b76a6f74e3_MD5.png]]

> 其他方面

![[00 assets/1f2d16167c9a0e1bd00025a26bdc23f2_MD5.png]]

## 24.3 项目部署

![[00 assets/839de0b83c8e6069f532b264e9d42f67_MD5.png]]
![[00 assets/669842adf7da0d7d2ea94d4a4da470e1_MD5.png]]
![[00 assets/0f6b9bf7106da58d5421aa78baad4b0c_MD5.png]]

## 24.4 浏览器 API

### 24.4.1 performance

> performance

![[00 assets/12e15036bd12b968606c80c8ce7fc1c8_MD5.png]]

> 网页加载时间

![[00 assets/765870abc984017a2144b12136c05498_MD5.png]]
![[00 assets/713e6828728cd3e0d7acb36420b9199f_MD5.png]]
![[00 assets/4b583c836b745102434fe8f344e146aa_MD5.png]]

> 浏览器调试

![[00 assets/8cdcf2df78cde9bbf5c26388963fa58a_MD5.png]]

### 24.4.2 network

![[00 assets/4b3998641ee6783ec84d04717a96ef93_MD5.png]]

### 24.4.3 lighthouse

# 25、开放性问题回答

## 25.1 如何看待好的公司

加入大家口中的好公司，好部门而沾沾自喜，显得幼稚而虚荣。但凡思考过如何实现自我价值的互联网人应该都明白一点，一个已经成功的产品带来的荣誉感并不足以填补自己内心的不自信，也不利于提升自己；有能力的人最终会选择打造自己的产品，哪里能给最大的自由，能最大限度实现自己的想法，哪里就是最好的地方。

刚毕业的人喜欢谈论工资，为了一点月薪的差异破坏自己的心情，但到后面会发现，随着工资增长自己的力量并没有变大。最重要的，还是得升级角色，一个高阶角色，并不只代表着权力，更多的是责任和保护的能力。

## 25.2 为什么从上一个公司离职

![[00 assets/1652bfdb87e78593c35d99c4921b0d11_MD5.png]]

## 25.3 hr 面注意问题

[48 个高频面试问题，总结高分回答模板，建议收藏\_牛客网](https://www.nowcoder.com/discuss/364011316049125376)

[面试从此 Easy：一文帮你搞定所有的 HR 面和主管面\_牛客网](https://www.nowcoder.com/discuss/463084541746454528)

[HR 面试面经问题汇总（共计 30+问题，2500+字数）\_牛客网](https://www.nowcoder.com/discuss/612425745993859072)

## 25.4 说下你得优点或者缺点？

> 缺点：

1、缺乏自信

2、工作中不太懂得拒绝别人，尤其是认识的人。但是之后我也会提高自己在这方面的沟通能力，安排好自己的工作计划，希望能够不被这些所影响。

3、我认为我比较大的缺点是我会容易焦虑，如果我写的这个方案没有完全确定下来的话，我就会不停的去想新的方案，直到确定下来，是处于一种不自信的焦虑，自己也在慢慢改掉这个缺点。

> 优点

根据自身情况来讲

## 25.5 针对加班得看法

看情况，如果是因为技术问题加班，那么我就会看是否能研发一个小工具来减少加班量

如果类似黑神话悟空这类突发需求，只能说可以理解，肯定是愿意得

# 26、跨端

## 26.1 请说一下 h5 hybird 技术

基础介绍：[移动端开发必备知识-Hybrid App 面试的时候小伙伴们有没有被问到过 Hybrid App 呢？不得不说了解 Hybrid - 掘金 (juejin.cn)](https://juejin.cn/post/7062967241268019214)

他的本质就是使用 webview 嵌入到设备中使用 JSBridge 来实现网页和原生的信息通讯

如果是安卓设备传入信息到 H5 的话，一般有 loadUrl 方法，但是该方法如何获取函数的返回值，一般在安卓版本 4.4 以下使用；现在主流的是使用 evaluateJavascript 来实现，他可以获取函数的返回值，也是现在比较主流的方式，一般支持 安卓版本 4.4 以上

如果想 H5 给 安卓设备传输信息，可以使用 addJavascriptInerface 来进行注入，H5 使用 window 来调用就行了

# 27、React

## 27.1 React 的常用 hook？useEffect 的作用？听说过 useRef 吗？

常用的 React Hook 包括 `useState`（管理状态）、`useEffect`（处理副作用）、`useContext`（访问上下文）、`useReducer`（复杂状态管理）、`useMemo`（记忆计算结果）、`useCallback`（记忆回调函数），而 `useRef` 用于存储可变值或访问 DOM 元素。

![[00 assets/bec9b10e00d850ccdd3b5002efd3f1db_MD5.png]]

![[00 assets/963880ad9c0e25b75db7a636ebd5ebf3_MD5.png]]
![[00 assets/82286e8b137f9b1ebbf6d9d942e8353e_MD5.png]]

## 27.2 redux的实现原理

[[redux的实现原理]]

## 27.3 讲一下 React Fiber 架构

[[讲一下什么是 React Fiber]]

# 28、CSS原子化

## 28.1 Unocss了解吗

![[00 assets/4fec37e7eaa2189e86b8a3f24ccacbce_MD5.jpeg]]
![[00 assets/13275df818fa3746764151ce1093464b_MD5.jpeg]]
![[00 assets/2847d340c50c8559a6778a4f5007d6cb_MD5.jpeg]]


# 29、后端

## 29.1 nginx如何进行流量按比例转发

![[00 assets/d27ca836a480c3ca19085a4f420040da_MD5.jpeg]]

2、使用 split_clients
![[00 assets/096e49392ef4d143b96c21972157b01b_MD5.jpeg]]

3、使用map模块
![[00 assets/ec31c0d7e5fad6a0267f7a744cd25c24_MD5.jpeg]]
![[00 assets/194ad5cc8cf0043c333d50f2d338d61e_MD5.jpeg]]


# 30、Monorepo

## 31.1 单体仓库monorepo解决了哪些问题？单体仓库有哪些工具及它们的对比优劣势

![[00 assets/29507656d1d6e212e48e0b3ce472bbab_MD5.jpeg]]

## 31.2 单体仓库依赖的管理方式以及包的发布等是怎么处理的

![[00 assets/36891faf1c481162e385b9ff7f89fd5b_MD5.jpeg]]
![[00 assets/7b50957f5e2fb54b6d7d1b0cec4dc776_MD5.jpeg]]

针对于发布来说

![[00 assets/9e44a8df913b51d0814ae3ef1c63d84e_MD5.jpeg]]

# 31、代码规范

## 31.1 eslint9的新特性你知道哪些，性能具体做了哪些优化？eslint是怎么做到用配置规则去检测代码的异常？

![[00 assets/9167688a9f703de43922ba744f4d8756_MD5.jpeg]]![[00 assets/cb34cb64a4467f7f43bfa9576879f038_MD5.jpeg]]

# 32、前端安全

## 32.1 讲一讲你对前端安全的了解，内容安全策略CSP中有个属性不做拦截只做上报了解吗

![[00 assets/4f03396520fbe54cd5d6c0fcd0b29dbd_MD5.jpeg]]
![[00 assets/3716e680bbbc93d54e33799ddbd698e4_MD5.jpeg]]



# 33、开放性问题

## 33.1 你为什么选择前端

![[00 assets/52ba13ac409bd5f7a762dce3eb8f81d0_MD5.jpeg]]