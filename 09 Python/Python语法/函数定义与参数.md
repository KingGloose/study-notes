# 函数定义与参数

关联：[[01 Python语法]] | [[Python语法/类型标注（typing）]] | [[Python语法/异常处理（try、except、finally、raise）]]

## 前端视角对比

- `def` ≈ `function`，但 Python 更强调“关键字参数”（named arguments）
- `*args/**kwargs` ≈ JS 的 rest 参数 + 以对象形式接收其余命名参数
- Python 默认参数“只在函数定义时求值一次”（这一点和 JS 不同，容易踩坑）

## Python 基本写法

```py
def greet(name: str, prefix: str = "Hi") -> str:
    return f"{prefix}, {name}"

greet("Alice")
greet(name="Bob", prefix="Hello")
```

## *args / **kwargs

```py
def f(*args, **kwargs):
    return args, kwargs

f(1, 2, a=3)  # ((1, 2), {'a': 3})
```

对比 JS：

```ts
function f(...args: unknown[]) {
  return args
}
```

## 默认参数易踩坑

不要用可变对象做默认值：

```py
def bad(xs=[]):
    xs.append(1)
    return xs

bad()  # [1]
bad()  # [1, 1]  (很多前端会误以为每次都是新数组)
```

推荐写法：

```py
def good(xs=None):
    if xs is None:
        xs = []
    xs.append(1)
    return xs
```

## 参数的 5 种形态（这才是 Python 的强项）

Python 函数参数大体分为：

- 位置参数（positional）
- 关键字参数（keyword）
- 可变位置参数：`*args`
- 可变关键字参数：`**kwargs`
- 位置专用（positional-only）与关键字专用（keyword-only）参数（进阶但很实用）

### 位置专用 / 关键字专用（/ 与 *）

```py
def f(a, b, /, c, *, d):
    print(a, b, c, d)

f(1, 2, 3, d=4)     # OK
# f(a=1, b=2, c=3, d=4)  # TypeError: a,b 是位置专用
# f(1, 2, 3, 4)          # TypeError: d 是关键字专用
```

什么时候用：

- 写库/公共 API 时，限制调用方式，避免未来重构破坏兼容
- 参数很多时，用关键字专用强制“写出参数名”，可读性更强

## 调用时解包：* / **（非常常用）

```py
def add(a: int, b: int) -> int:
    return a + b

args = (1, 2)
print(add(*args))

kwargs = {"a": 1, "b": 2}
print(add(**kwargs))
```

## 返回多个值：不是魔法，就是 tuple + 解包

```py
def parse_user(text: str) -> tuple[str, int]:
    name, age_s = text.split(":")
    return name, int(age_s)


name, age = parse_user("Alice:18")
```

## lambda：能用，但别滥用

Python 的 `lambda` 只允许单表达式；它在 `sorted(key=...)` 场景最常见：

```py
users = [{"name": "Bob"}, {"name": "Alice"}]
users2 = sorted(users, key=lambda u: u["name"])
```

## 小练习

1. 写一个函数 `build_url(host, *, path="/", https=True)`：用 keyword-only 参数让调用更明确。
2. 写一个 `sum_all(*nums: int) -> int`：返回任意数量整数的和。
3. 写一个排序：按用户字典的 `age` 升序排序（用 `sorted(key=...)` + lambda）。
