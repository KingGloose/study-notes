# 变量与赋值

关联：[[01 Python语法]] | [[Python语法/基本数据类型]] | [[Python语法/作用域（LEGB）与可变、不可变]]

## 前端视角对比

- JS/TS 需要声明（`let/const/var`），Python 不需要；“赋值”本质是把名字绑定到对象
- JS/TS 常见是 camelCase，Python 社区更偏向 snake_case；常量通常用全大写（约定而非关键字）
- JS/TS 有 TDZ（`let/const`），Python 则是“在作用域里只要出现过赋值，这个名字就被视为局部变量”，可能导致 `UnboundLocalError`

## Python 常见写法

```py
x = 1
name = "Alice"

# 多重赋值 / 解包（类似 JS 解构）
x, y = 1, 2

# 交换变量（不需要临时变量）
x, y = y, x
```

## 名字绑定（Name Binding）到底是什么意思

在 Python 里，“变量”不是一个装值的盒子，更像一个**名字**：

- 右侧会先产生/得到一个对象
- 左侧名字会绑定到这个对象上

这就是为什么你会在 [[Python语法/常用容器类型（list、tuple、dict、set）]] 里频繁遇到“共享可变对象”的坑。

```py
a = [1, 2]
b = a
print(a is b)  # True：两个名字指向同一个 list 对象
```

> [!tip] 前端类比
> JS 里 `const arr = []` 并不是“数组不可变”，而是“引用不可重新赋值”；Python 的多数坑和这一点非常像。

## 解包赋值（Unpacking）与星号解包

Python 的解包能力比 JS 的解构更深入（尤其在函数调用、返回值拆分里）。

```py
# 基础解包
x, y = (10, 20)

# 星号解包：收集剩余项
head, *rest = [1, 2, 3, 4]
print(head)  # 1
print(rest)  # [2, 3, 4]

# 忽略值（约定用 _）
_, status = (200, "OK")
```

> [!note] 规则
> 解包的左侧结构必须能匹配右侧的“可迭代对象”的形状；不匹配会抛 `ValueError`。

## 类型标注（Annotation）与赋值

类型标注不会改变运行时语义，但会显著提升 IDE 补全和团队协作体验（见 [[Python语法/类型标注（typing）]]）。

```py
user_id: int = 1
name: str
name = "Alice"  # 先声明后赋值也可以
```

## 海象运算符（Walrus）：:=

当你需要“在表达式内部赋值”时可以用 `:=`（在工程里别滥用，读起来会更像技巧）。

```py
text = "  hello  "
if (s := text.strip()):
    print("non-empty", s)
```

前端类比：把“赋值 + 判断”合并在一起（JS 没有完全等价的语法，通常只能写两行）。

## 复制：浅拷贝 vs 深拷贝（非常常见）

当对象是可变容器时，你经常需要决定“复制到什么程度”。

```py
import copy

xs = [[1], [2]]

shallow = xs.copy()         # 或 xs[:]；只拷贝第一层列表
deep = copy.deepcopy(xs)    # 递归拷贝所有层

shallow[0].append(99)
print(xs)      # [[1, 99], [2]]  浅拷贝共享了内层列表
print(deep)    # [[1], [2]]
```

## 命名与风格（写起来更像 Python）

- 变量/函数：`snake_case`
- 类名：`PascalCase`
- 常量（约定）：`UPPER_CASE`
- 避免用 `list/dict/set/str` 等内置类型名当变量名（会遮蔽 builtins）

## 小练习（写完建议丢进 REPL 跑一遍）

1. 写一个函数 `swap(a, b)`，返回交换后的二元组；用解包赋值写。
2. 给一个嵌套列表 `xs = [[1], [2]]`，分别用浅拷贝和深拷贝复制它，然后修改副本，观察原列表是否变化。
3. 用 `:=` 写一个“读取输入、去空白、非空则继续处理”的小片段。

## 对应到 JS/TS 的心智模型

```ts
let x = 1
const name = "Alice"

// 解构
let a = 1, b = 2
;[a, b] = [b, a]
```

关键差异：

- Python 没有 `const` 关键字；不可变更多来自“值/对象是否可变”以及“不要重新赋值”的团队约定
- Python 的“变量”更像“标签”，指向对象；这点和 JS 引用类型（对象/数组）很像

## 易踩坑

- 赋值不会复制对象：

```py
a = [1, 2]
b = a
b.append(3)
print(a)  # [1, 2, 3]
```

- 想要复制请用：`a.copy()` / `a[:]` / `copy.deepcopy(a)`（取决于浅拷贝/深拷贝需求）
