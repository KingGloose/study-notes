# 运算符

关联：[[01 Python语法]] | [[Python语法/条件语句（if、elif、else）]] | [[Python语法/基本数据类型]]

## 前端视角对比

- Python 没有 `===`，只有 `==`（值相等）和 `is`（同一对象/同一引用，类似“引用相等”）
- Python 没有 `++/--`
- 幂运算用 `**`（JS 用 `**` 也一样）
- 整除用 `//`（JS 需要 `Math.floor(a / b)` 或位运算技巧）
- 逻辑运算用 `and/or/not`（JS 用 `&&/||/!`）

## 常用示例

```py
5 / 2    # 2.5
5 // 2   # 2
5 % 2    # 1
2 ** 3   # 8

"a" in "cat"       # True
1 in [1, 2, 3]      # True

x = None
x is None           # True
```

## 链式比较（非常 Pythonic）

你可以像数学表达式一样写比较：

```py
x = 7
0 < x < 10      # True
```

等价于：`0 < x and x < 10`（且 `x` 只会被求值一次）。

## 位运算（写后端/算法/权限位时会用到）

```py
1 << 3     # 8
8 >> 1     # 4
5 & 3      # 1
5 | 3      # 7
5 ^ 3      # 6
~5         # -6（注意：Python 的 int 是无限精度，~ 的结果是补码意义上的）
```

## in / not in：成员关系判断

```py
"py" in {"py", "js"}      # set membership
"name" in {"name": 1}      # dict membership：只判断 key
```

> [!tip] 工程建议
> 需要频繁 membership 判断时，优先用 `set` 或 `dict`（见 [[Python语法/常用容器类型（list、tuple、dict、set）]]）。

## and/or 的短路 + 返回值（再强调一次）

短路不仅是性能点，更是控制流表达方式：

```py
user = {"name": "Alice"}
name = user.get("name") or "Anonymous"  # 为空则给默认值
```

## 优先级（不要求死记，但要避免误读）

经验法则：

- 复杂表达式尽量加括号，省得未来自己读不懂
- 条件表达式拆开写成中间变量，胜过写“聪明的一行”

## 小练习

1. 写一个函数判断 `x` 是否在 `[0, 100)` 区间（用链式比较）。
2. 用 `or` 写一个“可空值回退”的表达式：优先取环境变量，否则取默认值。（涉及读取环境变量时可拓展到 [[Python语法/模块与包（import）]] / `os.environ`）

## 重要差异：== vs is

- `==`：值相等（类似 JS `a == b` 或 `a === b` 的“值比较”语义）
- `is`：对象标识相等（类似 JS `objA === objB` 对引用类型的比较）

规则建议：

- 判断 `None` 用 `is None`
- 其他情况一般用 `==`

## 逻辑运算返回值

和 JS 一样，Python 的 `and/or` 也会返回“最后一个被求值的操作数”，不一定是 `True/False`：

```py
"" or "fallback"     # "fallback"
"hi" and 123         # 123
```
