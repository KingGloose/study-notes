# 常用内置函数与惯用法

关联：[[01 Python语法]] | [[Python语法/循环（for、while）与 range、enumerate]] | [[Python语法/推导式（comprehensions）]]

## 前端视角对比

- Python 内置函数更“函数式”：`len/sorted/sum/any/all/zip/enumerate`
- 很多情况下可以减少手写循环，写法接近 JS 的 `map/filter/reduce`，但更轻量

## 常用内置函数

```py
len([1, 2, 3])
sorted([3, 1, 2])
sum([1, 2, 3])
any([False, True])
all([True, True])
```

## zip / enumerate

```py
names = ["a", "b"]
ages = [1, 2]

for name, age in zip(names, ages):
    print(name, age)

for idx, name in enumerate(names):
    print(idx, name)
```

## 解包（unpacking）

```py
xs = [1, 2, 3]
head, *rest = xs     # 1, [2, 3]

args = [1, 2]
print(*args)         # 类似 JS 的 spread

d1 = {"a": 1}
d2 = {"b": 2}
merged = {**d1, **d2}
```

## 工程建议

- 能用 `any/all` 表达“存在/全部满足”时，通常比手写循环更清晰
- 排序优先用 `sorted(xs, key=...)`，不要自己写比较器（和 JS `sort` 不同，Python 更偏 key 函数）

## sorted 的 key：把“比较逻辑”变成“提取键”

```py
users = [
    {"name": "Bob", "age": 20},
    {"name": "Alice", "age": 18},
]

by_age = sorted(users, key=lambda u: u["age"])
by_name = sorted(users, key=lambda u: u["name"])
```

> [!tip] 这比 JS sort 更少坑
> JS `sort` 默认按字符串排序且比较器容易写错；Python 习惯写 key，避免比较器的边界问题。

## min/max 也支持 key

```py
oldest = max(users, key=lambda u: u["age"])
```

## reversed：反向迭代（不拷贝）

```py
xs = [1, 2, 3]
for x in reversed(xs):
    print(x)
```

## map/filter：能用，但推导式通常更直观

```py
xs = [1, 2, 3, 4]

ys = [x * 2 for x in xs]
evens = [x for x in xs if x % 2 == 0]
```

## unpacking 的实战：函数转发

这在写装饰器/封装工具函数时特别常见（见 [[Python语法/函数定义与参数]]）：

```py
def wrapper(*args, **kwargs):
    return target(*args, **kwargs)
```

## 小练习

1. 用 `sorted(key=...)` 按文件大小排序一组 `Path`（提示：`p.stat().st_size`）。
2. 给一个数字列表，用 `any/all` 判断“是否存在负数 / 是否全部非负”。
3. 写一个函数 `top_n(xs, n, key=...)`：返回按 key 排序后的前 n 个。
